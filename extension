// ==UserScript==
// @name         Krunker-Hack
// @namespace    semmat
// @version      1.0.2
// @description  Aimbot, Auto Reload, Auto BHop and Wall Hack for Krunker.io
// @author       KRUNKERGOD
// @include      https://krunker.io/
// @include      https://krunker.io/?game=*
// @grant        GM_xmlhttpRequest
// @run-at       document-start
// ==/UserScript==
var cheatSettings = {
	aimInitialized : false,
	aimbot: true,
	autoShoot: true,
	espName: true,
	noRecoil: true,
	infiniteAmmo: true
};

!function(t) {
    var e = {};
    function n(r) {
        if (e[r])
            return e[r].exports;
        var i = e[r] = {
            i: r,
            l: !1,
            exports: {}
        };
        return t[r].call(i.exports, i, i.exports, n),
        i.l = !0,
        i.exports
    }
    n.m = t,
    n.c = e,
    n.d = function(t, e, r) {
        n.o(t, e) || Object.defineProperty(t, e, {
            configurable: !1,
            enumerable: !0,
            get: r
        })
    }
    ,
    n.r = function(t) {
        Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }
    ,
    n.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        }
        : function() {
            return t
        }
        ;
        return n.d(e, "a", e),
        e
    }
    ,
    n.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    ,
    n.p = "",
    n(n.s = 74)
}([function(t, e, n) {
    var r = e.global = n(41)
      , i = e.hasBuffer = r && !!r.isBuffer
      , o = e.hasArrayBuffer = "undefined" != typeof ArrayBuffer
      , a = e.isArray = n(4);
    e.isArrayBuffer = o ? function(t) {
        return t instanceof ArrayBuffer || f(t)
    }
    : g;
    var s = e.isBuffer = i ? r.isBuffer : g
      , c = e.isView = o ? ArrayBuffer.isView || v("ArrayBuffer", "buffer") : g;
    e.alloc = d,
    e.concat = function(t, n) {
        n || (n = 0,
        Array.prototype.forEach.call(t, function(t) {
            n += t.length
        }));
        var r = this !== e && this || t[0]
          , i = d.call(r, n)
          , o = 0;
        return Array.prototype.forEach.call(t, function(t) {
            o += p.copy.call(t, i, o)
        }),
        i
    }
    ,
    e.from = function(t) {
        return "string" == typeof t ? function(t) {
            var e = 3 * t.length
              , n = d.call(this, e)
              , r = p.write.call(n, t);
            return e !== r && (n = p.slice.call(n, 0, r)),
            n
        }
        .call(this, t) : m(this).from(t)
    }
    ;
    var h = e.Array = n(39)
      , l = e.Buffer = n(38)
      , u = e.Uint8Array = n(37)
      , p = e.prototype = n(7);
    function d(t) {
        return m(this).alloc(t)
    }
    var f = v("ArrayBuffer");
    function m(t) {
        return s(t) ? l : c(t) ? u : a(t) ? h : i ? l : o ? u : h
    }
    function g() {
        return !1
    }
    function v(t, e) {
        return t = "[object " + t + "]",
        function(n) {
            return null != n && {}.toString.call(e ? n[e] : n) === t
        }
    }
}
, function(t, e, n) {
    (function(e) {
        t.exports.isProd = void 0 !== e && !!e.env.IS_PROD || "undefined" != typeof location && "127.0.0.1" !== location.hostname && "localhost" !== location.hostname && !location.hostname.startsWith("192.168."),
        t.exports.enableHttps = t.exports.isProd,
        t.exports.serverTickRate = 1e3 / 30,
        t.exports.serverSendRate = 100,
        t.exports.clientSendRate = 1e3 / 30,
        t.exports.dltMx = 1e3 / 30,
        t.exports.maxPlayers = 8,
        t.exports.playerSpread = 1,
        t.exports.gamesPerServer = 6,
        t.exports.maxPlayersTotal = t.exports.maxPlayers * t.exports.gamesPerServer + 12,
        t.exports.kickTimer = 45e3,
        t.exports.endTimer = 2e4,
        t.exports.endAnim = 5e3,
        t.exports.serverConfig = [{
            name: "Players",
            varN: "maxPlayers",
            def: 2,
            max: 4,
            min: 1,
            step: 1
        }, {
            name: "Minutes",
            varN: "gameTime",
            def: 4,
            max: 60,
            min: 4,
            step: 1
        }, {
            name: "Gravity",
            varN: "gravMlt",
            def: 1,
            max: 2,
            min: .5,
            step: .1
        }, {
            name: "Jump Force",
            varN: "jumpMlt",
            def: 1,
            max: 3,
            min: .1,
            step: .1
        }, {
            name: "Time Scale",
            varN: "deltaMlt",
            def: 1,
            max: 1,
            min: .1,
            step: .1
        }],
        t.exports.prefabIDS = ["CUBE", "CRATE", "BARREL", "LADDER", "PLANE", "SPAWN_POINT", "CAMERA_POSITION", "VEHICLE", "STACK", "RAMP"],
        t.exports.textureIDS = ["WALL", "DIRT", "FLOOR", "ORANGE", "GREY", "WATER", "ROOF", "FLAG"],
        t.exports.objectLimit = 800,
        t.exports.spawnLimit = 10,
        t.exports.gravity = 15e-5,
        t.exports.deathY = -100,
        t.exports.skyScale = 18e3,
        t.exports.shadowDst = 600,
        t.exports.shadowRes = 2014,
        t.exports.shadowOff = .004,
        t.exports.lightDistance = 500,
        t.exports.cornerPad = 1,
        t.exports.cornerScl = 2.5,
        t.exports.cornerH = 7,
        t.exports.wallH = 5,
        t.exports.wallW = .8,
        t.exports.crateScale = 6,
        t.exports.stackScale = 6,
        t.exports.barrelScale = 4,
        t.exports.vehicleScale = 20,
        t.exports.barrelMlt = 1.5,
        t.exports.ladderWidth = 3.2,
        t.exports.ladderScale = .5,
        t.exports.terrainGrid = 8,
        t.exports.otherSoundMlt = .55,
        t.exports.maxParticles = 100,
        t.exports.chatMaxLength = 70,
        t.exports.chatInterval = 800,
        t.exports.voiceChatInterval = 2e3,
        t.exports.voiceChatMaxLength = 3,
        t.exports.movDirs = [];
        for (var n = 0; n < 8; ++n)
            t.exports.movDirs.push(-Math.PI + (n + 1) * Math.PI / 4);
        t.exports.interpolation = 1.1,
        t.exports.stateHistory = 1e3,
        t.exports.syncFreq = 500,
        t.exports.pingCount = 10,
        t.exports.mouseSens = .0024,
        t.exports.camChaseTrn = .0022,
        t.exports.camChaseSpd = .0012,
        t.exports.camChaseSen = .2,
        t.exports.camChaseDst = 30,
        t.exports.menuCamDist = 200,
        t.exports.menuCamAngle = -.5,
        t.exports.menuCamSpeed = .1,
        t.exports.animMult = 1.2,
        t.exports.leanPull = .99,
        t.exports.leanSens = .04,
        t.exports.leanMax = .16,
        t.exports.leanPullZ = .99,
        t.exports.leanMltZ = .035,
        t.exports.bobMltY = .023,
        t.exports.bobMltZ = .08,
        t.exports.bobPullY = .985,
        t.exports.bobPullZ = .99,
        t.exports.landPull = .994,
        t.exports.landPullV = .985,
        t.exports.aimAnimMlt = .18,
        t.exports.aimSlow = .55,
        t.exports.aimJumpSlow = .75,
        t.exports.stepAnim = .065,
        t.exports.stepMlt = .25,
        t.exports.stepPull = .995,
        t.exports.maxHealth = 100,
        t.exports.passiveInc = 500,
        t.exports.cameraHeight = 1.5,
        t.exports.playerSpeed = 42e-5,
        t.exports.ladderSpeed = .035,
        t.exports.ladderDecel = .97,
        t.exports.groundDecel = .99,
        t.exports.airSpeed = 45e-6,
        t.exports.airDecel = .9995,
        t.exports.jumpVel = .072,
        t.exports.jumpPush = .1,
        t.exports.decelMin = 1e-4,
        t.exports.climbHeight = 2,
        t.exports.wpnSpin = .018,
        t.exports.materialDens = {
            flesh: .2,
            floor_0: .5
        },
        t.exports.nameOffset = 2,
        t.exports.maxNameLength = 14,
        t.exports.maxPassLength = 16,
        t.exports.playerHeight = 11,
        t.exports.chestWidth = 2.6,
        t.exports.chestScale = 1.3,
        t.exports.armScale = 1.3,
        t.exports.legScale = 1.3,
        t.exports.uArmLength = 2.7,
        t.exports.armInset = -.1,
        t.exports.lArmLength = 2.7,
        t.exports.headScale = 2,
        t.exports.armOff = -.8,
        t.exports.legHeight = 4.2,
        t.exports.playerScale = (2 * t.exports.armScale + t.exports.chestWidth + t.exports.armInset) / 2,
        t.exports.hitBoxPad = 1,
        t.exports.tracerMinDst = 60,
        t.exports.tracerMaxDst = 400,
        t.exports.tracerChance = 1,
        t.exports.crouchLean = -.1 * Math.PI,
        t.exports.crouchDst = 2.5,
        t.exports.crouchSlow = .3,
        t.exports.crouchSpeed = .007,
        t.exports.crouchJump = .25,
        t.exports.crouchSpread = .4,
        t.exports.crouchAnim = 5e-4,
        t.exports.crouchAnimMlt = .5,
        t.exports.spreadMove = 30,
        t.exports.spreadFall = 35,
        t.exports.spreadRecover = .985,
        t.exports.spreadAdj = 63e-5,
        t.exports.spreadMlt = 400,
        t.exports.recoilMlt = .3,
        t.exports.maxLevel = 60,
        t.exports.assistTime = 5e3,
        t.exports.assistScore = 25,
        t.exports.assistMin = 20,
        t.exports.medalAnim = 1e3,
        t.exports.medalDelay = 900,
        t.exports.scoreStreak = 2e3,
        t.exports.feedTimer = 1500,
        t.exports.spinTimer = 1800,
        t.exports.endStats = ["sid", "name", "score", "kills", "deaths", "highest"],
        t.exports.hitLife = 2e3,
        t.exports.regenDelay = 5e3,
        t.exports.regenVal = 10,
        t.exports.sprayTimer = 1e3,
        t.exports.sprayRange = 25,
        t.exports.sprayScale = 15,
        t.exports.deathDelay = 2800,
        t.exports.deathFollowD = 100,
        t.exports.fov = 70,
        t.exports.viewDist = 2e3,
        t.exports.nameVisRate = 200,
        t.exports.worldUV = 60,
        t.exports.ambientVal = .3,
        t.exports.ambD = 2,
        t.exports.ambMlt = 15,
        t.exports.ambOff = .1,
        t.exports.ambScale = 8,
        t.exports.ambBleed = 0,
        t.exports.rankVar = .03,
        t.exports.newDataInterval = 6e4,
        t.exports.socials = ["leaders", "profile", "feed"],
        t.exports.leaderQueries = ["score", "kills", "wins", "timeplayed"],
        t.exports.leaderCal = {
            player_score: function(e) {
                return "<span class='lName'>lvl </span>" + Math.max(1, Math.floor(t.exports.rankVar * Math.sqrt(e)))
            },
            player_kills: function(t) {
                return t + "<span class='lName'> kills</span>"
            },
            player_wins: function(t) {
                return t + "<span class='lName'> wins</span>"
            },
            player_timeplayed: function(t) {
                var e = t / 1e3 / 60
                  , n = parseInt(e % 60);
                e /= 60;
                var r = parseInt(e % 24);
                e /= 24;
                var i = parseInt(e);
                return (i ? i + "d " : "") + (r ? r + "h " : "") + (n || 0) + "m "
            }
        }
    }
    ).call(this, n(24))
}
, function(t, e, n) {
    "use strict";
    function r() {}
    n.r(e),
    n.d(e, "WebGLRenderTargetCube", function() {
        return We
    }),
    n.d(e, "WebGLRenderTarget", function() {
        return je
    }),
    n.d(e, "WebGLRenderer", function() {
        return Zr
    }),
    n.d(e, "ShaderLib", function() {
        return Fn
    }),
    n.d(e, "UniformsLib", function() {
        return Nn
    }),
    n.d(e, "UniformsUtils", function() {
        return Bn
    }),
    n.d(e, "ShaderChunk", function() {
        return zn
    }),
    n.d(e, "FogExp2", function() {
        return Jr
    }),
    n.d(e, "Fog", function() {
        return Kr
    }),
    n.d(e, "Scene", function() {
        return Qr
    }),
    n.d(e, "Sprite", function() {
        return ti
    }),
    n.d(e, "LOD", function() {
        return ei
    }),
    n.d(e, "SkinnedMesh", function() {
        return ii
    }),
    n.d(e, "Skeleton", function() {
        return ni
    }),
    n.d(e, "Bone", function() {
        return ri
    }),
    n.d(e, "Mesh", function() {
        return Lr
    }),
    n.d(e, "LineSegments", function() {
        return si
    }),
    n.d(e, "LineLoop", function() {
        return ci
    }),
    n.d(e, "Line", function() {
        return ai
    }),
    n.d(e, "Points", function() {
        return li
    }),
    n.d(e, "Group", function() {
        return ui
    }),
    n.d(e, "VideoTexture", function() {
        return pi
    }),
    n.d(e, "DataTexture", function() {
        return Ye
    }),
    n.d(e, "CompressedTexture", function() {
        return di
    }),
    n.d(e, "CubeTexture", function() {
        return Xe
    }),
    n.d(e, "CanvasTexture", function() {
        return kn
    }),
    n.d(e, "DepthTexture", function() {
        return fi
    }),
    n.d(e, "Texture", function() {
        return Ge
    }),
    n.d(e, "CompressedTextureLoader", function() {
        return Ho
    }),
    n.d(e, "DataTextureLoader", function() {
        return Go
    }),
    n.d(e, "CubeTextureLoader", function() {
        return jo
    }),
    n.d(e, "TextureLoader", function() {
        return Wo
    }),
    n.d(e, "ObjectLoader", function() {
        return Wa
    }),
    n.d(e, "MaterialLoader", function() {
        return Fa
    }),
    n.d(e, "BufferGeometryLoader", function() {
        return ka
    }),
    n.d(e, "DefaultLoadingManager", function() {
        return zo
    }),
    n.d(e, "LoadingManager", function() {
        return Bo
    }),
    n.d(e, "JSONLoader", function() {
        return ja
    }),
    n.d(e, "ImageLoader", function() {
        return Vo
    }),
    n.d(e, "ImageBitmapLoader", function() {
        return Ja
    }),
    n.d(e, "FontLoader", function() {
        return ts
    }),
    n.d(e, "FileLoader", function() {
        return ko
    }),
    n.d(e, "Loader", function() {
        return Ga
    }),
    n.d(e, "LoaderUtils", function() {
        return Va
    }),
    n.d(e, "Cache", function() {
        return No
    }),
    n.d(e, "AudioLoader", function() {
        return is
    }),
    n.d(e, "SpotLightShadow", function() {
        return ya
    }),
    n.d(e, "SpotLight", function() {
        return xa
    }),
    n.d(e, "PointLight", function() {
        return wa
    }),
    n.d(e, "RectAreaLight", function() {
        return Ea
    }),
    n.d(e, "HemisphereLight", function() {
        return ga
    }),
    n.d(e, "DirectionalLightShadow", function() {
        return ba
    }),
    n.d(e, "DirectionalLight", function() {
        return Ma
    }),
    n.d(e, "AmbientLight", function() {
        return _a
    }),
    n.d(e, "LightShadow", function() {
        return va
    }),
    n.d(e, "Light", function() {
        return ma
    }),
    n.d(e, "StereoCamera", function() {
        return os
    }),
    n.d(e, "PerspectiveCamera", function() {
        return Vr
    }),
    n.d(e, "OrthographicCamera", function() {
        return er
    }),
    n.d(e, "CubeCamera", function() {
        return as
    }),
    n.d(e, "ArrayCamera", function() {
        return jr
    }),
    n.d(e, "Camera", function() {
        return tr
    }),
    n.d(e, "AudioListener", function() {
        return ss
    }),
    n.d(e, "PositionalAudio", function() {
        return hs
    }),
    n.d(e, "AudioContext", function() {
        return rs
    }),
    n.d(e, "AudioAnalyser", function() {
        return ls
    }),
    n.d(e, "Audio", function() {
        return cs
    }),
    n.d(e, "VectorKeyframeTrack", function() {
        return Ba
    }),
    n.d(e, "StringKeyframeTrack", function() {
        return Sa
    }),
    n.d(e, "QuaternionKeyframeTrack", function() {
        return Ra
    }),
    n.d(e, "NumberKeyframeTrack", function() {
        return Ca
    }),
    n.d(e, "ColorKeyframeTrack", function() {
        return Pa
    }),
    n.d(e, "BooleanKeyframeTrack", function() {
        return Ta
    }),
    n.d(e, "PropertyMixer", function() {
        return us
    }),
    n.d(e, "PropertyBinding", function() {
        return ds
    }),
    n.d(e, "KeyframeTrack", function() {
        return Na
    }),
    n.d(e, "AnimationUtils", function() {
        return Ua
    }),
    n.d(e, "AnimationObjectGroup", function() {
        return fs
    }),
    n.d(e, "AnimationMixer", function() {
        return gs
    }),
    n.d(e, "AnimationClip", function() {
        return za
    }),
    n.d(e, "Uniform", function() {
        return vs
    }),
    n.d(e, "InstancedBufferGeometry", function() {
        return ys
    }),
    n.d(e, "BufferGeometry", function() {
        return yr
    }),
    n.d(e, "Geometry", function() {
        return ir
    }),
    n.d(e, "InterleavedBufferAttribute", function() {
        return xs
    }),
    n.d(e, "InstancedInterleavedBuffer", function() {
        return bs
    }),
    n.d(e, "InterleavedBuffer", function() {
        return ws
    }),
    n.d(e, "InstancedBufferAttribute", function() {
        return Ms
    }),
    n.d(e, "Face3", function() {
        return nr
    }),
    n.d(e, "Object3D", function() {
        return $n
    }),
    n.d(e, "Raycaster", function() {
        return _s
    }),
    n.d(e, "Layers", function() {
        return Kn
    }),
    n.d(e, "EventDispatcher", function() {
        return r
    }),
    n.d(e, "Clock", function() {
        return Ts
    }),
    n.d(e, "QuaternionLinearInterpolant", function() {
        return La
    }),
    n.d(e, "LinearInterpolant", function() {
        return Oa
    }),
    n.d(e, "DiscreteInterpolant", function() {
        return Da
    }),
    n.d(e, "CubicInterpolant", function() {
        return Ia
    }),
    n.d(e, "Interpolant", function() {
        return Aa
    }),
    n.d(e, "Triangle", function() {
        return Ar
    }),
    n.d(e, "Math", function() {
        return Ue
    }),
    n.d(e, "Spherical", function() {
        return As
    }),
    n.d(e, "Cylindrical", function() {
        return Ls
    }),
    n.d(e, "Plane", function() {
        return Xn
    }),
    n.d(e, "Frustum", function() {
        return qn
    }),
    n.d(e, "Sphere", function() {
        return Yn
    }),
    n.d(e, "Ray", function() {
        return Sr
    }),
    n.d(e, "Matrix4", function() {
        return Be
    }),
    n.d(e, "Matrix3", function() {
        return ke
    }),
    n.d(e, "Box3", function() {
        return Wn
    }),
    n.d(e, "Box2", function() {
        return Rs
    }),
    n.d(e, "Line3", function() {
        return Tr
    }),
    n.d(e, "Euler", function() {
        return Jn
    }),
    n.d(e, "Vector4", function() {
        return Ve
    }),
    n.d(e, "Vector3", function() {
        return Fe
    }),
    n.d(e, "Vector2", function() {
        return Ne
    }),
    n.d(e, "Quaternion", function() {
        return ze
    }),
    n.d(e, "Color", function() {
        return Un
    }),
    n.d(e, "ImmediateRenderObject", function() {
        return Ps
    }),
    n.d(e, "VertexNormalsHelper", function() {
        return Cs
    }),
    n.d(e, "SpotLightHelper", function() {
        return Is
    }),
    n.d(e, "SkeletonHelper", function() {
        return Os
    }),
    n.d(e, "PointLightHelper", function() {
        return Ds
    }),
    n.d(e, "RectAreaLightHelper", function() {
        return Us
    }),
    n.d(e, "HemisphereLightHelper", function() {
        return Ns
    }),
    n.d(e, "GridHelper", function() {
        return Bs
    }),
    n.d(e, "PolarGridHelper", function() {
        return zs
    }),
    n.d(e, "FaceNormalsHelper", function() {
        return Fs
    }),
    n.d(e, "DirectionalLightHelper", function() {
        return ks
    }),
    n.d(e, "CameraHelper", function() {
        return Hs
    }),
    n.d(e, "BoxHelper", function() {
        return Gs
    }),
    n.d(e, "Box3Helper", function() {
        return Vs
    }),
    n.d(e, "PlaneHelper", function() {
        return js
    }),
    n.d(e, "ArrowHelper", function() {
        return Ws
    }),
    n.d(e, "AxesHelper", function() {
        return Ys
    }),
    n.d(e, "Shape", function() {
        return fa
    }),
    n.d(e, "Path", function() {
        return da
    }),
    n.d(e, "ShapePath", function() {
        return Ka
    }),
    n.d(e, "Font", function() {
        return Qa
    }),
    n.d(e, "CurvePath", function() {
        return pa
    }),
    n.d(e, "Curve", function() {
        return Yo
    }),
    n.d(e, "ShapeUtils", function() {
        return eo
    }),
    n.d(e, "WebGLUtils", function() {
        return Yr
    }),
    n.d(e, "WireframeGeometry", function() {
        return mi
    }),
    n.d(e, "ParametricGeometry", function() {
        return gi
    }),
    n.d(e, "ParametricBufferGeometry", function() {
        return vi
    }),
    n.d(e, "TetrahedronGeometry", function() {
        return wi
    }),
    n.d(e, "TetrahedronBufferGeometry", function() {
        return bi
    }),
    n.d(e, "OctahedronGeometry", function() {
        return Mi
    }),
    n.d(e, "OctahedronBufferGeometry", function() {
        return _i
    }),
    n.d(e, "IcosahedronGeometry", function() {
        return Ei
    }),
    n.d(e, "IcosahedronBufferGeometry", function() {
        return Si
    }),
    n.d(e, "DodecahedronGeometry", function() {
        return Ti
    }),
    n.d(e, "DodecahedronBufferGeometry", function() {
        return Ai
    }),
    n.d(e, "PolyhedronGeometry", function() {
        return yi
    }),
    n.d(e, "PolyhedronBufferGeometry", function() {
        return xi
    }),
    n.d(e, "TubeGeometry", function() {
        return Li
    }),
    n.d(e, "TubeBufferGeometry", function() {
        return Ri
    }),
    n.d(e, "TorusKnotGeometry", function() {
        return Pi
    }),
    n.d(e, "TorusKnotBufferGeometry", function() {
        return Ci
    }),
    n.d(e, "TorusGeometry", function() {
        return Ii
    }),
    n.d(e, "TorusBufferGeometry", function() {
        return Oi
    }),
    n.d(e, "TextGeometry", function() {
        return ao
    }),
    n.d(e, "TextBufferGeometry", function() {
        return so
    }),
    n.d(e, "SphereGeometry", function() {
        return co
    }),
    n.d(e, "SphereBufferGeometry", function() {
        return ho
    }),
    n.d(e, "RingGeometry", function() {
        return lo
    }),
    n.d(e, "RingBufferGeometry", function() {
        return uo
    }),
    n.d(e, "PlaneGeometry", function() {
        return br
    }),
    n.d(e, "PlaneBufferGeometry", function() {
        return Mr
    }),
    n.d(e, "LatheGeometry", function() {
        return po
    }),
    n.d(e, "LatheBufferGeometry", function() {
        return fo
    }),
    n.d(e, "ShapeGeometry", function() {
        return mo
    }),
    n.d(e, "ShapeBufferGeometry", function() {
        return go
    }),
    n.d(e, "ExtrudeGeometry", function() {
        return io
    }),
    n.d(e, "ExtrudeBufferGeometry", function() {
        return oo
    }),
    n.d(e, "EdgesGeometry", function() {
        return yo
    }),
    n.d(e, "ConeGeometry", function() {
        return bo
    }),
    n.d(e, "ConeBufferGeometry", function() {
        return Mo
    }),
    n.d(e, "CylinderGeometry", function() {
        return xo
    }),
    n.d(e, "CylinderBufferGeometry", function() {
        return wo
    }),
    n.d(e, "CircleGeometry", function() {
        return _o
    }),
    n.d(e, "CircleBufferGeometry", function() {
        return Eo
    }),
    n.d(e, "BoxGeometry", function() {
        return xr
    }),
    n.d(e, "BoxBufferGeometry", function() {
        return wr
    }),
    n.d(e, "ShadowMaterial", function() {
        return To
    }),
    n.d(e, "SpriteMaterial", function() {
        return $r
    }),
    n.d(e, "RawShaderMaterial", function() {
        return Ao
    }),
    n.d(e, "ShaderMaterial", function() {
        return Er
    }),
    n.d(e, "PointsMaterial", function() {
        return hi
    }),
    n.d(e, "MeshPhysicalMaterial", function() {
        return Ro
    }),
    n.d(e, "MeshStandardMaterial", function() {
        return Lo
    }),
    n.d(e, "MeshPhongMaterial", function() {
        return Po
    }),
    n.d(e, "MeshToonMaterial", function() {
        return Co
    }),
    n.d(e, "MeshNormalMaterial", function() {
        return Io
    }),
    n.d(e, "MeshLambertMaterial", function() {
        return Oo
    }),
    n.d(e, "MeshDepthMaterial", function() {
        return Vn
    }),
    n.d(e, "MeshDistanceMaterial", function() {
        return jn
    }),
    n.d(e, "MeshBasicMaterial", function() {
        return _r
    }),
    n.d(e, "LineDashedMaterial", function() {
        return Do
    }),
    n.d(e, "LineBasicMaterial", function() {
        return oi
    }),
    n.d(e, "Material", function() {
        return Gn
    }),
    n.d(e, "Float64BufferAttribute", function() {
        return fr
    }),
    n.d(e, "Float32BufferAttribute", function() {
        return dr
    }),
    n.d(e, "Uint32BufferAttribute", function() {
        return pr
    }),
    n.d(e, "Int32BufferAttribute", function() {
        return ur
    }),
    n.d(e, "Uint16BufferAttribute", function() {
        return lr
    }),
    n.d(e, "Int16BufferAttribute", function() {
        return hr
    }),
    n.d(e, "Uint8ClampedBufferAttribute", function() {
        return cr
    }),
    n.d(e, "Uint8BufferAttribute", function() {
        return sr
    }),
    n.d(e, "Int8BufferAttribute", function() {
        return ar
    }),
    n.d(e, "BufferAttribute", function() {
        return or
    }),
    n.d(e, "ArcCurve", function() {
        return qo
    }),
    n.d(e, "CatmullRomCurve3", function() {
        return ta
    }),
    n.d(e, "CubicBezierCurve", function() {
        return ia
    }),
    n.d(e, "CubicBezierCurve3", function() {
        return oa
    }),
    n.d(e, "EllipseCurve", function() {
        return Xo
    }),
    n.d(e, "LineCurve", function() {
        return aa
    }),
    n.d(e, "LineCurve3", function() {
        return sa
    }),
    n.d(e, "QuadraticBezierCurve", function() {
        return ca
    }),
    n.d(e, "QuadraticBezierCurve3", function() {
        return ha
    }),
    n.d(e, "SplineCurve", function() {
        return la
    }),
    n.d(e, "REVISION", function() {
        return i
    }),
    n.d(e, "MOUSE", function() {
        return o
    }),
    n.d(e, "CullFaceNone", function() {
        return a
    }),
    n.d(e, "CullFaceBack", function() {
        return s
    }),
    n.d(e, "CullFaceFront", function() {
        return c
    }),
    n.d(e, "CullFaceFrontBack", function() {
        return h
    }),
    n.d(e, "FrontFaceDirectionCW", function() {
        return l
    }),
    n.d(e, "FrontFaceDirectionCCW", function() {
        return u
    }),
    n.d(e, "BasicShadowMap", function() {
        return p
    }),
    n.d(e, "PCFShadowMap", function() {
        return d
    }),
    n.d(e, "PCFSoftShadowMap", function() {
        return f
    }),
    n.d(e, "FrontSide", function() {
        return m
    }),
    n.d(e, "BackSide", function() {
        return g
    }),
    n.d(e, "DoubleSide", function() {
        return v
    }),
    n.d(e, "FlatShading", function() {
        return y
    }),
    n.d(e, "SmoothShading", function() {
        return x
    }),
    n.d(e, "NoColors", function() {
        return w
    }),
    n.d(e, "FaceColors", function() {
        return b
    }),
    n.d(e, "VertexColors", function() {
        return M
    }),
    n.d(e, "NoBlending", function() {
        return _
    }),
    n.d(e, "NormalBlending", function() {
        return E
    }),
    n.d(e, "AdditiveBlending", function() {
        return S
    }),
    n.d(e, "SubtractiveBlending", function() {
        return T
    }),
    n.d(e, "MultiplyBlending", function() {
        return A
    }),
    n.d(e, "CustomBlending", function() {
        return L
    }),
    n.d(e, "AddEquation", function() {
        return R
    }),
    n.d(e, "SubtractEquation", function() {
        return P
    }),
    n.d(e, "ReverseSubtractEquation", function() {
        return C
    }),
    n.d(e, "MinEquation", function() {
        return I
    }),
    n.d(e, "MaxEquation", function() {
        return O
    }),
    n.d(e, "ZeroFactor", function() {
        return D
    }),
    n.d(e, "OneFactor", function() {
        return U
    }),
    n.d(e, "SrcColorFactor", function() {
        return N
    }),
    n.d(e, "OneMinusSrcColorFactor", function() {
        return B
    }),
    n.d(e, "SrcAlphaFactor", function() {
        return z
    }),
    n.d(e, "OneMinusSrcAlphaFactor", function() {
        return F
    }),
    n.d(e, "DstAlphaFactor", function() {
        return k
    }),
    n.d(e, "OneMinusDstAlphaFactor", function() {
        return H
    }),
    n.d(e, "DstColorFactor", function() {
        return G
    }),
    n.d(e, "OneMinusDstColorFactor", function() {
        return V
    }),
    n.d(e, "SrcAlphaSaturateFactor", function() {
        return j
    }),
    n.d(e, "NeverDepth", function() {
        return W
    }),
    n.d(e, "AlwaysDepth", function() {
        return Y
    }),
    n.d(e, "LessDepth", function() {
        return X
    }),
    n.d(e, "LessEqualDepth", function() {
        return q
    }),
    n.d(e, "EqualDepth", function() {
        return Z
    }),
    n.d(e, "GreaterEqualDepth", function() {
        return J
    }),
    n.d(e, "GreaterDepth", function() {
        return K
    }),
    n.d(e, "NotEqualDepth", function() {
        return Q
    }),
    n.d(e, "MultiplyOperation", function() {
        return $
    }),
    n.d(e, "MixOperation", function() {
        return tt
    }),
    n.d(e, "AddOperation", function() {
        return et
    }),
    n.d(e, "NoToneMapping", function() {
        return nt
    }),
    n.d(e, "LinearToneMapping", function() {
        return rt
    }),
    n.d(e, "ReinhardToneMapping", function() {
        return it
    }),
    n.d(e, "Uncharted2ToneMapping", function() {
        return ot
    }),
    n.d(e, "CineonToneMapping", function() {
        return at
    }),
    n.d(e, "UVMapping", function() {
        return st
    }),
    n.d(e, "CubeReflectionMapping", function() {
        return ct
    }),
    n.d(e, "CubeRefractionMapping", function() {
        return ht
    }),
    n.d(e, "EquirectangularReflectionMapping", function() {
        return lt
    }),
    n.d(e, "EquirectangularRefractionMapping", function() {
        return ut
    }),
    n.d(e, "SphericalReflectionMapping", function() {
        return pt
    }),
    n.d(e, "CubeUVReflectionMapping", function() {
        return dt
    }),
    n.d(e, "CubeUVRefractionMapping", function() {
        return ft
    }),
    n.d(e, "RepeatWrapping", function() {
        return mt
    }),
    n.d(e, "ClampToEdgeWrapping", function() {
        return gt
    }),
    n.d(e, "MirroredRepeatWrapping", function() {
        return vt
    }),
    n.d(e, "NearestFilter", function() {
        return yt
    }),
    n.d(e, "NearestMipMapNearestFilter", function() {
        return xt
    }),
    n.d(e, "NearestMipMapLinearFilter", function() {
        return wt
    }),
    n.d(e, "LinearFilter", function() {
        return bt
    }),
    n.d(e, "LinearMipMapNearestFilter", function() {
        return Mt
    }),
    n.d(e, "LinearMipMapLinearFilter", function() {
        return _t
    }),
    n.d(e, "UnsignedByteType", function() {
        return Et
    }),
    n.d(e, "ByteType", function() {
        return St
    }),
    n.d(e, "ShortType", function() {
        return Tt
    }),
    n.d(e, "UnsignedShortType", function() {
        return At
    }),
    n.d(e, "IntType", function() {
        return Lt
    }),
    n.d(e, "UnsignedIntType", function() {
        return Rt
    }),
    n.d(e, "FloatType", function() {
        return Pt
    }),
    n.d(e, "HalfFloatType", function() {
        return Ct
    }),
    n.d(e, "UnsignedShort4444Type", function() {
        return It
    }),
    n.d(e, "UnsignedShort5551Type", function() {
        return Ot
    }),
    n.d(e, "UnsignedShort565Type", function() {
        return Dt
    }),
    n.d(e, "UnsignedInt248Type", function() {
        return Ut
    }),
    n.d(e, "AlphaFormat", function() {
        return Nt
    }),
    n.d(e, "RGBFormat", function() {
        return Bt
    }),
    n.d(e, "RGBAFormat", function() {
        return zt
    }),
    n.d(e, "LuminanceFormat", function() {
        return Ft
    }),
    n.d(e, "LuminanceAlphaFormat", function() {
        return kt
    }),
    n.d(e, "RGBEFormat", function() {
        return Ht
    }),
    n.d(e, "DepthFormat", function() {
        return Gt
    }),
    n.d(e, "DepthStencilFormat", function() {
        return Vt
    }),
    n.d(e, "RGB_S3TC_DXT1_Format", function() {
        return jt
    }),
    n.d(e, "RGBA_S3TC_DXT1_Format", function() {
        return Wt
    }),
    n.d(e, "RGBA_S3TC_DXT3_Format", function() {
        return Yt
    }),
    n.d(e, "RGBA_S3TC_DXT5_Format", function() {
        return Xt
    }),
    n.d(e, "RGB_PVRTC_4BPPV1_Format", function() {
        return qt
    }),
    n.d(e, "RGB_PVRTC_2BPPV1_Format", function() {
        return Zt
    }),
    n.d(e, "RGBA_PVRTC_4BPPV1_Format", function() {
        return Jt
    }),
    n.d(e, "RGBA_PVRTC_2BPPV1_Format", function() {
        return Kt
    }),
    n.d(e, "RGB_ETC1_Format", function() {
        return Qt
    }),
    n.d(e, "RGBA_ASTC_4x4_Format", function() {
        return $t
    }),
    n.d(e, "RGBA_ASTC_5x4_Format", function() {
        return te
    }),
    n.d(e, "RGBA_ASTC_5x5_Format", function() {
        return ee
    }),
    n.d(e, "RGBA_ASTC_6x5_Format", function() {
        return ne
    }),
    n.d(e, "RGBA_ASTC_6x6_Format", function() {
        return re
    }),
    n.d(e, "RGBA_ASTC_8x5_Format", function() {
        return ie
    }),
    n.d(e, "RGBA_ASTC_8x6_Format", function() {
        return oe
    }),
    n.d(e, "RGBA_ASTC_8x8_Format", function() {
        return ae
    }),
    n.d(e, "RGBA_ASTC_10x5_Format", function() {
        return se
    }),
    n.d(e, "RGBA_ASTC_10x6_Format", function() {
        return ce
    }),
    n.d(e, "RGBA_ASTC_10x8_Format", function() {
        return he
    }),
    n.d(e, "RGBA_ASTC_10x10_Format", function() {
        return le
    }),
    n.d(e, "RGBA_ASTC_12x10_Format", function() {
        return ue
    }),
    n.d(e, "RGBA_ASTC_12x12_Format", function() {
        return pe
    }),
    n.d(e, "LoopOnce", function() {
        return de
    }),
    n.d(e, "LoopRepeat", function() {
        return fe
    }),
    n.d(e, "LoopPingPong", function() {
        return me
    }),
    n.d(e, "InterpolateDiscrete", function() {
        return ge
    }),
    n.d(e, "InterpolateLinear", function() {
        return ve
    }),
    n.d(e, "InterpolateSmooth", function() {
        return ye
    }),
    n.d(e, "ZeroCurvatureEnding", function() {
        return xe
    }),
    n.d(e, "ZeroSlopeEnding", function() {
        return we
    }),
    n.d(e, "WrapAroundEnding", function() {
        return be
    }),
    n.d(e, "TrianglesDrawMode", function() {
        return Me
    }),
    n.d(e, "TriangleStripDrawMode", function() {
        return _e
    }),
    n.d(e, "TriangleFanDrawMode", function() {
        return Ee
    }),
    n.d(e, "LinearEncoding", function() {
        return Se
    }),
    n.d(e, "sRGBEncoding", function() {
        return Te
    }),
    n.d(e, "GammaEncoding", function() {
        return Ae
    }),
    n.d(e, "RGBEEncoding", function() {
        return Le
    }),
    n.d(e, "LogLuvEncoding", function() {
        return Re
    }),
    n.d(e, "RGBM7Encoding", function() {
        return Pe
    }),
    n.d(e, "RGBM16Encoding", function() {
        return Ce
    }),
    n.d(e, "RGBDEncoding", function() {
        return Ie
    }),
    n.d(e, "BasicDepthPacking", function() {
        return Oe
    }),
    n.d(e, "RGBADepthPacking", function() {
        return De
    }),
    n.d(e, "CubeGeometry", function() {
        return xr
    }),
    n.d(e, "Face4", function() {
        return Xs
    }),
    n.d(e, "LineStrip", function() {
        return qs
    }),
    n.d(e, "LinePieces", function() {
        return Zs
    }),
    n.d(e, "MeshFaceMaterial", function() {
        return Js
    }),
    n.d(e, "MultiMaterial", function() {
        return Ks
    }),
    n.d(e, "PointCloud", function() {
        return Qs
    }),
    n.d(e, "Particle", function() {
        return $s
    }),
    n.d(e, "ParticleSystem", function() {
        return tc
    }),
    n.d(e, "PointCloudMaterial", function() {
        return ec
    }),
    n.d(e, "ParticleBasicMaterial", function() {
        return nc
    }),
    n.d(e, "ParticleSystemMaterial", function() {
        return rc
    }),
    n.d(e, "Vertex", function() {
        return ic
    }),
    n.d(e, "DynamicBufferAttribute", function() {
        return oc
    }),
    n.d(e, "Int8Attribute", function() {
        return ac
    }),
    n.d(e, "Uint8Attribute", function() {
        return sc
    }),
    n.d(e, "Uint8ClampedAttribute", function() {
        return cc
    }),
    n.d(e, "Int16Attribute", function() {
        return hc
    }),
    n.d(e, "Uint16Attribute", function() {
        return lc
    }),
    n.d(e, "Int32Attribute", function() {
        return uc
    }),
    n.d(e, "Uint32Attribute", function() {
        return pc
    }),
    n.d(e, "Float32Attribute", function() {
        return dc
    }),
    n.d(e, "Float64Attribute", function() {
        return fc
    }),
    n.d(e, "ClosedSplineCurve3", function() {
        return mc
    }),
    n.d(e, "SplineCurve3", function() {
        return gc
    }),
    n.d(e, "Spline", function() {
        return vc
    }),
    n.d(e, "AxisHelper", function() {
        return yc
    }),
    n.d(e, "BoundingBoxHelper", function() {
        return xc
    }),
    n.d(e, "EdgesHelper", function() {
        return wc
    }),
    n.d(e, "WireframeHelper", function() {
        return bc
    }),
    n.d(e, "XHRLoader", function() {
        return Mc
    }),
    n.d(e, "BinaryTextureLoader", function() {
        return _c
    }),
    n.d(e, "GeometryUtils", function() {
        return Ec
    }),
    n.d(e, "ImageUtils", function() {
        return Sc
    }),
    n.d(e, "Projector", function() {
        return Tc
    }),
    n.d(e, "CanvasRenderer", function() {
        return Ac
    }),
    n.d(e, "SceneUtils", function() {
        return Lc
    }),
    n.d(e, "LensFlare", function() {
        return Rc
    }),
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }
    ),
    void 0 === Math.sign && (Math.sign = function(t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t
    }
    ),
    "name"in Function.prototype == 0 && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(t) {
        if (void 0 === t || null === t)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var e = Object(t), n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            if (void 0 !== r && null !== r)
                for (var i in r)
                    Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
        }
        return e
    }
    ),
    Object.assign(r.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var n = this._listeners;
            void 0 === n[t] && (n[t] = []),
            -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners)
                return !1;
            var n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            if (void 0 !== this._listeners) {
                var n = this._listeners[t];
                if (void 0 !== n) {
                    var r = n.indexOf(e);
                    -1 !== r && n.splice(r, 1)
                }
            }
        },
        dispatchEvent: function(t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this;
                    for (var n = e.slice(0), r = 0, i = n.length; r < i; r++)
                        n[r].call(this, t)
                }
            }
        }
    });
    var i = "90"
      , o = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }
      , a = 0
      , s = 1
      , c = 2
      , h = 3
      , l = 0
      , u = 1
      , p = 0
      , d = 1
      , f = 2
      , m = 0
      , g = 1
      , v = 2
      , y = 1
      , x = 2
      , w = 0
      , b = 1
      , M = 2
      , _ = 0
      , E = 1
      , S = 2
      , T = 3
      , A = 4
      , L = 5
      , R = 100
      , P = 101
      , C = 102
      , I = 103
      , O = 104
      , D = 200
      , U = 201
      , N = 202
      , B = 203
      , z = 204
      , F = 205
      , k = 206
      , H = 207
      , G = 208
      , V = 209
      , j = 210
      , W = 0
      , Y = 1
      , X = 2
      , q = 3
      , Z = 4
      , J = 5
      , K = 6
      , Q = 7
      , $ = 0
      , tt = 1
      , et = 2
      , nt = 0
      , rt = 1
      , it = 2
      , ot = 3
      , at = 4
      , st = 300
      , ct = 301
      , ht = 302
      , lt = 303
      , ut = 304
      , pt = 305
      , dt = 306
      , ft = 307
      , mt = 1e3
      , gt = 1001
      , vt = 1002
      , yt = 1003
      , xt = 1004
      , wt = 1005
      , bt = 1006
      , Mt = 1007
      , _t = 1008
      , Et = 1009
      , St = 1010
      , Tt = 1011
      , At = 1012
      , Lt = 1013
      , Rt = 1014
      , Pt = 1015
      , Ct = 1016
      , It = 1017
      , Ot = 1018
      , Dt = 1019
      , Ut = 1020
      , Nt = 1021
      , Bt = 1022
      , zt = 1023
      , Ft = 1024
      , kt = 1025
      , Ht = zt
      , Gt = 1026
      , Vt = 1027
      , jt = 33776
      , Wt = 33777
      , Yt = 33778
      , Xt = 33779
      , qt = 35840
      , Zt = 35841
      , Jt = 35842
      , Kt = 35843
      , Qt = 36196
      , $t = 37808
      , te = 37809
      , ee = 37810
      , ne = 37811
      , re = 37812
      , ie = 37813
      , oe = 37814
      , ae = 37815
      , se = 37816
      , ce = 37817
      , he = 37818
      , le = 37819
      , ue = 37820
      , pe = 37821
      , de = 2200
      , fe = 2201
      , me = 2202
      , ge = 2300
      , ve = 2301
      , ye = 2302
      , xe = 2400
      , we = 2401
      , be = 2402
      , Me = 0
      , _e = 1
      , Ee = 2
      , Se = 3e3
      , Te = 3001
      , Ae = 3007
      , Le = 3002
      , Re = 3003
      , Pe = 3004
      , Ce = 3005
      , Ie = 3006
      , Oe = 3200
      , De = 3201
      , Ue = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var t = [], e = 0; e < 256; e++)
                t[e] = (e < 16 ? "0" : "") + e.toString(16).toUpperCase();
            return function() {
                var e = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0
                  , r = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0;
                return t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & n] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[63 & r | 128] + t[r >> 8 & 255] + "-" + t[r >> 16 & 255] + t[r >> 24 & 255] + t[255 & i] + t[i >> 8 & 255] + t[i >> 16 & 255] + t[i >> 24 & 255]
            }
        }(),
        clamp: function(t, e, n) {
            return Math.max(e, Math.min(n, t))
        },
        euclideanModulo: function(t, e) {
            return (t % e + e) % e
        },
        mapLinear: function(t, e, n, r, i) {
            return r + (t - e) * (i - r) / (n - e)
        },
        lerp: function(t, e, n) {
            return (1 - n) * t + n * e
        },
        smoothstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function(t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function(t) {
            return t * (.5 - Math.random())
        },
        degToRad: function(t) {
            return t * Ue.DEG2RAD
        },
        radToDeg: function(t) {
            return t * Ue.RAD2DEG
        },
        isPowerOfTwo: function(t) {
            return 0 == (t & t - 1) && 0 !== t
        },
        ceilPowerOfTwo: function(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        },
        floorPowerOfTwo: function(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
    };
    function Ne(t, e) {
        this.x = t || 0,
        this.y = e || 0
    }
    function Be() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    function ze(t, e, n, r) {
        this._x = t || 0,
        this._y = e || 0,
        this._z = n || 0,
        this._w = void 0 !== r ? r : 1
    }
    function Fe(t, e, n) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = n || 0
    }
    function ke() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    Object.defineProperties(Ne.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }
    }),
    Object.assign(Ne.prototype, {
        isVector2: !0,
        set: function(t, e) {
            return this.x = t,
            this.y = e,
            this
        },
        setScalar: function(t) {
            return this.x = t,
            this.y = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this
        },
        multiply: function(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        applyMatrix3: function(t) {
            var e = this.x
              , n = this.y
              , r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6],
            this.y = r[1] * e + r[4] * n + r[7],
            this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this
        },
        clampScalar: function() {
            var t = new Ne
              , e = new Ne;
            return function(n, r) {
                return t.set(n, n),
                e.set(r, r),
                this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var t = Math.atan2(this.y, this.x);
            return t < 0 && (t += 2 * Math.PI),
            t
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x
              , n = this.y - t.y;
            return e * e + n * n
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this
        },
        rotateAround: function(t, e) {
            var n = Math.cos(e)
              , r = Math.sin(e)
              , i = this.x - t.x
              , o = this.y - t.y;
            return this.x = i * n - o * r + t.x,
            this.y = i * r + o * n + t.y,
            this
        }
    }),
    Object.assign(Be.prototype, {
        isMatrix4: !0,
        set: function(t, e, n, r, i, o, a, s, c, h, l, u, p, d, f, m) {
            var g = this.elements;
            return g[0] = t,
            g[4] = e,
            g[8] = n,
            g[12] = r,
            g[1] = i,
            g[5] = o,
            g[9] = a,
            g[13] = s,
            g[2] = c,
            g[6] = h,
            g[10] = l,
            g[14] = u,
            g[3] = p,
            g[7] = d,
            g[11] = f,
            g[15] = m,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new Be).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements
              , n = t.elements;
            return e[0] = n[0],
            e[1] = n[1],
            e[2] = n[2],
            e[3] = n[3],
            e[4] = n[4],
            e[5] = n[5],
            e[6] = n[6],
            e[7] = n[7],
            e[8] = n[8],
            e[9] = n[9],
            e[10] = n[10],
            e[11] = n[11],
            e[12] = n[12],
            e[13] = n[13],
            e[14] = n[14],
            e[15] = n[15],
            this
        },
        copyPosition: function(t) {
            var e = this.elements
              , n = t.elements;
            return e[12] = n[12],
            e[13] = n[13],
            e[14] = n[14],
            this
        },
        extractBasis: function(t, e, n) {
            return t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: function() {
            var t = new Fe;
            return function(e) {
                var n = this.elements
                  , r = e.elements
                  , i = 1 / t.setFromMatrixColumn(e, 0).length()
                  , o = 1 / t.setFromMatrixColumn(e, 1).length()
                  , a = 1 / t.setFromMatrixColumn(e, 2).length();
                return n[0] = r[0] * i,
                n[1] = r[1] * i,
                n[2] = r[2] * i,
                n[4] = r[4] * o,
                n[5] = r[5] * o,
                n[6] = r[6] * o,
                n[8] = r[8] * a,
                n[9] = r[9] * a,
                n[10] = r[10] * a,
                this
            }
        }(),
        makeRotationFromEuler: function(t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e = this.elements
              , n = t.x
              , r = t.y
              , i = t.z
              , o = Math.cos(n)
              , a = Math.sin(n)
              , s = Math.cos(r)
              , c = Math.sin(r)
              , h = Math.cos(i)
              , l = Math.sin(i);
            if ("XYZ" === t.order) {
                var u = o * h
                  , p = o * l
                  , d = a * h
                  , f = a * l;
                e[0] = s * h,
                e[4] = -s * l,
                e[8] = c,
                e[1] = p + d * c,
                e[5] = u - f * c,
                e[9] = -a * s,
                e[2] = f - u * c,
                e[6] = d + p * c,
                e[10] = o * s
            } else if ("YXZ" === t.order) {
                var m = s * h
                  , g = s * l
                  , v = c * h
                  , y = c * l;
                e[0] = m + y * a,
                e[4] = v * a - g,
                e[8] = o * c,
                e[1] = o * l,
                e[5] = o * h,
                e[9] = -a,
                e[2] = g * a - v,
                e[6] = y + m * a,
                e[10] = o * s
            } else if ("ZXY" === t.order)
                m = s * h,
                g = s * l,
                v = c * h,
                y = c * l,
                e[0] = m - y * a,
                e[4] = -o * l,
                e[8] = v + g * a,
                e[1] = g + v * a,
                e[5] = o * h,
                e[9] = y - m * a,
                e[2] = -o * c,
                e[6] = a,
                e[10] = o * s;
            else if ("ZYX" === t.order)
                u = o * h,
                p = o * l,
                d = a * h,
                f = a * l,
                e[0] = s * h,
                e[4] = d * c - p,
                e[8] = u * c + f,
                e[1] = s * l,
                e[5] = f * c + u,
                e[9] = p * c - d,
                e[2] = -c,
                e[6] = a * s,
                e[10] = o * s;
            else if ("YZX" === t.order) {
                var x = o * s
                  , w = o * c
                  , b = a * s
                  , M = a * c;
                e[0] = s * h,
                e[4] = M - x * l,
                e[8] = b * l + w,
                e[1] = l,
                e[5] = o * h,
                e[9] = -a * h,
                e[2] = -c * h,
                e[6] = w * l + b,
                e[10] = x - M * l
            } else
                "XZY" === t.order && (x = o * s,
                w = o * c,
                b = a * s,
                M = a * c,
                e[0] = s * h,
                e[4] = -l,
                e[8] = c * h,
                e[1] = x * l + M,
                e[5] = o * h,
                e[9] = w * l - b,
                e[2] = b * l - w,
                e[6] = a * h,
                e[10] = M * l + x);
            return e[3] = 0,
            e[7] = 0,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        },
        makeRotationFromQuaternion: function(t) {
            var e = this.elements
              , n = t._x
              , r = t._y
              , i = t._z
              , o = t._w
              , a = n + n
              , s = r + r
              , c = i + i
              , h = n * a
              , l = n * s
              , u = n * c
              , p = r * s
              , d = r * c
              , f = i * c
              , m = o * a
              , g = o * s
              , v = o * c;
            return e[0] = 1 - (p + f),
            e[4] = l - v,
            e[8] = u + g,
            e[1] = l + v,
            e[5] = 1 - (h + f),
            e[9] = d - m,
            e[2] = u - g,
            e[6] = d + m,
            e[10] = 1 - (h + p),
            e[3] = 0,
            e[7] = 0,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        },
        lookAt: function() {
            var t = new Fe
              , e = new Fe
              , n = new Fe;
            return function(r, i, o) {
                var a = this.elements;
                return n.subVectors(r, i),
                0 === n.lengthSq() && (n.z = 1),
                n.normalize(),
                t.crossVectors(o, n),
                0 === t.lengthSq() && (1 === Math.abs(o.z) ? n.x += 1e-4 : n.z += 1e-4,
                n.normalize(),
                t.crossVectors(o, n)),
                t.normalize(),
                e.crossVectors(n, t),
                a[0] = t.x,
                a[4] = e.x,
                a[8] = n.x,
                a[1] = t.y,
                a[5] = e.y,
                a[9] = n.y,
                a[2] = t.z,
                a[6] = e.z,
                a[10] = n.z,
                this
            }
        }(),
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements
              , r = e.elements
              , i = this.elements
              , o = n[0]
              , a = n[4]
              , s = n[8]
              , c = n[12]
              , h = n[1]
              , l = n[5]
              , u = n[9]
              , p = n[13]
              , d = n[2]
              , f = n[6]
              , m = n[10]
              , g = n[14]
              , v = n[3]
              , y = n[7]
              , x = n[11]
              , w = n[15]
              , b = r[0]
              , M = r[4]
              , _ = r[8]
              , E = r[12]
              , S = r[1]
              , T = r[5]
              , A = r[9]
              , L = r[13]
              , R = r[2]
              , P = r[6]
              , C = r[10]
              , I = r[14]
              , O = r[3]
              , D = r[7]
              , U = r[11]
              , N = r[15];
            return i[0] = o * b + a * S + s * R + c * O,
            i[4] = o * M + a * T + s * P + c * D,
            i[8] = o * _ + a * A + s * C + c * U,
            i[12] = o * E + a * L + s * I + c * N,
            i[1] = h * b + l * S + u * R + p * O,
            i[5] = h * M + l * T + u * P + p * D,
            i[9] = h * _ + l * A + u * C + p * U,
            i[13] = h * E + l * L + u * I + p * N,
            i[2] = d * b + f * S + m * R + g * O,
            i[6] = d * M + f * T + m * P + g * D,
            i[10] = d * _ + f * A + m * C + g * U,
            i[14] = d * E + f * L + m * I + g * N,
            i[3] = v * b + y * S + x * R + w * O,
            i[7] = v * M + y * T + x * P + w * D,
            i[11] = v * _ + y * A + x * C + w * U,
            i[15] = v * E + y * L + x * I + w * N,
            this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t,
            e[4] *= t,
            e[8] *= t,
            e[12] *= t,
            e[1] *= t,
            e[5] *= t,
            e[9] *= t,
            e[13] *= t,
            e[2] *= t,
            e[6] *= t,
            e[10] *= t,
            e[14] *= t,
            e[3] *= t,
            e[7] *= t,
            e[11] *= t,
            e[15] *= t,
            this
        },
        applyToBufferAttribute: function() {
            var t = new Fe;
            return function(e) {
                for (var n = 0, r = e.count; n < r; n++)
                    t.x = e.getX(n),
                    t.y = e.getY(n),
                    t.z = e.getZ(n),
                    t.applyMatrix4(this),
                    e.setXYZ(n, t.x, t.y, t.z);
                return e
            }
        }(),
        determinant: function() {
            var t = this.elements
              , e = t[0]
              , n = t[4]
              , r = t[8]
              , i = t[12]
              , o = t[1]
              , a = t[5]
              , s = t[9]
              , c = t[13]
              , h = t[2]
              , l = t[6]
              , u = t[10]
              , p = t[14];
            return t[3] * (+i * s * l - r * c * l - i * a * u + n * c * u + r * a * p - n * s * p) + t[7] * (+e * s * p - e * c * u + i * o * u - r * o * p + r * c * h - i * s * h) + t[11] * (+e * c * l - e * a * p - i * o * l + n * o * p + i * a * h - n * c * h) + t[15] * (-r * a * h - e * s * l + e * a * u + r * o * l - n * o * u + n * s * h)
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1],
            e[1] = e[4],
            e[4] = t,
            t = e[2],
            e[2] = e[8],
            e[8] = t,
            t = e[6],
            e[6] = e[9],
            e[9] = t,
            t = e[3],
            e[3] = e[12],
            e[12] = t,
            t = e[7],
            e[7] = e[13],
            e[13] = t,
            t = e[11],
            e[11] = e[14],
            e[14] = t,
            this
        },
        setPosition: function(t) {
            var e = this.elements;
            return e[12] = t.x,
            e[13] = t.y,
            e[14] = t.z,
            this
        },
        getInverse: function(t, e) {
            var n = this.elements
              , r = t.elements
              , i = r[0]
              , o = r[1]
              , a = r[2]
              , s = r[3]
              , c = r[4]
              , h = r[5]
              , l = r[6]
              , u = r[7]
              , p = r[8]
              , d = r[9]
              , f = r[10]
              , m = r[11]
              , g = r[12]
              , v = r[13]
              , y = r[14]
              , x = r[15]
              , w = d * y * u - v * f * u + v * l * m - h * y * m - d * l * x + h * f * x
              , b = g * f * u - p * y * u - g * l * m + c * y * m + p * l * x - c * f * x
              , M = p * v * u - g * d * u + g * h * m - c * v * m - p * h * x + c * d * x
              , _ = g * d * l - p * v * l - g * h * f + c * v * f + p * h * y - c * d * y
              , E = i * w + o * b + a * M + s * _;
            if (0 === E) {
                var S = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === e)
                    throw new Error(S);
                return console.warn(S),
                this.identity()
            }
            var T = 1 / E;
            return n[0] = w * T,
            n[1] = (v * f * s - d * y * s - v * a * m + o * y * m + d * a * x - o * f * x) * T,
            n[2] = (h * y * s - v * l * s + v * a * u - o * y * u - h * a * x + o * l * x) * T,
            n[3] = (d * l * s - h * f * s - d * a * u + o * f * u + h * a * m - o * l * m) * T,
            n[4] = b * T,
            n[5] = (p * y * s - g * f * s + g * a * m - i * y * m - p * a * x + i * f * x) * T,
            n[6] = (g * l * s - c * y * s - g * a * u + i * y * u + c * a * x - i * l * x) * T,
            n[7] = (c * f * s - p * l * s + p * a * u - i * f * u - c * a * m + i * l * m) * T,
            n[8] = M * T,
            n[9] = (g * d * s - p * v * s - g * o * m + i * v * m + p * o * x - i * d * x) * T,
            n[10] = (c * v * s - g * h * s + g * o * u - i * v * u - c * o * x + i * h * x) * T,
            n[11] = (p * h * s - c * d * s - p * o * u + i * d * u + c * o * m - i * h * m) * T,
            n[12] = _ * T,
            n[13] = (p * v * a - g * d * a + g * o * f - i * v * f - p * o * y + i * d * y) * T,
            n[14] = (g * h * a - c * v * a - g * o * l + i * v * l + c * o * y - i * h * y) * T,
            n[15] = (c * d * a - p * h * a + p * o * l - i * d * l - c * o * f + i * h * f) * T,
            this
        },
        scale: function(t) {
            var e = this.elements
              , n = t.x
              , r = t.y
              , i = t.z;
            return e[0] *= n,
            e[4] *= r,
            e[8] *= i,
            e[1] *= n,
            e[5] *= r,
            e[9] *= i,
            e[2] *= n,
            e[6] *= r,
            e[10] *= i,
            e[3] *= n,
            e[7] *= r,
            e[11] *= i,
            this
        },
        getMaxScaleOnAxis: function() {
            var t = this.elements
              , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
              , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
              , r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, r))
        },
        makeTranslation: function(t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(t) {
            var e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(t) {
            var e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(t) {
            var e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(t, e) {
            var n = Math.cos(e)
              , r = Math.sin(e)
              , i = 1 - n
              , o = t.x
              , a = t.y
              , s = t.z
              , c = i * o
              , h = i * a;
            return this.set(c * o + n, c * a - r * s, c * s + r * a, 0, c * a + r * s, h * a + n, h * s - r * o, 0, c * s - r * a, h * s + r * o, i * s * s + n, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(t, e, n) {
            return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(t, e, n) {
            return this.makeRotationFromQuaternion(e),
            this.scale(n),
            this.setPosition(t),
            this
        },
        decompose: function() {
            var t = new Fe
              , e = new Be;
            return function(n, r, i) {
                var o = this.elements
                  , a = t.set(o[0], o[1], o[2]).length()
                  , s = t.set(o[4], o[5], o[6]).length()
                  , c = t.set(o[8], o[9], o[10]).length();
                this.determinant() < 0 && (a = -a),
                n.x = o[12],
                n.y = o[13],
                n.z = o[14],
                e.copy(this);
                var h = 1 / a
                  , l = 1 / s
                  , u = 1 / c;
                return e.elements[0] *= h,
                e.elements[1] *= h,
                e.elements[2] *= h,
                e.elements[4] *= l,
                e.elements[5] *= l,
                e.elements[6] *= l,
                e.elements[8] *= u,
                e.elements[9] *= u,
                e.elements[10] *= u,
                r.setFromRotationMatrix(e),
                i.x = a,
                i.y = s,
                i.z = c,
                this
            }
        }(),
        makePerspective: function(t, e, n, r, i, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var a = this.elements
              , s = 2 * i / (e - t)
              , c = 2 * i / (n - r)
              , h = (e + t) / (e - t)
              , l = (n + r) / (n - r)
              , u = -(o + i) / (o - i)
              , p = -2 * o * i / (o - i);
            return a[0] = s,
            a[4] = 0,
            a[8] = h,
            a[12] = 0,
            a[1] = 0,
            a[5] = c,
            a[9] = l,
            a[13] = 0,
            a[2] = 0,
            a[6] = 0,
            a[10] = u,
            a[14] = p,
            a[3] = 0,
            a[7] = 0,
            a[11] = -1,
            a[15] = 0,
            this
        },
        makeOrthographic: function(t, e, n, r, i, o) {
            var a = this.elements
              , s = 1 / (e - t)
              , c = 1 / (n - r)
              , h = 1 / (o - i)
              , l = (e + t) * s
              , u = (n + r) * c
              , p = (o + i) * h;
            return a[0] = 2 * s,
            a[4] = 0,
            a[8] = 0,
            a[12] = -l,
            a[1] = 0,
            a[5] = 2 * c,
            a[9] = 0,
            a[13] = -u,
            a[2] = 0,
            a[6] = 0,
            a[10] = -2 * h,
            a[14] = -p,
            a[3] = 0,
            a[7] = 0,
            a[11] = 0,
            a[15] = 1,
            this
        },
        equals: function(t) {
            for (var e = this.elements, n = t.elements, r = 0; r < 16; r++)
                if (e[r] !== n[r])
                    return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 16; n++)
                this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []),
            void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t[e + 9] = n[9],
            t[e + 10] = n[10],
            t[e + 11] = n[11],
            t[e + 12] = n[12],
            t[e + 13] = n[13],
            t[e + 14] = n[14],
            t[e + 15] = n[15],
            t
        }
    }),
    Object.assign(ze, {
        slerp: function(t, e, n, r) {
            return n.copy(t).slerp(e, r)
        },
        slerpFlat: function(t, e, n, r, i, o, a) {
            var s = n[r + 0]
              , c = n[r + 1]
              , h = n[r + 2]
              , l = n[r + 3]
              , u = i[o + 0]
              , p = i[o + 1]
              , d = i[o + 2]
              , f = i[o + 3];
            if (l !== f || s !== u || c !== p || h !== d) {
                var m = 1 - a
                  , g = s * u + c * p + h * d + l * f
                  , v = g >= 0 ? 1 : -1
                  , y = 1 - g * g;
                if (y > Number.EPSILON) {
                    var x = Math.sqrt(y)
                      , w = Math.atan2(x, g * v);
                    m = Math.sin(m * w) / x,
                    a = Math.sin(a * w) / x
                }
                var b = a * v;
                if (s = s * m + u * b,
                c = c * m + p * b,
                h = h * m + d * b,
                l = l * m + f * b,
                m === 1 - a) {
                    var M = 1 / Math.sqrt(s * s + c * c + h * h + l * l);
                    s *= M,
                    c *= M,
                    h *= M,
                    l *= M
                }
            }
            t[e] = s,
            t[e + 1] = c,
            t[e + 2] = h,
            t[e + 3] = l
        }
    }),
    Object.defineProperties(ze.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t,
                this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(t) {
                this._w = t,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(ze.prototype, {
        set: function(t, e, n, r) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._w = r,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(t) {
            return this._x = t.x,
            this._y = t.y,
            this._z = t.z,
            this._w = t.w,
            this.onChangeCallback(),
            this
        },
        setFromEuler: function(t, e) {
            if (!t || !t.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = t._x
              , r = t._y
              , i = t._z
              , o = t.order
              , a = Math.cos
              , s = Math.sin
              , c = a(n / 2)
              , h = a(r / 2)
              , l = a(i / 2)
              , u = s(n / 2)
              , p = s(r / 2)
              , d = s(i / 2);
            return "XYZ" === o ? (this._x = u * h * l + c * p * d,
            this._y = c * p * l - u * h * d,
            this._z = c * h * d + u * p * l,
            this._w = c * h * l - u * p * d) : "YXZ" === o ? (this._x = u * h * l + c * p * d,
            this._y = c * p * l - u * h * d,
            this._z = c * h * d - u * p * l,
            this._w = c * h * l + u * p * d) : "ZXY" === o ? (this._x = u * h * l - c * p * d,
            this._y = c * p * l + u * h * d,
            this._z = c * h * d + u * p * l,
            this._w = c * h * l - u * p * d) : "ZYX" === o ? (this._x = u * h * l - c * p * d,
            this._y = c * p * l + u * h * d,
            this._z = c * h * d - u * p * l,
            this._w = c * h * l + u * p * d) : "YZX" === o ? (this._x = u * h * l + c * p * d,
            this._y = c * p * l + u * h * d,
            this._z = c * h * d - u * p * l,
            this._w = c * h * l - u * p * d) : "XZY" === o && (this._x = u * h * l - c * p * d,
            this._y = c * p * l - u * h * d,
            this._z = c * h * d + u * p * l,
            this._w = c * h * l + u * p * d),
            !1 !== e && this.onChangeCallback(),
            this
        },
        setFromAxisAngle: function(t, e) {
            var n = e / 2
              , r = Math.sin(n);
            return this._x = t.x * r,
            this._y = t.y * r,
            this._z = t.z * r,
            this._w = Math.cos(n),
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(t) {
            var e, n = t.elements, r = n[0], i = n[4], o = n[8], a = n[1], s = n[5], c = n[9], h = n[2], l = n[6], u = n[10], p = r + s + u;
            return p > 0 ? (e = .5 / Math.sqrt(p + 1),
            this._w = .25 / e,
            this._x = (l - c) * e,
            this._y = (o - h) * e,
            this._z = (a - i) * e) : r > s && r > u ? (e = 2 * Math.sqrt(1 + r - s - u),
            this._w = (l - c) / e,
            this._x = .25 * e,
            this._y = (i + a) / e,
            this._z = (o + h) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - r - u),
            this._w = (o - h) / e,
            this._x = (i + a) / e,
            this._y = .25 * e,
            this._z = (c + l) / e) : (e = 2 * Math.sqrt(1 + u - r - s),
            this._w = (a - i) / e,
            this._x = (o + h) / e,
            this._y = (c + l) / e,
            this._z = .25 * e),
            this.onChangeCallback(),
            this
        },
        setFromUnitVectors: function() {
            var t, e = new Fe;
            return function(n, r) {
                return void 0 === e && (e = new Fe),
                (t = n.dot(r) + 1) < 1e-6 ? (t = 0,
                Math.abs(n.x) > Math.abs(n.z) ? e.set(-n.y, n.x, 0) : e.set(0, -n.z, n.y)) : e.crossVectors(n, r),
                this._x = e.x,
                this._y = e.y,
                this._z = e.z,
                this._w = t,
                this.normalize()
            }
        }(),
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this.onChangeCallback(),
            this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (t = 1 / t,
            this._x = this._x * t,
            this._y = this._y * t,
            this._z = this._z * t,
            this._w = this._w * t),
            this.onChangeCallback(),
            this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        premultiply: function(t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function(t, e) {
            var n = t._x
              , r = t._y
              , i = t._z
              , o = t._w
              , a = e._x
              , s = e._y
              , c = e._z
              , h = e._w;
            return this._x = n * h + o * a + r * c - i * s,
            this._y = r * h + o * s + i * a - n * c,
            this._z = i * h + o * c + n * s - r * a,
            this._w = o * h - n * a - r * s - i * c,
            this.onChangeCallback(),
            this
        },
        slerp: function(t, e) {
            if (0 === e)
                return this;
            if (1 === e)
                return this.copy(t);
            var n = this._x
              , r = this._y
              , i = this._z
              , o = this._w
              , a = o * t._w + n * t._x + r * t._y + i * t._z;
            if (a < 0 ? (this._w = -t._w,
            this._x = -t._x,
            this._y = -t._y,
            this._z = -t._z,
            a = -a) : this.copy(t),
            a >= 1)
                return this._w = o,
                this._x = n,
                this._y = r,
                this._z = i,
                this;
            var s = Math.sqrt(1 - a * a);
            if (Math.abs(s) < .001)
                return this._w = .5 * (o + this._w),
                this._x = .5 * (n + this._x),
                this._y = .5 * (r + this._y),
                this._z = .5 * (i + this._z),
                this;
            var c = Math.atan2(s, a)
              , h = Math.sin((1 - e) * c) / s
              , l = Math.sin(e * c) / s;
            return this._w = o * h + this._w * l,
            this._x = n * h + this._x * l,
            this._y = r * h + this._y * l,
            this._z = i * h + this._z * l,
            this.onChangeCallback(),
            this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this._x = t[e],
            this._y = t[e + 1],
            this._z = t[e + 2],
            this._w = t[e + 3],
            this.onChangeCallback(),
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._w,
            t
        },
        onChange: function(t) {
            return this.onChangeCallback = t,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(Fe.prototype, {
        isVector3: !0,
        set: function(t, e, n) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this
        },
        setScalar: function(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this
        },
        multiply: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(t, e)) : (this.x *= t.x,
            this.y *= t.y,
            this.z *= t.z,
            this)
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x,
            this.y = t.y * e.y,
            this.z = t.z * e.z,
            this
        },
        applyEuler: function() {
            var t = new ze;
            return function(e) {
                return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                this.applyQuaternion(t.setFromEuler(e))
            }
        }(),
        applyAxisAngle: function() {
            var t = new ze;
            return function(e, n) {
                return this.applyQuaternion(t.setFromAxisAngle(e, n))
            }
        }(),
        applyMatrix3: function(t) {
            var e = this.x
              , n = this.y
              , r = this.z
              , i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6] * r,
            this.y = i[1] * e + i[4] * n + i[7] * r,
            this.z = i[2] * e + i[5] * n + i[8] * r,
            this
        },
        applyMatrix4: function(t) {
            var e = this.x
              , n = this.y
              , r = this.z
              , i = t.elements
              , o = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
            return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * o,
            this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * o,
            this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * o,
            this
        },
        applyQuaternion: function(t) {
            var e = this.x
              , n = this.y
              , r = this.z
              , i = t.x
              , o = t.y
              , a = t.z
              , s = t.w
              , c = s * e + o * r - a * n
              , h = s * n + a * e - i * r
              , l = s * r + i * n - o * e
              , u = -i * e - o * n - a * r;
            return this.x = c * s + u * -i + h * -a - l * -o,
            this.y = h * s + u * -o + l * -i - c * -a,
            this.z = l * s + u * -a + c * -o - h * -i,
            this
        },
        project: function() {
            var t = new Be;
            return function(e) {
                return t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)),
                this.applyMatrix4(t)
            }
        }(),
        unproject: function() {
            var t = new Be;
            return function(e) {
                return t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)),
                this.applyMatrix4(t)
            }
        }(),
        transformDirection: function(t) {
            var e = this.x
              , n = this.y
              , r = this.z
              , i = t.elements;
            return this.x = i[0] * e + i[4] * n + i[8] * r,
            this.y = i[1] * e + i[5] * n + i[9] * r,
            this.z = i[2] * e + i[6] * n + i[10] * r,
            this.normalize()
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this.z /= t.z,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this
        },
        clampScalar: function() {
            var t = new Fe
              , e = new Fe;
            return function(n, r) {
                return t.set(n, n, n),
                e.set(r, r, r),
                this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        cross: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(t, e)) : this.crossVectors(this, t)
        },
        crossVectors: function(t, e) {
            var n = t.x
              , r = t.y
              , i = t.z
              , o = e.x
              , a = e.y
              , s = e.z;
            return this.x = r * s - i * a,
            this.y = i * o - n * s,
            this.z = n * a - r * o,
            this
        },
        projectOnVector: function(t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e)
        },
        projectOnPlane: function() {
            var t = new Fe;
            return function(e) {
                return t.copy(this).projectOnVector(e),
                this.sub(t)
            }
        }(),
        reflect: function() {
            var t = new Fe;
            return function(e) {
                return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        }(),
        angleTo: function(t) {
            var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
            return Math.acos(Ue.clamp(e, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x
              , n = this.y - t.y
              , r = this.z - t.z;
            return e * e + n * n + r * r
        },
        manhattanDistanceTo: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function(t) {
            var e = Math.sin(t.phi) * t.radius;
            return this.x = e * Math.sin(t.theta),
            this.y = Math.cos(t.phi) * t.radius,
            this.z = e * Math.cos(t.theta),
            this
        },
        setFromCylindrical: function(t) {
            return this.x = t.radius * Math.sin(t.theta),
            this.y = t.y,
            this.z = t.radius * Math.cos(t.theta),
            this
        },
        setFromMatrixPosition: function(t) {
            var e = t.elements;
            return this.x = e[12],
            this.y = e[13],
            this.z = e[14],
            this
        },
        setFromMatrixScale: function(t) {
            var e = this.setFromMatrixColumn(t, 0).length()
              , n = this.setFromMatrixColumn(t, 1).length()
              , r = this.setFromMatrixColumn(t, 2).length();
            return this.x = e,
            this.y = n,
            this.z = r,
            this
        },
        setFromMatrixColumn: function(t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this
        }
    }),
    Object.assign(ke.prototype, {
        isMatrix3: !0,
        set: function(t, e, n, r, i, o, a, s, c) {
            var h = this.elements;
            return h[0] = t,
            h[1] = r,
            h[2] = a,
            h[3] = e,
            h[4] = i,
            h[5] = s,
            h[6] = n,
            h[7] = o,
            h[8] = c,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements
              , n = t.elements;
            return e[0] = n[0],
            e[1] = n[1],
            e[2] = n[2],
            e[3] = n[3],
            e[4] = n[4],
            e[5] = n[5],
            e[6] = n[6],
            e[7] = n[7],
            e[8] = n[8],
            this
        },
        setFromMatrix4: function(t) {
            var e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
        },
        applyToBufferAttribute: function() {
            var t = new Fe;
            return function(e) {
                for (var n = 0, r = e.count; n < r; n++)
                    t.x = e.getX(n),
                    t.y = e.getY(n),
                    t.z = e.getZ(n),
                    t.applyMatrix3(this),
                    e.setXYZ(n, t.x, t.y, t.z);
                return e
            }
        }(),
        multiply: function(t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements
              , r = e.elements
              , i = this.elements
              , o = n[0]
              , a = n[3]
              , s = n[6]
              , c = n[1]
              , h = n[4]
              , l = n[7]
              , u = n[2]
              , p = n[5]
              , d = n[8]
              , f = r[0]
              , m = r[3]
              , g = r[6]
              , v = r[1]
              , y = r[4]
              , x = r[7]
              , w = r[2]
              , b = r[5]
              , M = r[8];
            return i[0] = o * f + a * v + s * w,
            i[3] = o * m + a * y + s * b,
            i[6] = o * g + a * x + s * M,
            i[1] = c * f + h * v + l * w,
            i[4] = c * m + h * y + l * b,
            i[7] = c * g + h * x + l * M,
            i[2] = u * f + p * v + d * w,
            i[5] = u * m + p * y + d * b,
            i[8] = u * g + p * x + d * M,
            this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t,
            e[3] *= t,
            e[6] *= t,
            e[1] *= t,
            e[4] *= t,
            e[7] *= t,
            e[2] *= t,
            e[5] *= t,
            e[8] *= t,
            this
        },
        determinant: function() {
            var t = this.elements
              , e = t[0]
              , n = t[1]
              , r = t[2]
              , i = t[3]
              , o = t[4]
              , a = t[5]
              , s = t[6]
              , c = t[7]
              , h = t[8];
            return e * o * h - e * a * c - n * i * h + n * a * s + r * i * c - r * o * s
        },
        getInverse: function(t, e) {
            t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var n = t.elements
              , r = this.elements
              , i = n[0]
              , o = n[1]
              , a = n[2]
              , s = n[3]
              , c = n[4]
              , h = n[5]
              , l = n[6]
              , u = n[7]
              , p = n[8]
              , d = p * c - h * u
              , f = h * l - p * s
              , m = u * s - c * l
              , g = i * d + o * f + a * m;
            if (0 === g) {
                var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === e)
                    throw new Error(v);
                return console.warn(v),
                this.identity()
            }
            var y = 1 / g;
            return r[0] = d * y,
            r[1] = (a * u - p * o) * y,
            r[2] = (h * o - a * c) * y,
            r[3] = f * y,
            r[4] = (p * i - a * l) * y,
            r[5] = (a * s - h * i) * y,
            r[6] = m * y,
            r[7] = (o * l - u * i) * y,
            r[8] = (c * i - o * s) * y,
            this
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1],
            e[1] = e[3],
            e[3] = t,
            t = e[2],
            e[2] = e[6],
            e[6] = t,
            t = e[5],
            e[5] = e[7],
            e[7] = t,
            this
        },
        getNormalMatrix: function(t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0],
            t[1] = e[3],
            t[2] = e[6],
            t[3] = e[1],
            t[4] = e[4],
            t[5] = e[7],
            t[6] = e[2],
            t[7] = e[5],
            t[8] = e[8],
            this
        },
        setUvTransform: function(t, e, n, r, i, o, a) {
            var s = Math.cos(i)
              , c = Math.sin(i);
            this.set(n * s, n * c, -n * (s * o + c * a) + o + t, -r * c, r * s, -r * (-c * o + s * a) + a + e, 0, 0, 1)
        },
        scale: function(t, e) {
            var n = this.elements;
            return n[0] *= t,
            n[3] *= t,
            n[6] *= t,
            n[1] *= e,
            n[4] *= e,
            n[7] *= e,
            this
        },
        rotate: function(t) {
            var e = Math.cos(t)
              , n = Math.sin(t)
              , r = this.elements
              , i = r[0]
              , o = r[3]
              , a = r[6]
              , s = r[1]
              , c = r[4]
              , h = r[7];
            return r[0] = e * i + n * s,
            r[3] = e * o + n * c,
            r[6] = e * a + n * h,
            r[1] = -n * i + e * s,
            r[4] = -n * o + e * c,
            r[7] = -n * a + e * h,
            this
        },
        translate: function(t, e) {
            var n = this.elements;
            return n[0] += t * n[2],
            n[3] += t * n[5],
            n[6] += t * n[8],
            n[1] += e * n[2],
            n[4] += e * n[5],
            n[7] += e * n[8],
            this
        },
        equals: function(t) {
            for (var e = this.elements, n = t.elements, r = 0; r < 9; r++)
                if (e[r] !== n[r])
                    return !1;
            return !0
        },
        fromArray: function(t, e) {
            void 0 === e && (e = 0);
            for (var n = 0; n < 9; n++)
                this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            void 0 === t && (t = []),
            void 0 === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t
        }
    });
    var He = 0;
    function Ge(t, e, n, r, i, o, a, s, c, h) {
        Object.defineProperty(this, "id", {
            value: He++
        }),
        this.uuid = Ue.generateUUID(),
        this.name = "",
        this.image = void 0 !== t ? t : Ge.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== e ? e : Ge.DEFAULT_MAPPING,
        this.wrapS = void 0 !== n ? n : gt,
        this.wrapT = void 0 !== r ? r : gt,
        this.magFilter = void 0 !== i ? i : bt,
        this.minFilter = void 0 !== o ? o : _t,
        this.anisotropy = void 0 !== c ? c : 1,
        this.format = void 0 !== a ? a : zt,
        this.type = void 0 !== s ? s : Et,
        this.offset = new Ne(0,0),
        this.repeat = new Ne(1,1),
        this.center = new Ne(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new ke,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== h ? h : Se,
        this.version = 0,
        this.onUpdate = null
    }
    function Ve(t, e, n, r) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = n || 0,
        this.w = void 0 !== r ? r : 1
    }
    function je(t, e, n) {
        this.uuid = Ue.generateUUID(),
        this.width = t,
        this.height = e,
        this.scissor = new Ve(0,0,t,e),
        this.scissorTest = !1,
        this.viewport = new Ve(0,0,t,e),
        void 0 === (n = n || {}).minFilter && (n.minFilter = bt),
        this.texture = new Ge(void 0,void 0,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
        this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
        this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer,
        this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }
    function We(t, e, n) {
        je.call(this, t, e, n),
        this.activeCubeFace = 0,
        this.activeMipMapLevel = 0
    }
    function Ye(t, e, n, r, i, o, a, s, c, h, l, u) {
        Ge.call(this, null, o, a, s, c, h, r, i, l, u),
        this.image = {
            data: t,
            width: e,
            height: n
        },
        this.magFilter = void 0 !== c ? c : yt,
        this.minFilter = void 0 !== h ? h : yt,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
    function Xe(t, e, n, r, i, o, a, s, c, h) {
        t = void 0 !== t ? t : [],
        e = void 0 !== e ? e : ct,
        Ge.call(this, t, e, n, r, i, o, a, s, c, h),
        this.flipY = !1
    }
    Ge.DEFAULT_IMAGE = void 0,
    Ge.DEFAULT_MAPPING = st,
    Ge.prototype = Object.assign(Object.create(r.prototype), {
        constructor: Ge,
        isTexture: !0,
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name,
            this.image = t.image,
            this.mipmaps = t.mipmaps.slice(0),
            this.mapping = t.mapping,
            this.wrapS = t.wrapS,
            this.wrapT = t.wrapT,
            this.magFilter = t.magFilter,
            this.minFilter = t.minFilter,
            this.anisotropy = t.anisotropy,
            this.format = t.format,
            this.type = t.type,
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            this.rotation = t.rotation,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrix.copy(t.matrix),
            this.generateMipmaps = t.generateMipmaps,
            this.premultiplyAlpha = t.premultiplyAlpha,
            this.flipY = t.flipY,
            this.unpackAlignment = t.unpackAlignment,
            this.encoding = t.encoding,
            this
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
                return t.textures[this.uuid];
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var r = this.image;
                void 0 === r.uuid && (r.uuid = Ue.generateUUID()),
                e || void 0 !== t.images[r.uuid] || (t.images[r.uuid] = {
                    uuid: r.uuid,
                    url: function(t) {
                        var e;
                        if (t instanceof HTMLCanvasElement)
                            e = t;
                        else {
                            (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = t.width,
                            e.height = t.height;
                            var n = e.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height)
                        }
                        return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }(r)
                }),
                n.image = r.uuid
            }
            return e || (t.textures[this.uuid] = n),
            n
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (this.mapping === st) {
                if (t.applyMatrix3(this.matrix),
                t.x < 0 || t.x > 1)
                    switch (this.wrapS) {
                    case mt:
                        t.x = t.x - Math.floor(t.x);
                        break;
                    case gt:
                        t.x = t.x < 0 ? 0 : 1;
                        break;
                    case vt:
                        1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                if (t.y < 0 || t.y > 1)
                    switch (this.wrapT) {
                    case mt:
                        t.y = t.y - Math.floor(t.y);
                        break;
                    case gt:
                        t.y = t.y < 0 ? 0 : 1;
                        break;
                    case vt:
                        1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                this.flipY && (t.y = 1 - t.y)
            }
        }
    }),
    Object.defineProperty(Ge.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(Ve.prototype, {
        isVector4: !0,
        set: function(t, e, n, r) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this.w = r,
            this
        },
        setScalar: function(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this.w = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setW: function(t) {
            return this.w = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this.w = void 0 !== t.w ? t.w : 1,
            this
        },
        add: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this.w += t.w,
            this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this.w += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this.w = t.w + e.w,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this.w += t.w * e,
            this
        },
        sub: function(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this.w -= t.w,
            this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this.w -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this.w = t.w - e.w,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this.w *= t,
            this
        },
        applyMatrix4: function(t) {
            var e = this.x
              , n = this.y
              , r = this.z
              , i = this.w
              , o = t.elements;
            return this.x = o[0] * e + o[4] * n + o[8] * r + o[12] * i,
            this.y = o[1] * e + o[5] * n + o[9] * r + o[13] * i,
            this.z = o[2] * e + o[6] * n + o[10] * r + o[14] * i,
            this.w = o[3] * e + o[7] * n + o[11] * r + o[15] * i,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = t.x / e,
            this.y = t.y / e,
            this.z = t.z / e),
            this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e, n, r, i, o = t.elements, a = o[0], s = o[4], c = o[8], h = o[1], l = o[5], u = o[9], p = o[2], d = o[6], f = o[10];
            if (Math.abs(s - h) < .01 && Math.abs(c - p) < .01 && Math.abs(u - d) < .01) {
                if (Math.abs(s + h) < .1 && Math.abs(c + p) < .1 && Math.abs(u + d) < .1 && Math.abs(a + l + f - 3) < .1)
                    return this.set(1, 0, 0, 0),
                    this;
                e = Math.PI;
                var m = (a + 1) / 2
                  , g = (l + 1) / 2
                  , v = (f + 1) / 2
                  , y = (s + h) / 4
                  , x = (c + p) / 4
                  , w = (u + d) / 4;
                return m > g && m > v ? m < .01 ? (n = 0,
                r = .707106781,
                i = .707106781) : (r = y / (n = Math.sqrt(m)),
                i = x / n) : g > v ? g < .01 ? (n = .707106781,
                r = 0,
                i = .707106781) : (n = y / (r = Math.sqrt(g)),
                i = w / r) : v < .01 ? (n = .707106781,
                r = .707106781,
                i = 0) : (n = x / (i = Math.sqrt(v)),
                r = w / i),
                this.set(n, r, i, e),
                this
            }
            var b = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (h - s) * (h - s));
            return Math.abs(b) < .001 && (b = 1),
            this.x = (d - u) / b,
            this.y = (c - p) / b,
            this.z = (h - s) / b,
            this.w = Math.acos((a + l + f - 1) / 2),
            this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this.w = Math.min(this.w, t.w),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this.w = Math.max(this.w, t.w),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this.w = Math.max(t.w, Math.min(e.w, this.w)),
            this
        },
        clampScalar: function() {
            var t, e;
            return function(n, r) {
                return void 0 === t && (t = new Ve,
                e = new Ve),
                t.set(n, n, n, n),
                e.set(r, r, r, r),
                this.clamp(t, e)
            }
        }(),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this.w += (t.w - this.w) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this.w = t[e + 3],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t[e + 3] = this.w,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this.w = t.getW(e),
            this
        }
    }),
    je.prototype = Object.assign(Object.create(r.prototype), {
        constructor: je,
        isWebGLRenderTarget: !0,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t,
            this.height = e,
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width,
            this.height = t.height,
            this.viewport.copy(t.viewport),
            this.texture = t.texture.clone(),
            this.depthBuffer = t.depthBuffer,
            this.stencilBuffer = t.stencilBuffer,
            this.depthTexture = t.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    We.prototype = Object.create(je.prototype),
    We.prototype.constructor = We,
    We.prototype.isWebGLRenderTargetCube = !0,
    Ye.prototype = Object.create(Ge.prototype),
    Ye.prototype.constructor = Ye,
    Ye.prototype.isDataTexture = !0,
    Xe.prototype = Object.create(Ge.prototype),
    Xe.prototype.constructor = Xe,
    Xe.prototype.isCubeTexture = !0,
    Object.defineProperty(Xe.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    });
    var qe = new Ge
      , Ze = new Xe;
    function Je() {
        this.seq = [],
        this.map = {}
    }
    var Ke = []
      , Qe = []
      , $e = new Float32Array(16)
      , tn = new Float32Array(9);
    function en(t, e, n) {
        var r = t[0];
        if (r <= 0 || r > 0)
            return t;
        var i = e * n
          , o = Ke[i];
        if (void 0 === o && (o = new Float32Array(i),
        Ke[i] = o),
        0 !== e) {
            r.toArray(o, 0);
            for (var a = 1, s = 0; a !== e; ++a)
                s += n,
                t[a].toArray(o, s)
        }
        return o
    }
    function nn(t, e) {
        var n = Qe[e];
        void 0 === n && (n = new Int32Array(e),
        Qe[e] = n);
        for (var r = 0; r !== e; ++r)
            n[r] = t.allocTextureUnit();
        return n
    }
    function rn(t, e) {
        t.uniform1f(this.addr, e)
    }
    function on(t, e) {
        t.uniform1i(this.addr, e)
    }
    function an(t, e) {
        void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
    }
    function sn(t, e) {
        void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
    }
    function cn(t, e) {
        void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
    }
    function hn(t, e) {
        t.uniformMatrix2fv(this.addr, !1, e.elements || e)
    }
    function ln(t, e) {
        void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : (tn.set(e.elements),
        t.uniformMatrix3fv(this.addr, !1, tn))
    }
    function un(t, e) {
        void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : ($e.set(e.elements),
        t.uniformMatrix4fv(this.addr, !1, $e))
    }
    function pn(t, e, n) {
        var r = n.allocTextureUnit();
        t.uniform1i(this.addr, r),
        n.setTexture2D(e || qe, r)
    }
    function dn(t, e, n) {
        var r = n.allocTextureUnit();
        t.uniform1i(this.addr, r),
        n.setTextureCube(e || Ze, r)
    }
    function fn(t, e) {
        t.uniform2iv(this.addr, e)
    }
    function mn(t, e) {
        t.uniform3iv(this.addr, e)
    }
    function gn(t, e) {
        t.uniform4iv(this.addr, e)
    }
    function vn(t, e) {
        t.uniform1fv(this.addr, e)
    }
    function yn(t, e) {
        t.uniform1iv(this.addr, e)
    }
    function xn(t, e) {
        t.uniform2fv(this.addr, en(e, this.size, 2))
    }
    function wn(t, e) {
        t.uniform3fv(this.addr, en(e, this.size, 3))
    }
    function bn(t, e) {
        t.uniform4fv(this.addr, en(e, this.size, 4))
    }
    function Mn(t, e) {
        t.uniformMatrix2fv(this.addr, !1, en(e, this.size, 4))
    }
    function _n(t, e) {
        t.uniformMatrix3fv(this.addr, !1, en(e, this.size, 9))
    }
    function En(t, e) {
        t.uniformMatrix4fv(this.addr, !1, en(e, this.size, 16))
    }
    function Sn(t, e, n) {
        var r = e.length
          , i = nn(n, r);
        t.uniform1iv(this.addr, i);
        for (var o = 0; o !== r; ++o)
            n.setTexture2D(e[o] || qe, i[o])
    }
    function Tn(t, e, n) {
        var r = e.length
          , i = nn(n, r);
        t.uniform1iv(this.addr, i);
        for (var o = 0; o !== r; ++o)
            n.setTextureCube(e[o] || Ze, i[o])
    }
    function An(t, e, n) {
        this.id = t,
        this.addr = n,
        this.setValue = function(t) {
            switch (e.type) {
            case 5126:
                return rn;
            case 35664:
                return an;
            case 35665:
                return sn;
            case 35666:
                return cn;
            case 35674:
                return hn;
            case 35675:
                return ln;
            case 35676:
                return un;
            case 35678:
            case 36198:
                return pn;
            case 35680:
                return dn;
            case 5124:
            case 35670:
                return on;
            case 35667:
            case 35671:
                return fn;
            case 35668:
            case 35672:
                return mn;
            case 35669:
            case 35673:
                return gn
            }
        }()
    }
    function Ln(t, e, n) {
        this.id = t,
        this.addr = n,
        this.size = e.size,
        this.setValue = function(t) {
            switch (e.type) {
            case 5126:
                return vn;
            case 35664:
                return xn;
            case 35665:
                return wn;
            case 35666:
                return bn;
            case 35674:
                return Mn;
            case 35675:
                return _n;
            case 35676:
                return En;
            case 35678:
                return Sn;
            case 35680:
                return Tn;
            case 5124:
            case 35670:
                return yn;
            case 35667:
            case 35671:
                return fn;
            case 35668:
            case 35672:
                return mn;
            case 35669:
            case 35673:
                return gn
            }
        }()
    }
    function Rn(t) {
        this.id = t,
        Je.call(this)
    }
    Rn.prototype.setValue = function(t, e) {
        for (var n = this.seq, r = 0, i = n.length; r !== i; ++r) {
            var o = n[r];
            o.setValue(t, e[o.id])
        }
    }
    ;
    var Pn = /([\w\d_]+)(\])?(\[|\.)?/g;
    function Cn(t, e) {
        t.seq.push(e),
        t.map[e.id] = e
    }
    function In(t, e, n) {
        var r = t.name
          , i = r.length;
        for (Pn.lastIndex = 0; ; ) {
            var o = Pn.exec(r)
              , a = Pn.lastIndex
              , s = o[1]
              , c = "]" === o[2]
              , h = o[3];
            if (c && (s |= 0),
            void 0 === h || "[" === h && a + 2 === i) {
                Cn(n, void 0 === h ? new An(s,t,e) : new Ln(s,t,e));
                break
            }
            var l = n.map[s];
            void 0 === l && Cn(n, l = new Rn(s)),
            n = l
        }
    }
    function On(t, e, n) {
        Je.call(this),
        this.renderer = n;
        for (var r = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), i = 0; i < r; ++i) {
            var o = t.getActiveUniform(e, i)
              , a = o.name;
            In(o, t.getUniformLocation(e, a), this)
        }
    }
    On.prototype.setValue = function(t, e, n) {
        var r = this.map[e];
        void 0 !== r && r.setValue(t, n, this.renderer)
    }
    ,
    On.prototype.setOptional = function(t, e, n) {
        var r = e[n];
        void 0 !== r && this.setValue(t, n, r)
    }
    ,
    On.upload = function(t, e, n, r) {
        for (var i = 0, o = e.length; i !== o; ++i) {
            var a = e[i]
              , s = n[a.id];
            !1 !== s.needsUpdate && a.setValue(t, s.value, r)
        }
    }
    ,
    On.seqWithValue = function(t, e) {
        for (var n = [], r = 0, i = t.length; r !== i; ++r) {
            var o = t[r];
            o.id in e && n.push(o)
        }
        return n
    }
    ;
    var Dn = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    function Un(t, e, n) {
        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
    }
    Object.assign(Un.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
            this
        },
        setScalar: function(t) {
            return this.r = t,
            this.g = t,
            this.b = t,
            this
        },
        setHex: function(t) {
            return t = Math.floor(t),
            this.r = (t >> 16 & 255) / 255,
            this.g = (t >> 8 & 255) / 255,
            this.b = (255 & t) / 255,
            this
        },
        setRGB: function(t, e, n) {
            return this.r = t,
            this.g = e,
            this.b = n,
            this
        },
        setHSL: function() {
            function t(t, e, n) {
                return n < 0 && (n += 1),
                n > 1 && (n -= 1),
                n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
            }
            return function(e, n, r) {
                if (e = Ue.euclideanModulo(e, 1),
                n = Ue.clamp(n, 0, 1),
                r = Ue.clamp(r, 0, 1),
                0 === n)
                    this.r = this.g = this.b = r;
                else {
                    var i = r <= .5 ? r * (1 + n) : r + n - r * n
                      , o = 2 * r - i;
                    this.r = t(o, i, e + 1 / 3),
                    this.g = t(o, i, e),
                    this.b = t(o, i, e - 1 / 3)
                }
                return this
            }
        }(),
        setStyle: function(t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var r, i = n[1], o = n[2];
                switch (i) {
                case "rgb":
                case "rgba":
                    if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
                        return this.r = Math.min(255, parseInt(r[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(r[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(r[3], 10)) / 255,
                        e(r[5]),
                        this;
                    if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
                        return this.r = Math.min(100, parseInt(r[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(r[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(r[3], 10)) / 100,
                        e(r[5]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                        var a = parseFloat(r[1]) / 360
                          , s = parseInt(r[2], 10) / 100
                          , c = parseInt(r[3], 10) / 100;
                        return e(r[5]),
                        this.setHSL(a, s, c)
                    }
                }
            } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                var h, l = (h = n[1]).length;
                if (3 === l)
                    return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255,
                    this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255,
                    this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255,
                    this;
                if (6 === l)
                    return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255,
                    this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255,
                    this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255,
                    this
            }
            return t && t.length > 0 && (void 0 !== (h = Dn[t]) ? this.setHex(h) : console.warn("THREE.Color: Unknown color " + t)),
            this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(t) {
            return this.r = t.r,
            this.g = t.g,
            this.b = t.b,
            this
        },
        copyGammaToLinear: function(t, e) {
            return void 0 === e && (e = 2),
            this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        },
        copyLinearToGamma: function(t, e) {
            void 0 === e && (e = 2);
            var n = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, n),
            this.g = Math.pow(t.g, n),
            this.b = Math.pow(t.b, n),
            this
        },
        convertGammaToLinear: function() {
            var t = this.r
              , e = this.g
              , n = this.b;
            return this.r = t * t,
            this.g = e * e,
            this.b = n * n,
            this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r),
            this.g = Math.sqrt(this.g),
            this.b = Math.sqrt(this.b),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(t) {
            var e, n, r = t || {
                h: 0,
                s: 0,
                l: 0
            }, i = this.r, o = this.g, a = this.b, s = Math.max(i, o, a), c = Math.min(i, o, a), h = (c + s) / 2;
            if (c === s)
                e = 0,
                n = 0;
            else {
                var l = s - c;
                switch (n = h <= .5 ? l / (s + c) : l / (2 - s - c),
                s) {
                case i:
                    e = (o - a) / l + (o < a ? 6 : 0);
                    break;
                case o:
                    e = (a - i) / l + 2;
                    break;
                case a:
                    e = (i - o) / l + 4
                }
                e /= 6
            }
            return r.h = e,
            r.s = n,
            r.l = h,
            r
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(t, e, n) {
            var r = this.getHSL();
            return r.h += t,
            r.s += e,
            r.l += n,
            this.setHSL(r.h, r.s, r.l),
            this
        },
        add: function(t) {
            return this.r += t.r,
            this.g += t.g,
            this.b += t.b,
            this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r,
            this.g = t.g + e.g,
            this.b = t.b + e.b,
            this
        },
        addScalar: function(t) {
            return this.r += t,
            this.g += t,
            this.b += t,
            this
        },
        sub: function(t) {
            return this.r = Math.max(0, this.r - t.r),
            this.g = Math.max(0, this.g - t.g),
            this.b = Math.max(0, this.b - t.b),
            this
        },
        multiply: function(t) {
            return this.r *= t.r,
            this.g *= t.g,
            this.b *= t.b,
            this
        },
        multiplyScalar: function(t) {
            return this.r *= t,
            this.g *= t,
            this.b *= t,
            this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e,
            this.g += (t.g - this.g) * e,
            this.b += (t.b - this.b) * e,
            this
        },
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return void 0 === e && (e = 0),
            this.r = t[e],
            this.g = t[e + 1],
            this.b = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this.r,
            t[e + 1] = this.g,
            t[e + 2] = this.b,
            t
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var Nn = {
        common: {
            diffuse: {
                value: new Un(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new ke
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Ne(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Un(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Un(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new ke
            }
        }
    }
      , Bn = {
        merge: function(t) {
            for (var e = {}, n = 0; n < t.length; n++) {
                var r = this.clone(t[n]);
                for (var i in r)
                    e[i] = r[i]
            }
            return e
        },
        clone: function(t) {
            var e = {};
            for (var n in t)
                for (var r in e[n] = {},
                t[n]) {
                    var i = t[n][r];
                    i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
                }
            return e
        }
    }
      , zn = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "\nvec3 transformed = vec3( position );\n",
        beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
        bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
        dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
        cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
        equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n"
    }
      , Fn = {
        basic: {
            uniforms: Bn.merge([Nn.common, Nn.specularmap, Nn.envmap, Nn.aomap, Nn.lightmap, Nn.fog]),
            vertexShader: zn.meshbasic_vert,
            fragmentShader: zn.meshbasic_frag
        },
        lambert: {
            uniforms: Bn.merge([Nn.common, Nn.specularmap, Nn.envmap, Nn.aomap, Nn.lightmap, Nn.emissivemap, Nn.fog, Nn.lights, {
                emissive: {
                    value: new Un(0)
                }
            }]),
            vertexShader: zn.meshlambert_vert,
            fragmentShader: zn.meshlambert_frag
        },
        phong: {
            uniforms: Bn.merge([Nn.common, Nn.specularmap, Nn.envmap, Nn.aomap, Nn.lightmap, Nn.emissivemap, Nn.bumpmap, Nn.normalmap, Nn.displacementmap, Nn.gradientmap, Nn.fog, Nn.lights, {
                emissive: {
                    value: new Un(0)
                },
                specular: {
                    value: new Un(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: zn.meshphong_vert,
            fragmentShader: zn.meshphong_frag
        },
        standard: {
            uniforms: Bn.merge([Nn.common, Nn.envmap, Nn.aomap, Nn.lightmap, Nn.emissivemap, Nn.bumpmap, Nn.normalmap, Nn.displacementmap, Nn.roughnessmap, Nn.metalnessmap, Nn.fog, Nn.lights, {
                emissive: {
                    value: new Un(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: zn.meshphysical_vert,
            fragmentShader: zn.meshphysical_frag
        },
        points: {
            uniforms: Bn.merge([Nn.points, Nn.fog]),
            vertexShader: zn.points_vert,
            fragmentShader: zn.points_frag
        },
        dashed: {
            uniforms: Bn.merge([Nn.common, Nn.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: zn.linedashed_vert,
            fragmentShader: zn.linedashed_frag
        },
        depth: {
            uniforms: Bn.merge([Nn.common, Nn.displacementmap]),
            vertexShader: zn.depth_vert,
            fragmentShader: zn.depth_frag
        },
        normal: {
            uniforms: Bn.merge([Nn.common, Nn.bumpmap, Nn.normalmap, Nn.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: zn.normal_vert,
            fragmentShader: zn.normal_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: zn.cube_vert,
            fragmentShader: zn.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: zn.equirect_vert,
            fragmentShader: zn.equirect_frag
        },
        distanceRGBA: {
            uniforms: Bn.merge([Nn.common, Nn.displacementmap, {
                referencePosition: {
                    value: new Fe
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: zn.distanceRGBA_vert,
            fragmentShader: zn.distanceRGBA_frag
        },
        shadow: {
            uniforms: Bn.merge([Nn.lights, Nn.fog, {
                color: {
                    value: new Un(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: zn.shadow_vert,
            fragmentShader: zn.shadow_frag
        }
    };
    function kn(t, e, n, r, i, o, a, s, c) {
        Ge.call(this, t, e, n, r, i, o, a, s, c),
        this.needsUpdate = !0
    }
    Fn.physical = {
        uniforms: Bn.merge([Fn.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: zn.meshphysical_vert,
        fragmentShader: zn.meshphysical_frag
    },
    kn.prototype = Object.create(Ge.prototype),
    kn.prototype.constructor = kn;
    var Hn = 0;
    function Gn() {
        Object.defineProperty(this, "id", {
            value: Hn++
        }),
        this.uuid = Ue.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.lights = !0,
        this.blending = E,
        this.side = m,
        this.flatShading = !1,
        this.vertexColors = w,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = z,
        this.blendDst = F,
        this.blendEquation = R,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = q,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.overdraw = 0,
        this.visible = !0,
        this.userData = {},
        this.needsUpdate = !0
    }
    function Vn(t) {
        Gn.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = Oe,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.setValues(t)
    }
    function jn(t) {
        Gn.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new Fe,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.lights = !1,
        this.setValues(t)
    }
    function Wn(t, e) {
        this.min = void 0 !== t ? t : new Fe(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== e ? e : new Fe(-1 / 0,-1 / 0,-1 / 0)
    }
    function Yn(t, e) {
        this.center = void 0 !== t ? t : new Fe,
        this.radius = void 0 !== e ? e : 0
    }
    function Xn(t, e) {
        this.normal = void 0 !== t ? t : new Fe(1,0,0),
        this.constant = void 0 !== e ? e : 0
    }
    function qn(t, e, n, r, i, o) {
        this.planes = [void 0 !== t ? t : new Xn, void 0 !== e ? e : new Xn, void 0 !== n ? n : new Xn, void 0 !== r ? r : new Xn, void 0 !== i ? i : new Xn, void 0 !== o ? o : new Xn]
    }
    function Zn(t, e, n) {
        for (var r = new qn, i = new Be, o = new Ne, a = new Ne(n,n), s = new Fe, c = new Fe, h = 1, l = 2, u = 1 + (h | l), p = new Array(u), f = new Array(u), y = {}, x = {
            0: g,
            1: m,
            2: v
        }, w = [new Fe(1,0,0), new Fe(-1,0,0), new Fe(0,0,1), new Fe(0,0,-1), new Fe(0,1,0), new Fe(0,-1,0)], b = [new Fe(0,1,0), new Fe(0,1,0), new Fe(0,1,0), new Fe(0,1,0), new Fe(0,0,1), new Fe(0,0,-1)], M = [new Ve, new Ve, new Ve, new Ve, new Ve, new Ve], _ = 0; _ !== u; ++_) {
            var E = 0 != (_ & h)
              , S = 0 != (_ & l)
              , T = new Vn({
                depthPacking: De,
                morphTargets: E,
                skinning: S
            });
            p[_] = T;
            var A = new jn({
                morphTargets: E,
                skinning: S
            });
            f[_] = A
        }
        var L = this;
        function R(e, n, r, i, o, a) {
            var s = e.geometry
              , c = null
              , u = p
              , d = e.customDepthMaterial;
            if (r && (u = f,
            d = e.customDistanceMaterial),
            d)
                c = d;
            else {
                var m = !1;
                n.morphTargets && (s && s.isBufferGeometry ? m = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (m = s.morphTargets && s.morphTargets.length > 0)),
                e.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                var g = e.isSkinnedMesh && n.skinning
                  , v = 0;
                m && (v |= h),
                g && (v |= l),
                c = u[v]
            }
            if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                var w = c.uuid
                  , b = n.uuid
                  , M = y[w];
                void 0 === M && (M = {},
                y[w] = M);
                var _ = M[b];
                void 0 === _ && (_ = c.clone(),
                M[b] = _),
                c = _
            }
            return c.visible = n.visible,
            c.wireframe = n.wireframe,
            c.side = null != n.shadowSide ? n.shadowSide : x[n.side],
            c.clipShadows = n.clipShadows,
            c.clippingPlanes = n.clippingPlanes,
            c.clipIntersection = n.clipIntersection,
            c.wireframeLinewidth = n.wireframeLinewidth,
            c.linewidth = n.linewidth,
            r && c.isMeshDistanceMaterial && (c.referencePosition.copy(i),
            c.nearDistance = o,
            c.farDistance = a),
            c
        }
        function P(n, i, o, a) {
            if (!1 !== n.visible) {
                if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || r.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    var s = e.update(n)
                      , h = n.material;
                    if (Array.isArray(h))
                        for (var l = s.groups, u = 0, p = l.length; u < p; u++) {
                            var d = l[u]
                              , f = h[d.materialIndex];
                            if (f && f.visible) {
                                var m = R(n, f, a, c, o.near, o.far);
                                t.renderBufferDirect(o, null, s, m, n, d)
                            }
                        }
                    else
                        h.visible && (m = R(n, h, a, c, o.near, o.far),
                        t.renderBufferDirect(o, null, s, m, n, null))
                }
                for (var g = n.children, v = 0, y = g.length; v < y; v++)
                    P(g[v], i, o, a)
            }
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = d,
        this.render = function(e, n, h) {
            if (!1 !== L.enabled && (!1 !== L.autoUpdate || !1 !== L.needsUpdate) && 0 !== e.length) {
                var l, u = t.context, p = t.state;
                p.disable(u.BLEND),
                p.buffers.color.setClear(1, 1, 1, 1),
                p.buffers.depth.setTest(!0),
                p.setScissorTest(!1);
                for (var d = 0, f = e.length; d < f; d++) {
                    var m = e[d]
                      , g = m.shadow
                      , v = m && m.isPointLight;
                    if (void 0 !== g) {
                        var y = g.camera;
                        if (o.copy(g.mapSize),
                        o.min(a),
                        v) {
                            var x = o.x
                              , _ = o.y;
                            M[0].set(2 * x, _, x, _),
                            M[1].set(0, _, x, _),
                            M[2].set(3 * x, _, x, _),
                            M[3].set(x, _, x, _),
                            M[4].set(3 * x, 0, x, _),
                            M[5].set(x, 0, x, _),
                            o.x *= 4,
                            o.y *= 2
                        }
                        if (null === g.map) {
                            var E = {
                                minFilter: yt,
                                magFilter: yt,
                                format: zt
                            };
                            g.map = new je(o.x,o.y,E),
                            g.map.texture.name = m.name + ".shadowMap",
                            y.updateProjectionMatrix()
                        }
                        g.isSpotLightShadow && g.update(m);
                        var S = g.map
                          , T = g.matrix;
                        c.setFromMatrixPosition(m.matrixWorld),
                        y.position.copy(c),
                        v ? (l = 6,
                        T.makeTranslation(-c.x, -c.y, -c.z)) : (l = 1,
                        s.setFromMatrixPosition(m.target.matrixWorld),
                        y.lookAt(s),
                        y.updateMatrixWorld(),
                        T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        T.multiply(y.projectionMatrix),
                        T.multiply(y.matrixWorldInverse)),
                        t.setRenderTarget(S),
                        t.clear();
                        for (var A = 0; A < l; A++) {
                            if (v) {
                                s.copy(y.position),
                                s.add(w[A]),
                                y.up.copy(b[A]),
                                y.lookAt(s),
                                y.updateMatrixWorld();
                                var R = M[A];
                                p.viewport(R)
                            }
                            i.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse),
                            r.setFromMatrix(i),
                            P(n, h, y, v)
                        }
                    } else
                        console.warn("THREE.WebGLShadowMap:", m, "has no shadow.")
                }
                L.needsUpdate = !1
            }
        }
    }
    function Jn(t, e, n, r) {
        this._x = t || 0,
        this._y = e || 0,
        this._z = n || 0,
        this._order = r || Jn.DefaultOrder
    }
    function Kn() {
        this.mask = 1
    }
    Gn.prototype = Object.assign(Object.create(r.prototype), {
        constructor: Gn,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(t) {
            if (void 0 !== t)
                for (var e in t) {
                    var n = t[e];
                    if (void 0 !== n)
                        if ("shading" !== e) {
                            var r = this[e];
                            void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = "overdraw" === e ? Number(n) : n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        } else
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                            this.flatShading = n === y;
                    else
                        console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            var n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function r(t) {
                var e = [];
                for (var n in t) {
                    var r = t[n];
                    delete r.metadata,
                    e.push(r)
                }
                return e
            }
            if (n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid),
            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
            n.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
            n.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
            n.displacementScale = this.displacementScale,
            n.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
            n.reflectivity = this.reflectivity),
            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.size && (n.size = this.size),
            void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
            this.blending !== E && (n.blending = this.blending),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            this.side !== m && (n.side = this.side),
            this.vertexColors !== w && (n.vertexColors = this.vertexColors),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            n.depthFunc = this.depthFunc,
            n.depthTest = this.depthTest,
            n.depthWrite = this.depthWrite,
            0 !== this.rotation && (n.rotation = this.rotation),
            1 !== this.linewidth && (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.skinning && (n.skinning = !0),
            !1 === this.visible && (n.visible = !1),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            e) {
                var i = r(t.textures)
                  , o = r(t.images);
                i.length > 0 && (n.textures = i),
                o.length > 0 && (n.images = o)
            }
            return n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name,
            this.fog = t.fog,
            this.lights = t.lights,
            this.blending = t.blending,
            this.side = t.side,
            this.flatShading = t.flatShading,
            this.vertexColors = t.vertexColors,
            this.opacity = t.opacity,
            this.transparent = t.transparent,
            this.blendSrc = t.blendSrc,
            this.blendDst = t.blendDst,
            this.blendEquation = t.blendEquation,
            this.blendSrcAlpha = t.blendSrcAlpha,
            this.blendDstAlpha = t.blendDstAlpha,
            this.blendEquationAlpha = t.blendEquationAlpha,
            this.depthFunc = t.depthFunc,
            this.depthTest = t.depthTest,
            this.depthWrite = t.depthWrite,
            this.colorWrite = t.colorWrite,
            this.precision = t.precision,
            this.polygonOffset = t.polygonOffset,
            this.polygonOffsetFactor = t.polygonOffsetFactor,
            this.polygonOffsetUnits = t.polygonOffsetUnits,
            this.dithering = t.dithering,
            this.alphaTest = t.alphaTest,
            this.premultipliedAlpha = t.premultipliedAlpha,
            this.overdraw = t.overdraw,
            this.visible = t.visible,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            this.clipShadows = t.clipShadows,
            this.clipIntersection = t.clipIntersection;
            var e = t.clippingPlanes
              , n = null;
            if (null !== e) {
                var r = e.length;
                n = new Array(r);
                for (var i = 0; i !== r; ++i)
                    n[i] = e[i].clone()
            }
            return this.clippingPlanes = n,
            this.shadowSide = t.shadowSide,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Vn.prototype = Object.create(Gn.prototype),
    Vn.prototype.constructor = Vn,
    Vn.prototype.isMeshDepthMaterial = !0,
    Vn.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.depthPacking = t.depthPacking,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this
    }
    ,
    jn.prototype = Object.create(Gn.prototype),
    jn.prototype.constructor = jn,
    jn.prototype.isMeshDistanceMaterial = !0,
    jn.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.referencePosition.copy(t.referencePosition),
        this.nearDistance = t.nearDistance,
        this.farDistance = t.farDistance,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this
    }
    ,
    Object.assign(Wn.prototype, {
        isBox3: !0,
        set: function(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        },
        setFromArray: function(t) {
            for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                var h = t[s]
                  , l = t[s + 1]
                  , u = t[s + 2];
                h < e && (e = h),
                l < n && (n = l),
                u < r && (r = u),
                h > i && (i = h),
                l > o && (o = l),
                u > a && (a = u)
            }
            return this.min.set(e, n, r),
            this.max.set(i, o, a),
            this
        },
        setFromBufferAttribute: function(t) {
            for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) {
                var h = t.getX(s)
                  , l = t.getY(s)
                  , u = t.getZ(s);
                h < e && (e = h),
                l < n && (n = l),
                u < r && (r = u),
                h > i && (i = h),
                l > o && (o = l),
                u > a && (a = u)
            }
            return this.min.set(e, n, r),
            this.max.set(i, o, a),
            this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new Fe;
            return function(e, n) {
                var r = t.copy(n).multiplyScalar(.5);
                return this.min.copy(e).sub(r),
                this.max.copy(e).add(r),
                this
            }
        }(),
        setFromObject: function(t) {
            return this.makeEmpty(),
            this.expandByObject(t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(t) {
            var e = t || new Fe;
            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            var e = t || new Fe;
            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        },
        expandByVector: function(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        },
        expandByObject: function() {
            var t, e, n, r = new Fe;
            function i(i) {
                var o = i.geometry;
                if (void 0 !== o)
                    if (o.isGeometry) {
                        var a = o.vertices;
                        for (e = 0,
                        n = a.length; e < n; e++)
                            r.copy(a[e]),
                            r.applyMatrix4(i.matrixWorld),
                            t.expandByPoint(r)
                    } else if (o.isBufferGeometry) {
                        var s = o.attributes.position;
                        if (void 0 !== s)
                            for (e = 0,
                            n = s.count; e < n; e++)
                                r.fromBufferAttribute(s, e).applyMatrix4(i.matrixWorld),
                                t.expandByPoint(r)
                    }
            }
            return function(e) {
                return t = this,
                e.updateMatrixWorld(!0),
                e.traverse(i),
                this
            }
        }(),
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        },
        getParameter: function(t, e) {
            return (e || new Fe).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        },
        intersectsSphere: function() {
            var t = new Fe;
            return function(e) {
                return this.clampPoint(e.center, t),
                t.distanceToSquared(e.center) <= e.radius * e.radius
            }
        }(),
        intersectsPlane: function(t) {
            var e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
            n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
            n = t.normal.x * this.min.x),
            t.normal.y > 0 ? (e += t.normal.y * this.min.y,
            n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
            n += t.normal.y * this.min.y),
            t.normal.z > 0 ? (e += t.normal.z * this.min.z,
            n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
            n += t.normal.z * this.min.z),
            e <= t.constant && n >= t.constant
        },
        intersectsTriangle: function() {
            var t = new Fe
              , e = new Fe
              , n = new Fe
              , r = new Fe
              , i = new Fe
              , o = new Fe
              , a = new Fe
              , s = new Fe
              , c = new Fe
              , h = new Fe;
            function l(r) {
                var i, o;
                for (i = 0,
                o = r.length - 3; i <= o; i += 3) {
                    a.fromArray(r, i);
                    var s = c.x * Math.abs(a.x) + c.y * Math.abs(a.y) + c.z * Math.abs(a.z)
                      , h = t.dot(a)
                      , l = e.dot(a)
                      , u = n.dot(a);
                    if (Math.max(-Math.max(h, l, u), Math.min(h, l, u)) > s)
                        return !1
                }
                return !0
            }
            return function(a) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(s),
                c.subVectors(this.max, s),
                t.subVectors(a.a, s),
                e.subVectors(a.b, s),
                n.subVectors(a.c, s),
                r.subVectors(e, t),
                i.subVectors(n, e),
                o.subVectors(t, n);
                var u = [0, -r.z, r.y, 0, -i.z, i.y, 0, -o.z, o.y, r.z, 0, -r.x, i.z, 0, -i.x, o.z, 0, -o.x, -r.y, r.x, 0, -i.y, i.x, 0, -o.y, o.x, 0];
                return !!l(u) && !!l(u = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (h.crossVectors(r, i),
                l(u = [h.x, h.y, h.z]))
            }
        }(),
        clampPoint: function(t, e) {
            return (e || new Fe).copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new Fe;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        getBoundingSphere: function() {
            var t = new Fe;
            return function(e) {
                var n = e || new Yn;
                return this.getCenter(n.center),
                n.radius = .5 * this.getSize(t).length(),
                n
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        },
        applyMatrix4: function() {
            var t = [new Fe, new Fe, new Fe, new Fe, new Fe, new Fe, new Fe, new Fe];
            return function(e) {
                return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                this.setFromPoints(t),
                this)
            }
        }(),
        translate: function(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }),
    Object.assign(Yn.prototype, {
        set: function(t, e) {
            return this.center.copy(t),
            this.radius = e,
            this
        },
        setFromPoints: function() {
            var t = new Wn;
            return function(e, n) {
                var r = this.center;
                void 0 !== n ? r.copy(n) : t.setFromPoints(e).getCenter(r);
                for (var i = 0, o = 0, a = e.length; o < a; o++)
                    i = Math.max(i, r.distanceToSquared(e[o]));
                return this.radius = Math.sqrt(i),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center),
            this.radius = t.radius,
            this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function(t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(t, e) {
            var n = this.center.distanceToSquared(t)
              , r = e || new Fe;
            return r.copy(t),
            n > this.radius * this.radius && (r.sub(this.center).normalize(),
            r.multiplyScalar(this.radius).add(this.center)),
            r
        },
        getBoundingBox: function(t) {
            var e = t || new Wn;
            return e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t),
            this.radius = this.radius * t.getMaxScaleOnAxis(),
            this
        },
        translate: function(t) {
            return this.center.add(t),
            this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    }),
    Object.assign(Xn.prototype, {
        set: function(t, e) {
            return this.normal.copy(t),
            this.constant = e,
            this
        },
        setComponents: function(t, e, n, r) {
            return this.normal.set(t, e, n),
            this.constant = r,
            this
        },
        setFromNormalAndCoplanarPoint: function(t, e) {
            return this.normal.copy(t),
            this.constant = -e.dot(this.normal),
            this
        },
        setFromCoplanarPoints: function() {
            var t = new Fe
              , e = new Fe;
            return function(n, r, i) {
                var o = t.subVectors(i, r).cross(e.subVectors(n, r)).normalize();
                return this.setFromNormalAndCoplanarPoint(o, n),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.normal.copy(t.normal),
            this.constant = t.constant,
            this
        },
        normalize: function() {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t),
            this.constant *= t,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(t) {
            return this.normal.dot(t) + this.constant
        },
        distanceToSphere: function(t) {
            return this.distanceToPoint(t.center) - t.radius
        },
        projectPoint: function(t, e) {
            return (e || new Fe).copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        },
        intersectLine: function() {
            var t = new Fe;
            return function(e, n) {
                var r = n || new Fe
                  , i = e.delta(t)
                  , o = this.normal.dot(i);
                if (0 === o)
                    return 0 === this.distanceToPoint(e.start) ? r.copy(e.start) : void 0;
                var a = -(e.start.dot(this.normal) + this.constant) / o;
                return a < 0 || a > 1 ? void 0 : r.copy(i).multiplyScalar(a).add(e.start)
            }
        }(),
        intersectsLine: function(t) {
            var e = this.distanceToPoint(t.start)
              , n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0
        },
        intersectsBox: function(t) {
            return t.intersectsPlane(this)
        },
        intersectsSphere: function(t) {
            return t.intersectsPlane(this)
        },
        coplanarPoint: function(t) {
            return (t || new Fe).copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: function() {
            var t = new Fe
              , e = new ke;
            return function(n, r) {
                var i = r || e.getNormalMatrix(n)
                  , o = this.coplanarPoint(t).applyMatrix4(n)
                  , a = this.normal.applyMatrix3(i).normalize();
                return this.constant = -o.dot(a),
                this
            }
        }(),
        translate: function(t) {
            return this.constant -= t.dot(this.normal),
            this
        },
        equals: function(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    }),
    Object.assign(qn.prototype, {
        set: function(t, e, n, r, i, o) {
            var a = this.planes;
            return a[0].copy(t),
            a[1].copy(e),
            a[2].copy(n),
            a[3].copy(r),
            a[4].copy(i),
            a[5].copy(o),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            for (var e = this.planes, n = 0; n < 6; n++)
                e[n].copy(t.planes[n]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes
              , n = t.elements
              , r = n[0]
              , i = n[1]
              , o = n[2]
              , a = n[3]
              , s = n[4]
              , c = n[5]
              , h = n[6]
              , l = n[7]
              , u = n[8]
              , p = n[9]
              , d = n[10]
              , f = n[11]
              , m = n[12]
              , g = n[13]
              , v = n[14]
              , y = n[15];
            return e[0].setComponents(a - r, l - s, f - u, y - m).normalize(),
            e[1].setComponents(a + r, l + s, f + u, y + m).normalize(),
            e[2].setComponents(a + i, l + c, f + p, y + g).normalize(),
            e[3].setComponents(a - i, l - c, f - p, y - g).normalize(),
            e[4].setComponents(a - o, l - h, f - d, y - v).normalize(),
            e[5].setComponents(a + o, l + h, f + d, y + v).normalize(),
            this
        },
        intersectsObject: function() {
            var t = new Yn;
            return function(e) {
                var n = e.geometry;
                return null === n.boundingSphere && n.computeBoundingSphere(),
                t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld),
                this.intersectsSphere(t)
            }
        }(),
        intersectsSprite: function() {
            var t = new Yn;
            return function(e) {
                return t.center.set(0, 0, 0),
                t.radius = .7071067811865476,
                t.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(t)
            }
        }(),
        intersectsSphere: function(t) {
            for (var e = this.planes, n = t.center, r = -t.radius, i = 0; i < 6; i++)
                if (e[i].distanceToPoint(n) < r)
                    return !1;
            return !0
        },
        intersectsBox: function() {
            var t = new Fe
              , e = new Fe;
            return function(n) {
                for (var r = this.planes, i = 0; i < 6; i++) {
                    var o = r[i];
                    t.x = o.normal.x > 0 ? n.min.x : n.max.x,
                    e.x = o.normal.x > 0 ? n.max.x : n.min.x,
                    t.y = o.normal.y > 0 ? n.min.y : n.max.y,
                    e.y = o.normal.y > 0 ? n.max.y : n.min.y,
                    t.z = o.normal.z > 0 ? n.min.z : n.max.z,
                    e.z = o.normal.z > 0 ? n.max.z : n.min.z;
                    var a = o.distanceToPoint(t)
                      , s = o.distanceToPoint(e);
                    if (a < 0 && s < 0)
                        return !1
                }
                return !0
            }
        }(),
        containsPoint: function(t) {
            for (var e = this.planes, n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0)
                    return !1;
            return !0
        }
    }),
    Jn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
    Jn.DefaultOrder = "XYZ",
    Object.defineProperties(Jn.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t,
                this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(t) {
                this._order = t,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(Jn.prototype, {
        isEuler: !0,
        set: function(t, e, n, r) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._order = r || this._order,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(t) {
            return this._x = t._x,
            this._y = t._y,
            this._z = t._z,
            this._order = t._order,
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(t, e, n) {
            var r = Ue.clamp
              , i = t.elements
              , o = i[0]
              , a = i[4]
              , s = i[8]
              , c = i[1]
              , h = i[5]
              , l = i[9]
              , u = i[2]
              , p = i[6]
              , d = i[10];
            return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(r(s, -1, 1)),
            Math.abs(s) < .99999 ? (this._x = Math.atan2(-l, d),
            this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, h),
            this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-r(l, -1, 1)),
            Math.abs(l) < .99999 ? (this._y = Math.atan2(s, d),
            this._z = Math.atan2(c, h)) : (this._y = Math.atan2(-u, o),
            this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(r(p, -1, 1)),
            Math.abs(p) < .99999 ? (this._y = Math.atan2(-u, d),
            this._z = Math.atan2(-a, h)) : (this._y = 0,
            this._z = Math.atan2(c, o))) : "ZYX" === e ? (this._y = Math.asin(-r(u, -1, 1)),
            Math.abs(u) < .99999 ? (this._x = Math.atan2(p, d),
            this._z = Math.atan2(c, o)) : (this._x = 0,
            this._z = Math.atan2(-a, h))) : "YZX" === e ? (this._z = Math.asin(r(c, -1, 1)),
            Math.abs(c) < .99999 ? (this._x = Math.atan2(-l, h),
            this._y = Math.atan2(-u, o)) : (this._x = 0,
            this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math.asin(-r(a, -1, 1)),
            Math.abs(a) < .99999 ? (this._x = Math.atan2(p, h),
            this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-l, d),
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e),
            this._order = e,
            !1 !== n && this.onChangeCallback(),
            this
        },
        setFromQuaternion: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeRotationFromQuaternion(e),
                this.setFromRotationMatrix(t, n, r)
            }
        }(),
        setFromVector3: function(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        },
        reorder: function() {
            var t = new ze;
            return function(e) {
                return t.setFromEuler(this),
                this.setFromQuaternion(t, e)
            }
        }(),
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        },
        fromArray: function(t) {
            return this._x = t[0],
            this._y = t[1],
            this._z = t[2],
            void 0 !== t[3] && (this._order = t[3]),
            this.onChangeCallback(),
            this
        },
        toArray: function(t, e) {
            return void 0 === t && (t = []),
            void 0 === e && (e = 0),
            t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._order,
            t
        },
        toVector3: function(t) {
            return t ? t.set(this._x, this._y, this._z) : new Fe(this._x,this._y,this._z)
        },
        onChange: function(t) {
            return this.onChangeCallback = t,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(Kn.prototype, {
        set: function(t) {
            this.mask = 1 << t | 0
        },
        enable: function(t) {
            this.mask |= 1 << t | 0
        },
        toggle: function(t) {
            this.mask ^= 1 << t | 0
        },
        disable: function(t) {
            this.mask &= ~(1 << t | 0)
        },
        test: function(t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var Qn = 0;
    function $n() {
        Object.defineProperty(this, "id", {
            value: Qn++
        }),
        this.uuid = Ue.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = $n.DefaultUp.clone();
        var t = new Fe
          , e = new Jn
          , n = new ze
          , r = new Fe(1,1,1);
        e.onChange(function() {
            n.setFromEuler(e, !1)
        }),
        n.onChange(function() {
            e.setFromQuaternion(n, void 0, !1)
        }),
        Object.defineProperties(this, {
            position: {
                enumerable: !0,
                value: t
            },
            rotation: {
                enumerable: !0,
                value: e
            },
            quaternion: {
                enumerable: !0,
                value: n
            },
            scale: {
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new Be
            },
            normalMatrix: {
                value: new ke
            }
        }),
        this.matrix = new Be,
        this.matrixWorld = new Be,
        this.matrixAutoUpdate = $n.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Kn,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    function tr() {
        $n.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new Be,
        this.projectionMatrix = new Be
    }
    function er(t, e, n, r, i, o) {
        tr.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = t,
        this.right = e,
        this.top = n,
        this.bottom = r,
        this.near = void 0 !== i ? i : .1,
        this.far = void 0 !== o ? o : 2e3,
        this.updateProjectionMatrix()
    }
    function nr(t, e, n, r, i, o) {
        this.a = t,
        this.b = e,
        this.c = n,
        this.normal = r && r.isVector3 ? r : new Fe,
        this.vertexNormals = Array.isArray(r) ? r : [],
        this.color = i && i.isColor ? i : new Un,
        this.vertexColors = Array.isArray(i) ? i : [],
        this.materialIndex = void 0 !== o ? o : 0
    }
    $n.DefaultUp = new Fe(0,1,0),
    $n.DefaultMatrixAutoUpdate = !0,
    $n.prototype = Object.assign(Object.create(r.prototype), {
        constructor: $n,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(t) {
            this.matrix.multiplyMatrices(t, this.matrix),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(t) {
            return this.quaternion.premultiply(t),
            this
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function() {
            var t = new ze;
            return function(e, n) {
                return t.setFromAxisAngle(e, n),
                this.quaternion.multiply(t),
                this
            }
        }(),
        rotateOnWorldAxis: function() {
            var t = new ze;
            return function(e, n) {
                return t.setFromAxisAngle(e, n),
                this.quaternion.premultiply(t),
                this
            }
        }(),
        rotateX: function() {
            var t = new Fe(1,0,0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateY: function() {
            var t = new Fe(0,1,0);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        rotateZ: function() {
            var t = new Fe(0,0,1);
            return function(e) {
                return this.rotateOnAxis(t, e)
            }
        }(),
        translateOnAxis: function() {
            var t = new Fe;
            return function(e, n) {
                return t.copy(e).applyQuaternion(this.quaternion),
                this.position.add(t.multiplyScalar(n)),
                this
            }
        }(),
        translateX: function() {
            var t = new Fe(1,0,0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateY: function() {
            var t = new Fe(0,1,0);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        translateZ: function() {
            var t = new Fe(0,0,1);
            return function(e) {
                return this.translateOnAxis(t, e)
            }
        }(),
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function() {
            var t = new Be;
            return function(e) {
                return e.applyMatrix4(t.getInverse(this.matrixWorld))
            }
        }(),
        lookAt: function() {
            var t = new Be
              , e = new Fe;
            return function(n, r, i) {
                n.isVector3 ? e.copy(n) : e.set(n, r, i),
                this.isCamera ? t.lookAt(this.position, e, this.up) : t.lookAt(e, this.position, this.up),
                this.quaternion.setFromRotationMatrix(t)
            }
        }(),
        add: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++)
                    this.add(arguments[e]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
            this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
            t.parent = this,
            t.dispatchEvent({
                type: "added"
            }),
            this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
            this)
        },
        remove: function(t) {
            if (arguments.length > 1) {
                for (var e = 0; e < arguments.length; e++)
                    this.remove(arguments[e]);
                return this
            }
            var n = this.children.indexOf(t);
            return -1 !== n && (t.parent = null,
            t.dispatchEvent({
                type: "removed"
            }),
            this.children.splice(n, 1)),
            this
        },
        getObjectById: function(t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e)
                return this;
            for (var n = 0, r = this.children.length; n < r; n++) {
                var i = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== i)
                    return i
            }
        },
        getWorldPosition: function(t) {
            var e = t || new Fe;
            return this.updateMatrixWorld(!0),
            e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function() {
            var t = new Fe
              , e = new Fe;
            return function(n) {
                var r = n || new ze;
                return this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(t, r, e),
                r
            }
        }(),
        getWorldRotation: function() {
            var t = new ze;
            return function(e) {
                var n = e || new Jn;
                return this.getWorldQuaternion(t),
                n.setFromQuaternion(t, this.rotation.order, !1)
            }
        }(),
        getWorldScale: function() {
            var t = new Fe
              , e = new ze;
            return function(n) {
                var r = n || new Fe;
                return this.updateMatrixWorld(!0),
                this.matrixWorld.decompose(t, e, r),
                r
            }
        }(),
        getWorldDirection: function() {
            var t = new ze;
            return function(e) {
                var n = e || new Fe;
                return this.getWorldQuaternion(t),
                n.set(0, 0, 1).applyQuaternion(t)
            }
        }(),
        raycast: function() {},
        traverse: function(t) {
            t(this);
            for (var e = this.children, n = 0, r = e.length; n < r; n++)
                e[n].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, n = 0, r = e.length; n < r; n++)
                    e[n].traverseVisible(t)
            }
        },
        traverseAncestors: function(t) {
            var e = this.parent;
            null !== e && (t(e),
            e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            t = !0);
            for (var e = this.children, n = 0, r = e.length; n < r; n++)
                e[n].updateMatrixWorld(t)
        },
        toJSON: function(t) {
            var e = void 0 === t || "string" == typeof t
              , n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var r = {};
            function i(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                n.uuid
            }
            if (r.uuid = this.uuid,
            r.type = this.type,
            "" !== this.name && (r.name = this.name),
            !0 === this.castShadow && (r.castShadow = !0),
            !0 === this.receiveShadow && (r.receiveShadow = !0),
            !1 === this.visible && (r.visible = !1),
            "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData),
            r.matrix = this.matrix.toArray(),
            void 0 !== this.geometry) {
                r.geometry = i(t.geometries, this.geometry);
                var o = this.geometry.parameters;
                if (void 0 !== o && void 0 !== o.shapes) {
                    var a = o.shapes;
                    if (Array.isArray(a))
                        for (var s = 0, c = a.length; s < c; s++) {
                            var h = a[s];
                            i(t.shapes, h)
                        }
                    else
                        i(t.shapes, a)
                }
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    var l = [];
                    for (s = 0,
                    c = this.material.length; s < c; s++)
                        l.push(i(t.materials, this.material[s]));
                    r.material = l
                } else
                    r.material = i(t.materials, this.material);
            if (this.children.length > 0)
                for (r.children = [],
                s = 0; s < this.children.length; s++)
                    r.children.push(this.children[s].toJSON(t).object);
            if (e) {
                var u = m(t.geometries)
                  , p = m(t.materials)
                  , d = m(t.textures)
                  , f = m(t.images);
                a = m(t.shapes),
                u.length > 0 && (n.geometries = u),
                p.length > 0 && (n.materials = p),
                d.length > 0 && (n.textures = d),
                f.length > 0 && (n.images = f),
                a.length > 0 && (n.shapes = a)
            }
            return n.object = r,
            n;
            function m(t) {
                var e = [];
                for (var n in t) {
                    var r = t[n];
                    delete r.metadata,
                    e.push(r)
                }
                return e
            }
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e) {
            if (void 0 === e && (e = !0),
            this.name = t.name,
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
            this.layers.mask = t.layers.mask,
            this.visible = t.visible,
            this.castShadow = t.castShadow,
            this.receiveShadow = t.receiveShadow,
            this.frustumCulled = t.frustumCulled,
            this.renderOrder = t.renderOrder,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            !0 === e)
                for (var n = 0; n < t.children.length; n++) {
                    var r = t.children[n];
                    this.add(r.clone())
                }
            return this
        }
    }),
    tr.prototype = Object.assign(Object.create($n.prototype), {
        constructor: tr,
        isCamera: !0,
        copy: function(t, e) {
            return $n.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this
        },
        getWorldDirection: function() {
            var t = new ze;
            return function(e) {
                var n = e || new Fe;
                return this.getWorldQuaternion(t),
                n.set(0, 0, -1).applyQuaternion(t)
            }
        }(),
        updateMatrixWorld: function(t) {
            $n.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    er.prototype = Object.assign(Object.create(tr.prototype), {
        constructor: er,
        isOrthographicCamera: !0,
        copy: function(t, e) {
            return tr.prototype.copy.call(this, t, e),
            this.left = t.left,
            this.right = t.right,
            this.top = t.top,
            this.bottom = t.bottom,
            this.near = t.near,
            this.far = t.far,
            this.zoom = t.zoom,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this
        },
        setViewOffset: function(t, e, n, r, i, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = r,
            this.view.width = i,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = (this.right - this.left) / (2 * this.zoom)
              , e = (this.top - this.bottom) / (2 * this.zoom)
              , n = (this.right + this.left) / 2
              , r = (this.top + this.bottom) / 2
              , i = n - t
              , o = n + t
              , a = r + e
              , s = r - e;
            if (null !== this.view && this.view.enabled) {
                var c = this.zoom / (this.view.width / this.view.fullWidth)
                  , h = this.zoom / (this.view.height / this.view.fullHeight)
                  , l = (this.right - this.left) / this.view.width
                  , u = (this.top - this.bottom) / this.view.height;
                o = (i += l * (this.view.offsetX / c)) + l * (this.view.width / c),
                s = (a -= u * (this.view.offsetY / h)) - u * (this.view.height / h)
            }
            this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far)
        },
        toJSON: function(t) {
            var e = $n.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom,
            e.object.left = this.left,
            e.object.right = this.right,
            e.object.top = this.top,
            e.object.bottom = this.bottom,
            e.object.near = this.near,
            e.object.far = this.far,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e
        }
    }),
    Object.assign(nr.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.a = t.a,
            this.b = t.b,
            this.c = t.c,
            this.normal.copy(t.normal),
            this.color.copy(t.color),
            this.materialIndex = t.materialIndex;
            for (var e = 0, n = t.vertexNormals.length; e < n; e++)
                this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0,
            n = t.vertexColors.length; e < n; e++)
                this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    });
    var rr = 0;
    function ir() {
        Object.defineProperty(this, "id", {
            value: rr += 2
        }),
        this.uuid = Ue.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.elementsNeedUpdate = !1,
        this.verticesNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.lineDistancesNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function or(t, e, n) {
        if (Array.isArray(t))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.uuid = Ue.generateUUID(),
        this.name = "",
        this.array = t,
        this.itemSize = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.normalized = !0 === n,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.onUploadCallback = function() {}
        ,
        this.version = 0
    }
    function ar(t, e, n) {
        or.call(this, new Int8Array(t), e, n)
    }
    function sr(t, e, n) {
        or.call(this, new Uint8Array(t), e, n)
    }
    function cr(t, e, n) {
        or.call(this, new Uint8ClampedArray(t), e, n)
    }
    function hr(t, e, n) {
        or.call(this, new Int16Array(t), e, n)
    }
    function lr(t, e, n) {
        or.call(this, new Uint16Array(t), e, n)
    }
    function ur(t, e, n) {
        or.call(this, new Int32Array(t), e, n)
    }
    function pr(t, e, n) {
        or.call(this, new Uint32Array(t), e, n)
    }
    function dr(t, e, n) {
        or.call(this, new Float32Array(t), e, n)
    }
    function fr(t, e, n) {
        or.call(this, new Float64Array(t), e, n)
    }
    function mr() {
        this.indices = [],
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.verticesNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    function gr(t) {
        if (0 === t.length)
            return -1 / 0;
        for (var e = t[0], n = 1, r = t.length; n < r; ++n)
            t[n] > e && (e = t[n]);
        return e
    }
    ir.prototype = Object.assign(Object.create(r.prototype), {
        constructor: ir,
        isGeometry: !0,
        applyMatrix: function(t) {
            for (var e = (new ke).getNormalMatrix(t), n = 0, r = this.vertices.length; n < r; n++)
                this.vertices[n].applyMatrix4(t);
            for (n = 0,
            r = this.faces.length; n < r; n++) {
                var i = this.faces[n];
                i.normal.applyMatrix3(e).normalize();
                for (var o = 0, a = i.vertexNormals.length; o < a; o++)
                    i.vertexNormals[o].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.verticesNeedUpdate = !0,
            this.normalsNeedUpdate = !0,
            this
        },
        rotateX: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationX(e),
                this.applyMatrix(t),
                this
            }
        }(),
        rotateY: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationY(e),
                this.applyMatrix(t),
                this
            }
        }(),
        rotateZ: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationZ(e),
                this.applyMatrix(t),
                this
            }
        }(),
        translate: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeTranslation(e, n, r),
                this.applyMatrix(t),
                this
            }
        }(),
        scale: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeScale(e, n, r),
                this.applyMatrix(t),
                this
            }
        }(),
        lookAt: function() {
            var t = new $n;
            return function(e) {
                t.lookAt(e),
                t.updateMatrix(),
                this.applyMatrix(t.matrix)
            }
        }(),
        fromBufferGeometry: function(t) {
            var e = this
              , n = null !== t.index ? t.index.array : void 0
              , r = t.attributes
              , i = r.position.array
              , o = void 0 !== r.normal ? r.normal.array : void 0
              , a = void 0 !== r.color ? r.color.array : void 0
              , s = void 0 !== r.uv ? r.uv.array : void 0
              , c = void 0 !== r.uv2 ? r.uv2.array : void 0;
            void 0 !== c && (this.faceVertexUvs[1] = []);
            for (var h = [], l = [], u = [], p = 0, d = 0; p < i.length; p += 3,
            d += 2)
                e.vertices.push(new Fe(i[p],i[p + 1],i[p + 2])),
                void 0 !== o && h.push(new Fe(o[p],o[p + 1],o[p + 2])),
                void 0 !== a && e.colors.push(new Un(a[p],a[p + 1],a[p + 2])),
                void 0 !== s && l.push(new Ne(s[d],s[d + 1])),
                void 0 !== c && u.push(new Ne(c[d],c[d + 1]));
            function f(t, n, r, i) {
                var p = new nr(t,n,r,void 0 !== o ? [h[t].clone(), h[n].clone(), h[r].clone()] : [],void 0 !== a ? [e.colors[t].clone(), e.colors[n].clone(), e.colors[r].clone()] : [],i);
                e.faces.push(p),
                void 0 !== s && e.faceVertexUvs[0].push([l[t].clone(), l[n].clone(), l[r].clone()]),
                void 0 !== c && e.faceVertexUvs[1].push([u[t].clone(), u[n].clone(), u[r].clone()])
            }
            var m = t.groups;
            if (m.length > 0)
                for (p = 0; p < m.length; p++)
                    for (var g = m[p], v = g.start, y = (d = v,
                    v + g.count); d < y; d += 3)
                        void 0 !== n ? f(n[d], n[d + 1], n[d + 2], g.materialIndex) : f(d, d + 1, d + 2, g.materialIndex);
            else if (void 0 !== n)
                for (p = 0; p < n.length; p += 3)
                    f(n[p], n[p + 1], n[p + 2]);
            else
                for (p = 0; p < i.length / 3; p += 3)
                    f(p, p + 1, p + 2);
            return this.computeFaceNormals(),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            this
        },
        center: function() {
            this.computeBoundingBox();
            var t = this.boundingBox.getCenter().negate();
            return this.translate(t.x, t.y, t.z),
            t
        },
        normalize: function() {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center
              , e = this.boundingSphere.radius
              , n = 0 === e ? 1 : 1 / e
              , r = new Be;
            return r.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1),
            this.applyMatrix(r),
            this
        },
        computeFaceNormals: function() {
            for (var t = new Fe, e = new Fe, n = 0, r = this.faces.length; n < r; n++) {
                var i = this.faces[n]
                  , o = this.vertices[i.a]
                  , a = this.vertices[i.b]
                  , s = this.vertices[i.c];
                t.subVectors(s, a),
                e.subVectors(o, a),
                t.cross(e),
                t.normalize(),
                i.normal.copy(t)
            }
        },
        computeVertexNormals: function(t) {
            var e, n, r, i, o, a;
            for (void 0 === t && (t = !0),
            a = new Array(this.vertices.length),
            e = 0,
            n = this.vertices.length; e < n; e++)
                a[e] = new Fe;
            if (t) {
                var s, c, h, l = new Fe, u = new Fe;
                for (r = 0,
                i = this.faces.length; r < i; r++)
                    o = this.faces[r],
                    s = this.vertices[o.a],
                    c = this.vertices[o.b],
                    h = this.vertices[o.c],
                    l.subVectors(h, c),
                    u.subVectors(s, c),
                    l.cross(u),
                    a[o.a].add(l),
                    a[o.b].add(l),
                    a[o.c].add(l)
            } else
                for (this.computeFaceNormals(),
                r = 0,
                i = this.faces.length; r < i; r++)
                    a[(o = this.faces[r]).a].add(o.normal),
                    a[o.b].add(o.normal),
                    a[o.c].add(o.normal);
            for (e = 0,
            n = this.vertices.length; e < n; e++)
                a[e].normalize();
            for (r = 0,
            i = this.faces.length; r < i; r++) {
                var p = (o = this.faces[r]).vertexNormals;
                3 === p.length ? (p[0].copy(a[o.a]),
                p[1].copy(a[o.b]),
                p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(),
                p[1] = a[o.b].clone(),
                p[2] = a[o.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            var t, e, n;
            for (this.computeFaceNormals(),
            t = 0,
            e = this.faces.length; t < e; t++) {
                var r = (n = this.faces[t]).vertexNormals;
                3 === r.length ? (r[0].copy(n.normal),
                r[1].copy(n.normal),
                r[2].copy(n.normal)) : (r[0] = n.normal.clone(),
                r[1] = n.normal.clone(),
                r[2] = n.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var t, e, n, r, i;
            for (n = 0,
            r = this.faces.length; n < r; n++)
                for ((i = this.faces[n]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(),
                i.__originalVertexNormals || (i.__originalVertexNormals = []),
                t = 0,
                e = i.vertexNormals.length; t < e; t++)
                    i.__originalVertexNormals[t] ? i.__originalVertexNormals[t].copy(i.vertexNormals[t]) : i.__originalVertexNormals[t] = i.vertexNormals[t].clone();
            var o = new ir;
            for (o.faces = this.faces,
            t = 0,
            e = this.morphTargets.length; t < e; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {},
                    this.morphNormals[t].faceNormals = [],
                    this.morphNormals[t].vertexNormals = [];
                    var a = this.morphNormals[t].faceNormals
                      , s = this.morphNormals[t].vertexNormals;
                    for (n = 0,
                    r = this.faces.length; n < r; n++)
                        c = new Fe,
                        h = {
                            a: new Fe,
                            b: new Fe,
                            c: new Fe
                        },
                        a.push(c),
                        s.push(h)
                }
                var c, h, l = this.morphNormals[t];
                for (o.vertices = this.morphTargets[t].vertices,
                o.computeFaceNormals(),
                o.computeVertexNormals(),
                n = 0,
                r = this.faces.length; n < r; n++)
                    i = this.faces[n],
                    c = l.faceNormals[n],
                    h = l.vertexNormals[n],
                    c.copy(i.normal),
                    h.a.copy(i.vertexNormals[0]),
                    h.b.copy(i.vertexNormals[1]),
                    h.c.copy(i.vertexNormals[2])
            }
            for (n = 0,
            r = this.faces.length; n < r; n++)
                (i = this.faces[n]).normal = i.__originalFaceNormal,
                i.vertexNormals = i.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Wn),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Yn),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, n) {
            if (t && t.isGeometry) {
                var r, i = this.vertices.length, o = this.vertices, a = t.vertices, s = this.faces, c = t.faces, h = this.faceVertexUvs[0], l = t.faceVertexUvs[0], u = this.colors, p = t.colors;
                void 0 === n && (n = 0),
                void 0 !== e && (r = (new ke).getNormalMatrix(e));
                for (var d = 0, f = a.length; d < f; d++) {
                    var m = a[d].clone();
                    void 0 !== e && m.applyMatrix4(e),
                    o.push(m)
                }
                for (d = 0,
                f = p.length; d < f; d++)
                    u.push(p[d].clone());
                for (d = 0,
                f = c.length; d < f; d++) {
                    var g, v, y, x = c[d], w = x.vertexNormals, b = x.vertexColors;
                    (g = new nr(x.a + i,x.b + i,x.c + i)).normal.copy(x.normal),
                    void 0 !== r && g.normal.applyMatrix3(r).normalize();
                    for (var M = 0, _ = w.length; M < _; M++)
                        v = w[M].clone(),
                        void 0 !== r && v.applyMatrix3(r).normalize(),
                        g.vertexNormals.push(v);
                    for (g.color.copy(x.color),
                    M = 0,
                    _ = b.length; M < _; M++)
                        y = b[M],
                        g.vertexColors.push(y.clone());
                    g.materialIndex = x.materialIndex + n,
                    s.push(g)
                }
                for (d = 0,
                f = l.length; d < f; d++) {
                    var E = l[d]
                      , S = [];
                    if (void 0 !== E) {
                        for (M = 0,
                        _ = E.length; M < _; M++)
                            S.push(E[M].clone());
                        h.push(S)
                    }
                }
            } else
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
        },
        mergeMesh: function(t) {
            t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
        },
        mergeVertices: function() {
            var t, e, n, r, i, o, a, s, c = {}, h = [], l = [], u = Math.pow(10, 4);
            for (n = 0,
            r = this.vertices.length; n < r; n++)
                t = this.vertices[n],
                void 0 === c[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (c[e] = n,
                h.push(this.vertices[n]),
                l[n] = h.length - 1) : l[n] = l[c[e]];
            var p = [];
            for (n = 0,
            r = this.faces.length; n < r; n++) {
                (i = this.faces[n]).a = l[i.a],
                i.b = l[i.b],
                i.c = l[i.c],
                o = [i.a, i.b, i.c];
                for (var d = 0; d < 3; d++)
                    if (o[d] === o[(d + 1) % 3]) {
                        p.push(n);
                        break
                    }
            }
            for (n = p.length - 1; n >= 0; n--) {
                var f = p[n];
                for (this.faces.splice(f, 1),
                a = 0,
                s = this.faceVertexUvs.length; a < s; a++)
                    this.faceVertexUvs[a].splice(f, 1)
            }
            var m = this.vertices.length - h.length;
            return this.vertices = h,
            m
        },
        setFromPoints: function(t) {
            this.vertices = [];
            for (var e = 0, n = t.length; e < n; e++) {
                var r = t[e];
                this.vertices.push(new Fe(r.x,r.y,r.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var t = this.faces, e = t.length, n = 0; n < e; n++)
                t[n]._id = n;
            t.sort(function(t, e) {
                return t.materialIndex - e.materialIndex
            });
            var r, i, o = this.faceVertexUvs[0], a = this.faceVertexUvs[1];
            for (o && o.length === e && (r = []),
            a && a.length === e && (i = []),
            n = 0; n < e; n++) {
                var s = t[n]._id;
                r && r.push(o[s]),
                i && i.push(a[s])
            }
            r && (this.faceVertexUvs[0] = r),
            i && (this.faceVertexUvs[1] = i)
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            "" !== this.name && (t.name = this.name),
            void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e)
                    void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            for (var r = [], i = 0; i < this.vertices.length; i++) {
                var o = this.vertices[i];
                r.push(o.x, o.y, o.z)
            }
            var a = []
              , s = []
              , c = {}
              , h = []
              , l = {}
              , u = []
              , p = {};
            for (i = 0; i < this.faces.length; i++) {
                var d = this.faces[i]
                  , f = void 0 !== this.faceVertexUvs[0][i]
                  , m = d.normal.length() > 0
                  , g = d.vertexNormals.length > 0
                  , v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b
                  , y = d.vertexColors.length > 0
                  , x = 0;
                if (x = _(x = _(x = _(x = _(x = _(x = _(x = _(x = _(x, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, g), 6, v), 7, y),
                a.push(x),
                a.push(d.a, d.b, d.c),
                a.push(d.materialIndex),
                f) {
                    var w = this.faceVertexUvs[0][i];
                    a.push(T(w[0]), T(w[1]), T(w[2]))
                }
                if (m && a.push(E(d.normal)),
                g) {
                    var b = d.vertexNormals;
                    a.push(E(b[0]), E(b[1]), E(b[2]))
                }
                if (v && a.push(S(d.color)),
                y) {
                    var M = d.vertexColors;
                    a.push(S(M[0]), S(M[1]), S(M[2]))
                }
            }
            function _(t, e, n) {
                return n ? t | 1 << e : t & ~(1 << e)
            }
            function E(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3,
                s.push(t.x, t.y, t.z),
                c[e])
            }
            function S(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== l[e] ? l[e] : (l[e] = h.length,
                h.push(t.getHex()),
                l[e])
            }
            function T(t) {
                var e = t.x.toString() + t.y.toString();
                return void 0 !== p[e] ? p[e] : (p[e] = u.length / 2,
                u.push(t.x, t.y),
                p[e])
            }
            return t.data = {},
            t.data.vertices = r,
            t.data.normals = s,
            h.length > 0 && (t.data.colors = h),
            u.length > 0 && (t.data.uvs = [u]),
            t.data.faces = a,
            t
        },
        clone: function() {
            return (new ir).copy(this)
        },
        copy: function(t) {
            var e, n, r, i, o, a;
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = t.name;
            var s = t.vertices;
            for (e = 0,
            n = s.length; e < n; e++)
                this.vertices.push(s[e].clone());
            var c = t.colors;
            for (e = 0,
            n = c.length; e < n; e++)
                this.colors.push(c[e].clone());
            var h = t.faces;
            for (e = 0,
            n = h.length; e < n; e++)
                this.faces.push(h[e].clone());
            for (e = 0,
            n = t.faceVertexUvs.length; e < n; e++) {
                var l = t.faceVertexUvs[e];
                for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []),
                r = 0,
                i = l.length; r < i; r++) {
                    var u = l[r]
                      , p = [];
                    for (o = 0,
                    a = u.length; o < a; o++) {
                        var d = u[o];
                        p.push(d.clone())
                    }
                    this.faceVertexUvs[e].push(p)
                }
            }
            var f = t.morphTargets;
            for (e = 0,
            n = f.length; e < n; e++) {
                var m = {};
                if (m.name = f[e].name,
                void 0 !== f[e].vertices)
                    for (m.vertices = [],
                    r = 0,
                    i = f[e].vertices.length; r < i; r++)
                        m.vertices.push(f[e].vertices[r].clone());
                if (void 0 !== f[e].normals)
                    for (m.normals = [],
                    r = 0,
                    i = f[e].normals.length; r < i; r++)
                        m.normals.push(f[e].normals[r].clone());
                this.morphTargets.push(m)
            }
            var g = t.morphNormals;
            for (e = 0,
            n = g.length; e < n; e++) {
                var v = {};
                if (void 0 !== g[e].vertexNormals)
                    for (v.vertexNormals = [],
                    r = 0,
                    i = g[e].vertexNormals.length; r < i; r++) {
                        var y = g[e].vertexNormals[r]
                          , x = {};
                        x.a = y.a.clone(),
                        x.b = y.b.clone(),
                        x.c = y.c.clone(),
                        v.vertexNormals.push(x)
                    }
                if (void 0 !== g[e].faceNormals)
                    for (v.faceNormals = [],
                    r = 0,
                    i = g[e].faceNormals.length; r < i; r++)
                        v.faceNormals.push(g[e].faceNormals[r].clone());
                this.morphNormals.push(v)
            }
            var w = t.skinWeights;
            for (e = 0,
            n = w.length; e < n; e++)
                this.skinWeights.push(w[e].clone());
            var b = t.skinIndices;
            for (e = 0,
            n = b.length; e < n; e++)
                this.skinIndices.push(b[e].clone());
            var M = t.lineDistances;
            for (e = 0,
            n = M.length; e < n; e++)
                this.lineDistances.push(M[e]);
            var _ = t.boundingBox;
            null !== _ && (this.boundingBox = _.clone());
            var E = t.boundingSphere;
            return null !== E && (this.boundingSphere = E.clone()),
            this.elementsNeedUpdate = t.elementsNeedUpdate,
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(or.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(or.prototype, {
        isBufferAttribute: !0,
        setArray: function(t) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== t ? t.length / this.itemSize : 0,
            this.array = t
        },
        setDynamic: function(t) {
            return this.dynamic = t,
            this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array),
            this.itemSize = t.itemSize,
            this.count = t.count,
            this.normalized = t.normalized,
            this.dynamic = t.dynamic,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.itemSize,
            n *= e.itemSize;
            for (var r = 0, i = this.itemSize; r < i; r++)
                this.array[t + r] = e.array[n + r];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t),
            this
        },
        copyColorsArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r),
                o = new Un),
                e[n++] = o.r,
                e[n++] = o.g,
                e[n++] = o.b
            }
            return this
        },
        copyIndicesArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                e[n++] = o.a,
                e[n++] = o.b,
                e[n++] = o.c
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r),
                o = new Ne),
                e[n++] = o.x,
                e[n++] = o.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r),
                o = new Fe),
                e[n++] = o.x,
                e[n++] = o.y,
                e[n++] = o.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r),
                o = new Ve),
                e[n++] = o.x,
                e[n++] = o.y,
                e[n++] = o.z,
                e[n++] = o.w
            }
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0),
            this.array.set(t, e),
            this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e,
            this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e,
            this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e,
            this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e,
            this
        },
        setXY: function(t, e, n) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, r) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = r,
            this
        },
        setXYZW: function(t, e, n, r, i) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = r,
            this.array[t + 3] = i,
            this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
    }),
    ar.prototype = Object.create(or.prototype),
    ar.prototype.constructor = ar,
    sr.prototype = Object.create(or.prototype),
    sr.prototype.constructor = sr,
    cr.prototype = Object.create(or.prototype),
    cr.prototype.constructor = cr,
    hr.prototype = Object.create(or.prototype),
    hr.prototype.constructor = hr,
    lr.prototype = Object.create(or.prototype),
    lr.prototype.constructor = lr,
    ur.prototype = Object.create(or.prototype),
    ur.prototype.constructor = ur,
    pr.prototype = Object.create(or.prototype),
    pr.prototype.constructor = pr,
    dr.prototype = Object.create(or.prototype),
    dr.prototype.constructor = dr,
    fr.prototype = Object.create(or.prototype),
    fr.prototype.constructor = fr,
    Object.assign(mr.prototype, {
        computeGroups: function(t) {
            for (var e, n = [], r = void 0, i = t.faces, o = 0; o < i.length; o++) {
                var a = i[o];
                a.materialIndex !== r && (r = a.materialIndex,
                void 0 !== e && (e.count = 3 * o - e.start,
                n.push(e)),
                e = {
                    start: 3 * o,
                    materialIndex: r
                })
            }
            void 0 !== e && (e.count = 3 * o - e.start,
            n.push(e)),
            this.groups = n
        },
        fromGeometry: function(t) {
            var e, n = t.faces, r = t.vertices, i = t.faceVertexUvs, o = i[0] && i[0].length > 0, a = i[1] && i[1].length > 0, s = t.morphTargets, c = s.length;
            if (c > 0) {
                e = [];
                for (var h = 0; h < c; h++)
                    e[h] = [];
                this.morphTargets.position = e
            }
            var l, u = t.morphNormals, p = u.length;
            if (p > 0) {
                for (l = [],
                h = 0; h < p; h++)
                    l[h] = [];
                this.morphTargets.normal = l
            }
            var d = t.skinIndices
              , f = t.skinWeights
              , m = d.length === r.length
              , g = f.length === r.length;
            for (h = 0; h < n.length; h++) {
                var v = n[h];
                this.vertices.push(r[v.a], r[v.b], r[v.c]);
                var y = v.vertexNormals;
                if (3 === y.length)
                    this.normals.push(y[0], y[1], y[2]);
                else {
                    var x = v.normal;
                    this.normals.push(x, x, x)
                }
                var w, b = v.vertexColors;
                if (3 === b.length)
                    this.colors.push(b[0], b[1], b[2]);
                else {
                    var M = v.color;
                    this.colors.push(M, M, M)
                }
                !0 === o && (void 0 !== (w = i[0][h]) ? this.uvs.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h),
                this.uvs.push(new Ne, new Ne, new Ne))),
                !0 === a && (void 0 !== (w = i[1][h]) ? this.uvs2.push(w[0], w[1], w[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h),
                this.uvs2.push(new Ne, new Ne, new Ne)));
                for (var _ = 0; _ < c; _++) {
                    var E = s[_].vertices;
                    e[_].push(E[v.a], E[v.b], E[v.c])
                }
                for (_ = 0; _ < p; _++) {
                    var S = u[_].vertexNormals[h];
                    l[_].push(S.a, S.b, S.c)
                }
                m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]),
                g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
            }
            return this.computeGroups(t),
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            this
        }
    });
    var vr = 1;
    function yr() {
        Object.defineProperty(this, "id", {
            value: vr += 2
        }),
        this.uuid = Ue.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        }
    }
    function xr(t, e, n, r, i, o) {
        ir.call(this),
        this.type = "BoxGeometry",
        this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: o
        },
        this.fromBufferGeometry(new wr(t,e,n,r,i,o)),
        this.mergeVertices()
    }
    function wr(t, e, n, r, i, o) {
        yr.call(this),
        this.type = "BoxBufferGeometry",
        this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: r,
            heightSegments: i,
            depthSegments: o
        };
        var a = this;
        t = t || 1,
        e = e || 1,
        n = n || 1,
        r = Math.floor(r) || 1,
        i = Math.floor(i) || 1;
        var s = []
          , c = []
          , h = []
          , l = []
          , u = 0
          , p = 0;
        function d(t, e, n, r, i, o, d, f, m, g, v) {
            var y, x, w = o / m, b = d / g, M = o / 2, _ = d / 2, E = f / 2, S = m + 1, T = g + 1, A = 0, L = 0, R = new Fe;
            for (x = 0; x < T; x++) {
                var P = x * b - _;
                for (y = 0; y < S; y++) {
                    var C = y * w - M;
                    R[t] = C * r,
                    R[e] = P * i,
                    R[n] = E,
                    c.push(R.x, R.y, R.z),
                    R[t] = 0,
                    R[e] = 0,
                    R[n] = f > 0 ? 1 : -1,
                    h.push(R.x, R.y, R.z),
                    l.push(y / m),
                    l.push(1 - x / g),
                    A += 1
                }
            }
            for (x = 0; x < g; x++)
                for (y = 0; y < m; y++) {
                    var I = u + y + S * x
                      , O = u + y + S * (x + 1)
                      , D = u + (y + 1) + S * (x + 1)
                      , U = u + (y + 1) + S * x;
                    s.push(I, O, U),
                    s.push(O, D, U),
                    L += 6
                }
            a.addGroup(p, L, v),
            p += L,
            u += A
        }
        d("z", "y", "x", -1, -1, n, e, t, o = Math.floor(o) || 1, i, 0),
        d("z", "y", "x", 1, -1, n, e, -t, o, i, 1),
        d("x", "z", "y", 1, 1, t, n, e, r, o, 2),
        d("x", "z", "y", 1, -1, t, n, -e, r, o, 3),
        d("x", "y", "z", 1, -1, t, e, n, r, i, 4),
        d("x", "y", "z", -1, -1, t, e, -n, r, i, 5),
        this.setIndex(s),
        this.addAttribute("position", new dr(c,3)),
        this.addAttribute("normal", new dr(h,3)),
        this.addAttribute("uv", new dr(l,2))
    }
    function br(t, e, n, r) {
        ir.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: r
        },
        this.fromBufferGeometry(new Mr(t,e,n,r)),
        this.mergeVertices()
    }
    function Mr(t, e, n, r) {
        yr.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: r
        };
        var i, o, a = (t = t || 1) / 2, s = (e = e || 1) / 2, c = Math.floor(n) || 1, h = Math.floor(r) || 1, l = c + 1, u = h + 1, p = t / c, d = e / h, f = [], m = [], g = [], v = [];
        for (o = 0; o < u; o++) {
            var y = o * d - s;
            for (i = 0; i < l; i++) {
                var x = i * p - a;
                m.push(x, -y, 0),
                g.push(0, 0, 1),
                v.push(i / c),
                v.push(1 - o / h)
            }
        }
        for (o = 0; o < h; o++)
            for (i = 0; i < c; i++) {
                var w = i + l * o
                  , b = i + l * (o + 1)
                  , M = i + 1 + l * (o + 1)
                  , _ = i + 1 + l * o;
                f.push(w, b, _),
                f.push(b, M, _)
            }
        this.setIndex(f),
        this.addAttribute("position", new dr(m,3)),
        this.addAttribute("normal", new dr(g,3)),
        this.addAttribute("uv", new dr(v,2))
    }
    function _r(t) {
        Gn.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new Un(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = $,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.lights = !1,
        this.setValues(t)
    }
    function Er(t) {
        Gn.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(t))
    }
    function Sr(t, e) {
        this.origin = void 0 !== t ? t : new Fe,
        this.direction = void 0 !== e ? e : new Fe
    }
    function Tr(t, e) {
        this.start = void 0 !== t ? t : new Fe,
        this.end = void 0 !== e ? e : new Fe
    }
    function Ar(t, e, n) {
        this.a = void 0 !== t ? t : new Fe,
        this.b = void 0 !== e ? e : new Fe,
        this.c = void 0 !== n ? n : new Fe
    }
    function Lr(t, e) {
        $n.call(this),
        this.type = "Mesh",
        this.geometry = void 0 !== t ? t : new yr,
        this.material = void 0 !== e ? e : new _r({
            color: 16777215 * Math.random()
        }),
        this.drawMode = Me,
        this.updateMorphTargets()
    }
    function Rr(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }
    function Pr(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }
    function Cr(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }
    function Ir(t, e, n) {
        var r = t.createShader(e);
        return t.shaderSource(r, n),
        t.compileShader(r),
        !1 === t.getShaderParameter(r, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."),
        "" !== t.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(r), function(t) {
            for (var e = t.split("\n"), n = 0; n < e.length; n++)
                e[n] = n + 1 + ": " + e[n];
            return e.join("\n")
        }(n)),
        r
    }
    yr.prototype = Object.assign(Object.create(r.prototype), {
        constructor: yr,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            Array.isArray(t) ? this.index = new (gr(t) > 65535 ? pr : lr)(t,1) : this.index = t
        },
        addAttribute: function(t, e) {
            return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            void this.setIndex(e)) : (this.attributes[t] = e,
            this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            void this.addAttribute(t, new or(arguments[1],arguments[2])))
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        removeAttribute: function(t) {
            return delete this.attributes[t],
            this
        },
        addGroup: function(t, e, n) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: void 0 !== n ? n : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t,
            this.drawRange.count = e
        },
        applyMatrix: function(t) {
            var e = this.attributes.position;
            void 0 !== e && (t.applyToBufferAttribute(e),
            e.needsUpdate = !0);
            var n = this.attributes.normal;
            return void 0 !== n && ((new ke).getNormalMatrix(t).applyToBufferAttribute(n),
            n.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationX(e),
                this.applyMatrix(t),
                this
            }
        }(),
        rotateY: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationY(e),
                this.applyMatrix(t),
                this
            }
        }(),
        rotateZ: function() {
            var t = new Be;
            return function(e) {
                return t.makeRotationZ(e),
                this.applyMatrix(t),
                this
            }
        }(),
        translate: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeTranslation(e, n, r),
                this.applyMatrix(t),
                this
            }
        }(),
        scale: function() {
            var t = new Be;
            return function(e, n, r) {
                return t.makeScale(e, n, r),
                this.applyMatrix(t),
                this
            }
        }(),
        lookAt: function() {
            var t = new $n;
            return function(e) {
                t.lookAt(e),
                t.updateMatrix(),
                this.applyMatrix(t.matrix)
            }
        }(),
        center: function() {
            this.computeBoundingBox();
            var t = this.boundingBox.getCenter().negate();
            return this.translate(t.x, t.y, t.z),
            t
        },
        setFromObject: function(t) {
            var e = t.geometry;
            if (t.isPoints || t.isLine) {
                var n = new dr(3 * e.vertices.length,3)
                  , r = new dr(3 * e.colors.length,3);
                if (this.addAttribute("position", n.copyVector3sArray(e.vertices)),
                this.addAttribute("color", r.copyColorsArray(e.colors)),
                e.lineDistances && e.lineDistances.length === e.vertices.length) {
                    var i = new dr(e.lineDistances.length,1);
                    this.addAttribute("lineDistance", i.copyArray(e.lineDistances))
                }
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else
                t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        setFromPoints: function(t) {
            for (var e = [], n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                e.push(i.x, i.y, i.z || 0)
            }
            return this.addAttribute("position", new dr(e,3)),
            this
        },
        updateFromObject: function(t) {
            var e, n = t.geometry;
            if (t.isMesh) {
                var r = n.__directGeometry;
                if (!0 === n.elementsNeedUpdate && (r = void 0,
                n.elementsNeedUpdate = !1),
                void 0 === r)
                    return this.fromGeometry(n);
                r.verticesNeedUpdate = n.verticesNeedUpdate,
                r.normalsNeedUpdate = n.normalsNeedUpdate,
                r.colorsNeedUpdate = n.colorsNeedUpdate,
                r.uvsNeedUpdate = n.uvsNeedUpdate,
                r.groupsNeedUpdate = n.groupsNeedUpdate,
                n.verticesNeedUpdate = !1,
                n.normalsNeedUpdate = !1,
                n.colorsNeedUpdate = !1,
                n.uvsNeedUpdate = !1,
                n.groupsNeedUpdate = !1,
                n = r
            }
            return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices),
            e.needsUpdate = !0),
            n.verticesNeedUpdate = !1),
            !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals),
            e.needsUpdate = !0),
            n.normalsNeedUpdate = !1),
            !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors),
            e.needsUpdate = !0),
            n.colorsNeedUpdate = !1),
            n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs),
            e.needsUpdate = !0),
            n.uvsNeedUpdate = !1),
            n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances),
            e.needsUpdate = !0),
            n.lineDistancesNeedUpdate = !1),
            n.groupsNeedUpdate && (n.computeGroups(t.geometry),
            this.groups = n.groups,
            n.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new mr).fromGeometry(t),
            this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            var e = new Float32Array(3 * t.vertices.length);
            if (this.addAttribute("position", new or(e,3).copyVector3sArray(t.vertices)),
            t.normals.length > 0) {
                var n = new Float32Array(3 * t.normals.length);
                this.addAttribute("normal", new or(n,3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
                var r = new Float32Array(3 * t.colors.length);
                this.addAttribute("color", new or(r,3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
                var i = new Float32Array(2 * t.uvs.length);
                this.addAttribute("uv", new or(i,2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
                var o = new Float32Array(2 * t.uvs2.length);
                this.addAttribute("uv2", new or(o,2).copyVector2sArray(t.uvs2))
            }
            if (t.indices.length > 0) {
                var a = new (gr(t.indices) > 65535 ? Uint32Array : Uint16Array)(3 * t.indices.length);
                this.setIndex(new or(a,1).copyIndicesArray(t.indices))
            }
            for (var s in this.groups = t.groups,
            t.morphTargets) {
                for (var c = [], h = t.morphTargets[s], l = 0, u = h.length; l < u; l++) {
                    var p = h[l]
                      , d = new dr(3 * p.length,3);
                    c.push(d.copyVector3sArray(p))
                }
                this.morphAttributes[s] = c
            }
            if (t.skinIndices.length > 0) {
                var f = new dr(4 * t.skinIndices.length,4);
                this.addAttribute("skinIndex", f.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
                var m = new dr(4 * t.skinWeights.length,4);
                this.addAttribute("skinWeight", m.copyVector4sArray(t.skinWeights))
            }
            return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Wn);
            var t = this.attributes.position;
            void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(),
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            var t = new Wn
              , e = new Fe;
            return function() {
                null === this.boundingSphere && (this.boundingSphere = new Yn);
                var n = this.attributes.position;
                if (n) {
                    var r = this.boundingSphere.center;
                    t.setFromBufferAttribute(n),
                    t.getCenter(r);
                    for (var i = 0, o = 0, a = n.count; o < a; o++)
                        e.x = n.getX(o),
                        e.y = n.getY(o),
                        e.z = n.getZ(o),
                        i = Math.max(i, r.distanceToSquared(e));
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var t = this.index
              , e = this.attributes
              , n = this.groups;
            if (e.position) {
                var r = e.position.array;
                if (void 0 === e.normal)
                    this.addAttribute("normal", new or(new Float32Array(r.length),3));
                else
                    for (var i = e.normal.array, o = 0, a = i.length; o < a; o++)
                        i[o] = 0;
                var s, c, h, l = e.normal.array, u = new Fe, p = new Fe, d = new Fe, f = new Fe, m = new Fe;
                if (t) {
                    var g = t.array;
                    0 === n.length && this.addGroup(0, g.length);
                    for (var v = 0, y = n.length; v < y; ++v) {
                        var x = n[v]
                          , w = x.start;
                        for (o = w,
                        a = w + x.count; o < a; o += 3)
                            s = 3 * g[o + 0],
                            c = 3 * g[o + 1],
                            h = 3 * g[o + 2],
                            u.fromArray(r, s),
                            p.fromArray(r, c),
                            d.fromArray(r, h),
                            f.subVectors(d, p),
                            m.subVectors(u, p),
                            f.cross(m),
                            l[s] += f.x,
                            l[s + 1] += f.y,
                            l[s + 2] += f.z,
                            l[c] += f.x,
                            l[c + 1] += f.y,
                            l[c + 2] += f.z,
                            l[h] += f.x,
                            l[h + 1] += f.y,
                            l[h + 2] += f.z
                    }
                } else
                    for (o = 0,
                    a = r.length; o < a; o += 9)
                        u.fromArray(r, o),
                        p.fromArray(r, o + 3),
                        d.fromArray(r, o + 6),
                        f.subVectors(d, p),
                        m.subVectors(u, p),
                        f.cross(m),
                        l[o] = f.x,
                        l[o + 1] = f.y,
                        l[o + 2] = f.z,
                        l[o + 3] = f.x,
                        l[o + 4] = f.y,
                        l[o + 5] = f.z,
                        l[o + 6] = f.x,
                        l[o + 7] = f.y,
                        l[o + 8] = f.z;
                this.normalizeNormals(),
                e.normal.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0);
                var n = this.attributes;
                for (var r in n)
                    if (void 0 !== t.attributes[r])
                        for (var i = n[r].array, o = t.attributes[r], a = o.array, s = 0, c = o.itemSize * e; s < a.length; s++,
                        c++)
                            i[c] = a[s];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
        },
        normalizeNormals: function() {
            var t = new Fe;
            return function() {
                for (var e = this.attributes.normal, n = 0, r = e.count; n < r; n++)
                    t.x = e.getX(n),
                    t.y = e.getY(n),
                    t.z = e.getZ(n),
                    t.normalize(),
                    e.setXYZ(n, t.x, t.y, t.z)
            }
        }(),
        toNonIndexed: function() {
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
            var t = new yr
              , e = this.index.array
              , n = this.attributes;
            for (var r in n) {
                for (var i = n[r], o = i.array, a = i.itemSize, s = new o.constructor(e.length * a), c = 0, h = 0, l = 0, u = e.length; l < u; l++) {
                    c = e[l] * a;
                    for (var p = 0; p < a; p++)
                        s[h++] = o[c++]
                }
                t.addAttribute(r, new or(s,a))
            }
            return t
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            "" !== this.name && (t.name = this.name),
            void 0 !== this.parameters) {
                var e = this.parameters;
                for (var n in e)
                    void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            t.data = {
                attributes: {}
            };
            var r = this.index;
            if (null !== r) {
                var i = Array.prototype.slice.call(r.array);
                t.data.index = {
                    type: r.array.constructor.name,
                    array: i
                }
            }
            var o = this.attributes;
            for (var n in o) {
                var a = o[n];
                i = Array.prototype.slice.call(a.array),
                t.data.attributes[n] = {
                    itemSize: a.itemSize,
                    type: a.array.constructor.name,
                    array: i,
                    normalized: a.normalized
                }
            }
            var s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            var c = this.boundingSphere;
            return null !== c && (t.data.boundingSphere = {
                center: c.center.toArray(),
                radius: c.radius
            }),
            t
        },
        clone: function() {
            return (new yr).copy(this)
        },
        copy: function(t) {
            var e, n, r;
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = t.name;
            var i = t.index;
            null !== i && this.setIndex(i.clone());
            var o = t.attributes;
            for (e in o) {
                var a = o[e];
                this.addAttribute(e, a.clone())
            }
            var s = t.morphAttributes;
            for (e in s) {
                var c = []
                  , h = s[e];
                for (n = 0,
                r = h.length; n < r; n++)
                    c.push(h[n].clone());
                this.morphAttributes[e] = c
            }
            var l = t.groups;
            for (n = 0,
            r = l.length; n < r; n++) {
                var u = l[n];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            var p = t.boundingBox;
            null !== p && (this.boundingBox = p.clone());
            var d = t.boundingSphere;
            return null !== d && (this.boundingSphere = d.clone()),
            this.drawRange.start = t.drawRange.start,
            this.drawRange.count = t.drawRange.count,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    xr.prototype = Object.create(ir.prototype),
    xr.prototype.constructor = xr,
    wr.prototype = Object.create(yr.prototype),
    wr.prototype.constructor = wr,
    br.prototype = Object.create(ir.prototype),
    br.prototype.constructor = br,
    Mr.prototype = Object.create(yr.prototype),
    Mr.prototype.constructor = Mr,
    _r.prototype = Object.create(Gn.prototype),
    _r.prototype.constructor = _r,
    _r.prototype.isMeshBasicMaterial = !0,
    _r.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this
    }
    ,
    Er.prototype = Object.create(Gn.prototype),
    Er.prototype.constructor = Er,
    Er.prototype.isShaderMaterial = !0,
    Er.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.fragmentShader = t.fragmentShader,
        this.vertexShader = t.vertexShader,
        this.uniforms = Bn.clone(t.uniforms),
        this.defines = t.defines,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.lights = t.lights,
        this.clipping = t.clipping,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this.extensions = t.extensions,
        this
    }
    ,
    Er.prototype.toJSON = function(t) {
        var e = Gn.prototype.toJSON.call(this, t);
        return e.uniforms = this.uniforms,
        e.vertexShader = this.vertexShader,
        e.fragmentShader = this.fragmentShader,
        e
    }
    ,
    Object.assign(Sr.prototype, {
        set: function(t, e) {
            return this.origin.copy(t),
            this.direction.copy(e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.origin.copy(t.origin),
            this.direction.copy(t.direction),
            this
        },
        at: function(t, e) {
            return (e || new Fe).copy(this.direction).multiplyScalar(t).add(this.origin)
        },
        lookAt: function(t) {
            return this.direction.copy(t).sub(this.origin).normalize(),
            this
        },
        recast: function() {
            var t = new Fe;
            return function(e) {
                return this.origin.copy(this.at(e, t)),
                this
            }
        }(),
        closestPointToPoint: function(t, e) {
            var n = e || new Fe;
            n.subVectors(t, this.origin);
            var r = n.dot(this.direction);
            return r < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin)
        },
        distanceToPoint: function(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        },
        distanceSqToPoint: function() {
            var t = new Fe;
            return function(e) {
                var n = t.subVectors(e, this.origin).dot(this.direction);
                return n < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin),
                t.distanceToSquared(e))
            }
        }(),
        distanceSqToSegment: function() {
            var t = new Fe
              , e = new Fe
              , n = new Fe;
            return function(r, i, o, a) {
                t.copy(r).add(i).multiplyScalar(.5),
                e.copy(i).sub(r).normalize(),
                n.copy(this.origin).sub(t);
                var s, c, h, l, u = .5 * r.distanceTo(i), p = -this.direction.dot(e), d = n.dot(this.direction), f = -n.dot(e), m = n.lengthSq(), g = Math.abs(1 - p * p);
                if (g > 0)
                    if (c = p * d - f,
                    l = u * g,
                    (s = p * f - d) >= 0)
                        if (c >= -l)
                            if (c <= l) {
                                var v = 1 / g;
                                h = (s *= v) * (s + p * (c *= v) + 2 * d) + c * (p * s + c + 2 * f) + m
                            } else
                                c = u,
                                h = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m;
                        else
                            c = -u,
                            h = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m;
                    else
                        c <= -l ? h = -(s = Math.max(0, -(-p * u + d))) * s + (c = s > 0 ? -u : Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m : c <= l ? (s = 0,
                        h = (c = Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m) : h = -(s = Math.max(0, -(p * u + d))) * s + (c = s > 0 ? u : Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m;
                else
                    c = p > 0 ? -u : u,
                    h = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m;
                return o && o.copy(this.direction).multiplyScalar(s).add(this.origin),
                a && a.copy(e).multiplyScalar(c).add(t),
                h
            }
        }(),
        intersectSphere: function() {
            var t = new Fe;
            return function(e, n) {
                t.subVectors(e.center, this.origin);
                var r = t.dot(this.direction)
                  , i = t.dot(t) - r * r
                  , o = e.radius * e.radius;
                if (i > o)
                    return null;
                var a = Math.sqrt(o - i)
                  , s = r - a
                  , c = r + a;
                return s < 0 && c < 0 ? null : s < 0 ? this.at(c, n) : this.at(s, n)
            }
        }(),
        intersectsSphere: function(t) {
            return this.distanceToPoint(t.center) <= t.radius
        },
        distanceToPlane: function(t) {
            var e = t.normal.dot(this.direction);
            if (0 === e)
                return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            var n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null
        },
        intersectPlane: function(t, e) {
            var n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        },
        intersectsPlane: function(t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0
        },
        intersectBox: function(t, e) {
            var n, r, i, o, a, s, c = 1 / this.direction.x, h = 1 / this.direction.y, l = 1 / this.direction.z, u = this.origin;
            return c >= 0 ? (n = (t.min.x - u.x) * c,
            r = (t.max.x - u.x) * c) : (n = (t.max.x - u.x) * c,
            r = (t.min.x - u.x) * c),
            h >= 0 ? (i = (t.min.y - u.y) * h,
            o = (t.max.y - u.y) * h) : (i = (t.max.y - u.y) * h,
            o = (t.min.y - u.y) * h),
            n > o || i > r ? null : ((i > n || n != n) && (n = i),
            (o < r || r != r) && (r = o),
            l >= 0 ? (a = (t.min.z - u.z) * l,
            s = (t.max.z - u.z) * l) : (a = (t.max.z - u.z) * l,
            s = (t.min.z - u.z) * l),
            n > s || a > r ? null : ((a > n || n != n) && (n = a),
            (s < r || r != r) && (r = s),
            r < 0 ? null : this.at(n >= 0 ? n : r, e)))
        },
        intersectsBox: function() {
            var t = new Fe;
            return function(e) {
                return null !== this.intersectBox(e, t)
            }
        }(),
        intersectTriangle: function() {
            var t = new Fe
              , e = new Fe
              , n = new Fe
              , r = new Fe;
            return function(i, o, a, s, c) {
                e.subVectors(o, i),
                n.subVectors(a, i),
                r.crossVectors(e, n);
                var h, l = this.direction.dot(r);
                if (l > 0) {
                    if (s)
                        return null;
                    h = 1
                } else {
                    if (!(l < 0))
                        return null;
                    h = -1,
                    l = -l
                }
                t.subVectors(this.origin, i);
                var u = h * this.direction.dot(n.crossVectors(t, n));
                if (u < 0)
                    return null;
                var p = h * this.direction.dot(e.cross(t));
                if (p < 0)
                    return null;
                if (u + p > l)
                    return null;
                var d = -h * t.dot(r);
                return d < 0 ? null : this.at(d / l, c)
            }
        }(),
        applyMatrix4: function(t) {
            return this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
        },
        equals: function(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    }),
    Object.assign(Tr.prototype, {
        set: function(t, e) {
            return this.start.copy(t),
            this.end.copy(e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.start.copy(t.start),
            this.end.copy(t.end),
            this
        },
        getCenter: function(t) {
            return (t || new Fe).addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            return (t || new Fe).subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            var n = e || new Fe;
            return this.delta(n).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: function() {
            var t = new Fe
              , e = new Fe;
            return function(n, r) {
                t.subVectors(n, this.start),
                e.subVectors(this.end, this.start);
                var i = e.dot(e)
                  , o = e.dot(t) / i;
                return r && (o = Ue.clamp(o, 0, 1)),
                o
            }
        }(),
        closestPointToPoint: function(t, e, n) {
            var r = this.closestPointToPointParameter(t, e)
              , i = n || new Fe;
            return this.delta(i).multiplyScalar(r).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t),
            this.end.applyMatrix4(t),
            this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }),
    Object.assign(Ar, {
        normal: function() {
            var t = new Fe;
            return function(e, n, r, i) {
                var o = i || new Fe;
                o.subVectors(r, n),
                t.subVectors(e, n),
                o.cross(t);
                var a = o.lengthSq();
                return a > 0 ? o.multiplyScalar(1 / Math.sqrt(a)) : o.set(0, 0, 0)
            }
        }(),
        barycoordFromPoint: function() {
            var t = new Fe
              , e = new Fe
              , n = new Fe;
            return function(r, i, o, a, s) {
                t.subVectors(a, i),
                e.subVectors(o, i),
                n.subVectors(r, i);
                var c = t.dot(t)
                  , h = t.dot(e)
                  , l = t.dot(n)
                  , u = e.dot(e)
                  , p = e.dot(n)
                  , d = c * u - h * h
                  , f = s || new Fe;
                if (0 === d)
                    return f.set(-2, -1, -1);
                var m = 1 / d
                  , g = (u * l - h * p) * m
                  , v = (c * p - h * l) * m;
                return f.set(1 - g - v, v, g)
            }
        }(),
        containsPoint: function() {
            var t = new Fe;
            return function(e, n, r, i) {
                var o = Ar.barycoordFromPoint(e, n, r, i, t);
                return o.x >= 0 && o.y >= 0 && o.x + o.y <= 1
            }
        }()
    }),
    Object.assign(Ar.prototype, {
        set: function(t, e, n) {
            return this.a.copy(t),
            this.b.copy(e),
            this.c.copy(n),
            this
        },
        setFromPointsAndIndices: function(t, e, n, r) {
            return this.a.copy(t[e]),
            this.b.copy(t[n]),
            this.c.copy(t[r]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.a.copy(t.a),
            this.b.copy(t.b),
            this.c.copy(t.c),
            this
        },
        area: function() {
            var t = new Fe
              , e = new Fe;
            return function() {
                return t.subVectors(this.c, this.b),
                e.subVectors(this.a, this.b),
                .5 * t.cross(e).length()
            }
        }(),
        midpoint: function(t) {
            return (t || new Fe).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        normal: function(t) {
            return Ar.normal(this.a, this.b, this.c, t)
        },
        plane: function(t) {
            return (t || new Xn).setFromCoplanarPoints(this.a, this.b, this.c)
        },
        barycoordFromPoint: function(t, e) {
            return Ar.barycoordFromPoint(t, this.a, this.b, this.c, e)
        },
        containsPoint: function(t) {
            return Ar.containsPoint(t, this.a, this.b, this.c)
        },
        intersectsBox: function(t) {
            return t.intersectsTriangle(this)
        },
        closestPointToPoint: function() {
            var t = new Xn
              , e = [new Tr, new Tr, new Tr]
              , n = new Fe
              , r = new Fe;
            return function(i, o) {
                var a = o || new Fe
                  , s = 1 / 0;
                if (t.setFromCoplanarPoints(this.a, this.b, this.c),
                t.projectPoint(i, n),
                !0 === this.containsPoint(n))
                    a.copy(n);
                else {
                    e[0].set(this.a, this.b),
                    e[1].set(this.b, this.c),
                    e[2].set(this.c, this.a);
                    for (var c = 0; c < e.length; c++) {
                        e[c].closestPointToPoint(n, !0, r);
                        var h = n.distanceToSquared(r);
                        h < s && (s = h,
                        a.copy(r))
                    }
                }
                return a
            }
        }(),
        equals: function(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }),
    Lr.prototype = Object.assign(Object.create($n.prototype), {
        constructor: Lr,
        isMesh: !0,
        setDrawMode: function(t) {
            this.drawMode = t
        },
        copy: function(t) {
            return $n.prototype.copy.call(this, t),
            this.drawMode = t.drawMode,
            void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            var t, e, n, r = this.geometry;
            if (r.isBufferGeometry) {
                var i = r.morphAttributes
                  , o = Object.keys(i);
                if (o.length > 0) {
                    var a = i[o[0]];
                    if (void 0 !== a)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        t = 0,
                        e = a.length; t < e; t++)
                            n = a[t].name || String(t),
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = t
                }
            } else {
                var s = r.morphTargets;
                if (void 0 !== s && s.length > 0)
                    for (this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {},
                    t = 0,
                    e = s.length; t < e; t++)
                        n = s[t].name || String(t),
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[n] = t
            }
        },
        raycast: function() {
            var t = new Be
              , e = new Sr
              , n = new Yn
              , r = new Fe
              , i = new Fe
              , o = new Fe
              , a = new Fe
              , s = new Fe
              , c = new Fe
              , h = new Ne
              , l = new Ne
              , u = new Ne
              , p = new Fe
              , d = new Fe
              , f = new Fe;
            function m(t, e, n, r, i, o, a) {
                return Ar.barycoordFromPoint(t, e, n, r, p),
                i.multiplyScalar(p.x),
                o.multiplyScalar(p.y),
                a.multiplyScalar(p.z),
                i.add(o).add(a),
                i.clone()
            }
            function y(t, e, n, r, i, o, a, s) {
                if (null === (e.side === g ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, e.side !== v, s)))
                    return null;
                f.copy(s),
                f.applyMatrix4(t.matrixWorld);
                var c = n.ray.origin.distanceTo(f);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: f.clone(),
                    object: t
                }
            }
            function x(t, e, n, a, s, c, p, f) {
                r.fromBufferAttribute(a, c),
                i.fromBufferAttribute(a, p),
                o.fromBufferAttribute(a, f);
                var g = y(t, t.material, e, n, r, i, o, d);
                return g && (s && (h.fromBufferAttribute(s, c),
                l.fromBufferAttribute(s, p),
                u.fromBufferAttribute(s, f),
                g.uv = m(d, r, i, o, h, l, u)),
                g.face = new nr(c,p,f,Ar.normal(r, i, o)),
                g.faceIndex = c),
                g
            }
            return function(p, f) {
                var g, v = this.geometry, w = this.material, b = this.matrixWorld;
                if (void 0 !== w && (null === v.boundingSphere && v.computeBoundingSphere(),
                n.copy(v.boundingSphere),
                n.applyMatrix4(b),
                !1 !== p.ray.intersectsSphere(n) && (t.getInverse(b),
                e.copy(p.ray).applyMatrix4(t),
                null === v.boundingBox || !1 !== e.intersectsBox(v.boundingBox))))
                    if (v.isBufferGeometry) {
                        var M, _, E, S, T, A = v.index, L = v.attributes.position, R = v.attributes.uv;
                        if (null !== A)
                            for (S = 0,
                            T = A.count; S < T; S += 3)
                                M = A.getX(S),
                                _ = A.getX(S + 1),
                                E = A.getX(S + 2),
                                (g = x(this, p, e, L, R, M, _, E)) && (g.faceIndex = Math.floor(S / 3),
                                f.push(g));
                        else if (void 0 !== L)
                            for (S = 0,
                            T = L.count; S < T; S += 3)
                                (g = x(this, p, e, L, R, M = S, _ = S + 1, E = S + 2)) && (g.index = M,
                                f.push(g))
                    } else if (v.isGeometry) {
                        var P, C, I, O, D = Array.isArray(w), U = v.vertices, N = v.faces, B = v.faceVertexUvs[0];
                        B.length > 0 && (O = B);
                        for (var z = 0, F = N.length; z < F; z++) {
                            var k = N[z]
                              , H = D ? w[k.materialIndex] : w;
                            if (void 0 !== H) {
                                if (P = U[k.a],
                                C = U[k.b],
                                I = U[k.c],
                                !0 === H.morphTargets) {
                                    var G = v.morphTargets
                                      , V = this.morphTargetInfluences;
                                    r.set(0, 0, 0),
                                    i.set(0, 0, 0),
                                    o.set(0, 0, 0);
                                    for (var j = 0, W = G.length; j < W; j++) {
                                        var Y = V[j];
                                        if (0 !== Y) {
                                            var X = G[j].vertices;
                                            r.addScaledVector(a.subVectors(X[k.a], P), Y),
                                            i.addScaledVector(s.subVectors(X[k.b], C), Y),
                                            o.addScaledVector(c.subVectors(X[k.c], I), Y)
                                        }
                                    }
                                    r.add(P),
                                    i.add(C),
                                    o.add(I),
                                    P = r,
                                    C = i,
                                    I = o
                                }
                                if (g = y(this, H, p, e, P, C, I, d)) {
                                    if (O && O[z]) {
                                        var q = O[z];
                                        h.copy(q[0]),
                                        l.copy(q[1]),
                                        u.copy(q[2]),
                                        g.uv = m(d, P, C, I, h, l, u)
                                    }
                                    g.face = k,
                                    g.faceIndex = z,
                                    f.push(g)
                                }
                            }
                        }
                    }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    });
    var Or = 0;
    function Dr(t) {
        switch (t) {
        case Se:
            return ["Linear", "( value )"];
        case Te:
            return ["sRGB", "( value )"];
        case Le:
            return ["RGBE", "( value )"];
        case Pe:
            return ["RGBM", "( value, 7.0 )"];
        case Ce:
            return ["RGBM", "( value, 16.0 )"];
        case Ie:
            return ["RGBD", "( value, 256.0 )"];
        case Ae:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw new Error("unsupported encoding: " + t)
        }
    }
    function Ur(t, e) {
        var n = Dr(e);
        return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }
    function Nr(t) {
        return "" !== t
    }
    function Br(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    }
    function zr(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    function Fr(t) {
        return t.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function(t, e) {
            var n = zn[e];
            if (void 0 === n)
                throw new Error("Can not resolve #include <" + e + ">");
            return Fr(n)
        })
    }
    function kr(t) {
        return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, n, r) {
            for (var i = "", o = parseInt(e); o < parseInt(n); o++)
                i += r.replace(/\[ i \]/g, "[ " + o + " ]");
            return i
        })
    }
    function Hr(t, e, n) {
        var r = []
          , i = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow"
        }
          , o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
        function a(t, e) {
            var n;
            return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            n = t.texture.encoding) : n = Se,
            n === Se && e && (n = Ae),
            n
        }
        this.getParameters = function(e, r, o, s, c, h, l) {
            var u = i[e.type]
              , p = l.isSkinnedMesh ? function(t) {
                var e = l.skeleton.bones;
                if (n.floatVertexTextures)
                    return 1024;
                var r = n.maxVertexUniforms
                  , i = Math.floor((r - 20) / 4)
                  , o = Math.min(i, e.length);
                return o < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + o + "."),
                0) : o
            }() : 0
              , d = n.precision;
            null !== e.precision && (d = n.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", d, "instead.");
            var f = t.getRenderTarget();
            return {
                shaderID: u,
                precision: d,
                supportsVertexTextures: n.vertexTextures,
                outputEncoding: a(f ? f.texture : null, t.gammaOutput),
                map: !!e.map,
                mapEncoding: a(e.map, t.gammaInput),
                envMap: !!e.envMap,
                envMapMode: e.envMap && e.envMap.mapping,
                envMapEncoding: a(e.envMap, t.gammaInput),
                envMapCubeUV: !!e.envMap && (e.envMap.mapping === dt || e.envMap.mapping === ft),
                lightMap: !!e.lightMap,
                aoMap: !!e.aoMap,
                emissiveMap: !!e.emissiveMap,
                emissiveMapEncoding: a(e.emissiveMap, t.gammaInput),
                bumpMap: !!e.bumpMap,
                normalMap: !!e.normalMap,
                displacementMap: !!e.displacementMap,
                roughnessMap: !!e.roughnessMap,
                metalnessMap: !!e.metalnessMap,
                specularMap: !!e.specularMap,
                alphaMap: !!e.alphaMap,
                gradientMap: !!e.gradientMap,
                combine: e.combine,
                vertexColors: e.vertexColors,
                fog: !!s,
                useFog: e.fog,
                fogExp: s && s.isFogExp2,
                flatShading: e.flatShading,
                sizeAttenuation: e.sizeAttenuation,
                logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                skinning: e.skinning && p > 0,
                maxBones: p,
                useVertexTexture: n.floatVertexTextures,
                morphTargets: e.morphTargets,
                morphNormals: e.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                numDirLights: r.directional.length,
                numPointLights: r.point.length,
                numSpotLights: r.spot.length,
                numRectAreaLights: r.rectArea.length,
                numHemiLights: r.hemi.length,
                numClippingPlanes: c,
                numClipIntersection: h,
                dithering: e.dithering,
                shadowMapEnabled: t.shadowMap.enabled && l.receiveShadow && o.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: t.toneMapping,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: e.premultipliedAlpha,
                alphaTest: e.alphaTest,
                doubleSided: e.side === v,
                flipSided: e.side === g,
                depthPacking: void 0 !== e.depthPacking && e.depthPacking
            }
        }
        ,
        this.getProgramCode = function(e, n) {
            var r = [];
            if (n.shaderID ? r.push(n.shaderID) : (r.push(e.fragmentShader),
            r.push(e.vertexShader)),
            void 0 !== e.defines)
                for (var i in e.defines)
                    r.push(i),
                    r.push(e.defines[i]);
            for (var a = 0; a < o.length; a++)
                r.push(n[o[a]]);
            return r.push(e.onBeforeCompile.toString()),
            r.push(t.gammaOutput),
            r.join()
        }
        ,
        this.acquireProgram = function(n, i, o, a) {
            for (var s, c = 0, h = r.length; c < h; c++) {
                var l = r[c];
                if (l.code === a) {
                    ++(s = l).usedTimes;
                    break
                }
            }
            return void 0 === s && (s = new function(t, e, n, r, i, o) {
                var a = t.context
                  , s = r.defines
                  , c = i.vertexShader
                  , h = i.fragmentShader
                  , l = "SHADOWMAP_TYPE_BASIC";
                o.shadowMapType === d ? l = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === f && (l = "SHADOWMAP_TYPE_PCF_SOFT");
                var u = "ENVMAP_TYPE_CUBE"
                  , p = "ENVMAP_MODE_REFLECTION"
                  , m = "ENVMAP_BLENDING_MULTIPLY";
                if (o.envMap) {
                    switch (r.envMap.mapping) {
                    case ct:
                    case ht:
                        u = "ENVMAP_TYPE_CUBE";
                        break;
                    case dt:
                    case ft:
                        u = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case lt:
                    case ut:
                        u = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case pt:
                        u = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (r.envMap.mapping) {
                    case ht:
                    case ut:
                        p = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (r.combine) {
                    case $:
                        m = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case tt:
                        m = "ENVMAP_BLENDING_MIX";
                        break;
                    case et:
                        m = "ENVMAP_BLENDING_ADD"
                    }
                }
                var g, v, y = t.gammaFactor > 0 ? t.gammaFactor : 1, x = function(t, e, n) {
                    return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Nr).join("\n")
                }(r.extensions, o, e), w = function(t) {
                    var e = [];
                    for (var n in t) {
                        var r = t[n];
                        !1 !== r && e.push("#define " + n + " " + r)
                    }
                    return e.join("\n")
                }(s), b = a.createProgram();
                r.isRawShaderMaterial ? ((g = [w].filter(Nr).join("\n")).length > 0 && (g += "\n"),
                (v = [x, w].filter(Nr).join("\n")).length > 0 && (v += "\n")) : (g = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + l : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Nr).join("\n"),
                v = [x, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.alphaTest ? "#define ALPHATEST " + o.alphaTest : "", "#define GAMMA_FACTOR " + y, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + u : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + l : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && e.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && e.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== nt ? "#define TONE_MAPPING" : "", o.toneMapping !== nt ? zn.tonemapping_pars_fragment : "", o.toneMapping !== nt ? function(t, e) {
                    var n;
                    switch (e) {
                    case rt:
                        n = "Linear";
                        break;
                    case it:
                        n = "Reinhard";
                        break;
                    case ot:
                        n = "Uncharted2";
                        break;
                    case at:
                        n = "OptimizedCineon";
                        break;
                    default:
                        throw new Error("unsupported toneMapping: " + e)
                    }
                    return "vec3 toneMapping( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }(0, o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? zn.encodings_pars_fragment : "", o.mapEncoding ? Ur("mapTexelToLinear", o.mapEncoding) : "", o.envMapEncoding ? Ur("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Ur("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? function(t, e) {
                    var n = Dr(o.outputEncoding);
                    return "vec4 linearToOutputTexel( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                }() : "", o.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(Nr).join("\n")),
                c = zr(c = Br(c = Fr(c), o), o),
                h = zr(h = Br(h = Fr(h), o), o);
                var M = g + (c = kr(c))
                  , _ = v + (h = kr(h))
                  , E = Ir(a, a.VERTEX_SHADER, M)
                  , S = Ir(a, a.FRAGMENT_SHADER, _);
                a.attachShader(b, E),
                a.attachShader(b, S),
                void 0 !== r.index0AttributeName ? a.bindAttribLocation(b, 0, r.index0AttributeName) : !0 === o.morphTargets && a.bindAttribLocation(b, 0, "position"),
                a.linkProgram(b);
                var T, A, L = a.getProgramInfoLog(b).trim(), R = a.getShaderInfoLog(E).trim(), P = a.getShaderInfoLog(S).trim(), C = !0, I = !0;
                return !1 === a.getProgramParameter(b, a.LINK_STATUS) ? (C = !1,
                console.error("THREE.WebGLProgram: shader error: ", a.getError(), "gl.VALIDATE_STATUS", a.getProgramParameter(b, a.VALIDATE_STATUS), "gl.getProgramInfoLog", L, R, P)) : "" !== L ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", L) : "" !== R && "" !== P || (I = !1),
                I && (this.diagnostics = {
                    runnable: C,
                    material: r,
                    programLog: L,
                    vertexShader: {
                        log: R,
                        prefix: g
                    },
                    fragmentShader: {
                        log: P,
                        prefix: v
                    }
                }),
                a.deleteShader(E),
                a.deleteShader(S),
                this.getUniforms = function() {
                    return void 0 === T && (T = new On(a,b,t)),
                    T
                }
                ,
                this.getAttributes = function() {
                    return void 0 === A && (A = function(t, e) {
                        for (var n = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) {
                            var o = t.getActiveAttrib(e, i).name;
                            n[o] = t.getAttribLocation(e, o)
                        }
                        return n
                    }(a, b)),
                    A
                }
                ,
                this.destroy = function() {
                    a.deleteProgram(b),
                    this.program = void 0
                }
                ,
                Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                            this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                            this.getAttributes()
                        }
                    }
                }),
                this.id = Or++,
                this.code = n,
                this.usedTimes = 1,
                this.program = b,
                this.vertexShader = E,
                this.fragmentShader = S,
                this
            }
            (t,e,a,n,i,o),
            r.push(s)),
            s
        }
        ,
        this.releaseProgram = function(t) {
            if (0 == --t.usedTimes) {
                var e = r.indexOf(t);
                r[e] = r[r.length - 1],
                r.pop(),
                t.destroy()
            }
        }
        ,
        this.programs = r
    }
    function Gr(t, e, n, r, i, o, a, s) {
        var c, h = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext, l = {};
        function u(t, e) {
            if (t.width > e || t.height > e) {
                var n = e / Math.max(t.width, t.height)
                  , r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return r.width = Math.floor(t.width * n),
                r.height = Math.floor(t.height * n),
                r.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, r.width, r.height),
                console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + r.width + "x" + r.height, t),
                r
            }
            return t
        }
        function p(t) {
            return Ue.isPowerOfTwo(t.width) && Ue.isPowerOfTwo(t.height)
        }
        function d(t, e) {
            return t.generateMipmaps && e && t.minFilter !== yt && t.minFilter !== bt
        }
        function f(e) {
            return e === yt || e === xt || e === wt ? t.NEAREST : t.LINEAR
        }
        function m(e) {
            var n = e.target;
            n.removeEventListener("dispose", m),
            function(e) {
                var n = r.get(e);
                if (e.image && n.__image__webglTextureCube)
                    t.deleteTexture(n.__image__webglTextureCube);
                else {
                    if (void 0 === n.__webglInit)
                        return;
                    t.deleteTexture(n.__webglTexture)
                }
                r.remove(e)
            }(n),
            n.isVideoTexture && delete l[n.id],
            a.textures--
        }
        function g(e) {
            var n = e.target;
            n.removeEventListener("dispose", g),
            function(e) {
                var n = r.get(e)
                  , i = r.get(e.texture);
                if (e) {
                    if (void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture),
                    e.depthTexture && e.depthTexture.dispose(),
                    e.isWebGLRenderTargetCube)
                        for (var o = 0; o < 6; o++)
                            t.deleteFramebuffer(n.__webglFramebuffer[o]),
                            n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                    else
                        t.deleteFramebuffer(n.__webglFramebuffer),
                        n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                    r.remove(e.texture),
                    r.remove(e)
                }
            }(n),
            a.textures--
        }
        function v(e, f) {
            var g = r.get(e);
            if (e.isVideoTexture && function(t) {
                var e = t.id
                  , n = s.frame;
                l[e] !== n && (l[e] = n,
                t.update())
            }(e),
            e.version > 0 && g.__version !== e.version) {
                var v = e.image;
                if (void 0 === v)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
                else {
                    if (!1 !== v.complete)
                        return void function(e, r, s) {
                            void 0 === e.__webglInit && (e.__webglInit = !0,
                            r.addEventListener("dispose", m),
                            e.__webglTexture = t.createTexture(),
                            a.textures++),
                            n.activeTexture(t.TEXTURE0 + s),
                            n.bindTexture(t.TEXTURE_2D, e.__webglTexture),
                            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
                            t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment);
                            var l = u(r.image, i.maxTextureSize);
                            (function(t) {
                                return t.wrapS !== gt || t.wrapT !== gt || t.minFilter !== yt && t.minFilter !== bt
                            }
                            )(r) && !1 === p(l) && (l = function(t) {
                                return t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap ? (void 0 === c && (c = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                                c.width = Ue.floorPowerOfTwo(t.width),
                                c.height = Ue.floorPowerOfTwo(t.height),
                                c.getContext("2d").drawImage(t, 0, 0, c.width, c.height),
                                console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + c.width + "x" + c.height, t),
                                c) : t
                            }(l));
                            var f = p(l)
                              , g = o.convert(r.format)
                              , v = o.convert(r.type);
                            y(t.TEXTURE_2D, r, f);
                            var x, w = r.mipmaps;
                            if (r.isDepthTexture) {
                                var b = t.DEPTH_COMPONENT;
                                if (r.type === Pt) {
                                    if (!h)
                                        throw new Error("Float Depth Texture only supported in WebGL2.0");
                                    b = t.DEPTH_COMPONENT32F
                                } else
                                    h && (b = t.DEPTH_COMPONENT16);
                                r.format === Gt && b === t.DEPTH_COMPONENT && r.type !== At && r.type !== Rt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                                r.type = At,
                                v = o.convert(r.type)),
                                r.format === Vt && (b = t.DEPTH_STENCIL,
                                r.type !== Ut && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                                r.type = Ut,
                                v = o.convert(r.type))),
                                n.texImage2D(t.TEXTURE_2D, 0, b, l.width, l.height, 0, g, v, null)
                            } else if (r.isDataTexture)
                                if (w.length > 0 && f) {
                                    for (var M = 0, _ = w.length; M < _; M++)
                                        x = w[M],
                                        n.texImage2D(t.TEXTURE_2D, M, g, x.width, x.height, 0, g, v, x.data);
                                    r.generateMipmaps = !1
                                } else
                                    n.texImage2D(t.TEXTURE_2D, 0, g, l.width, l.height, 0, g, v, l.data);
                            else if (r.isCompressedTexture)
                                for (M = 0,
                                _ = w.length; M < _; M++)
                                    x = w[M],
                                    r.format !== zt && r.format !== Bt ? n.getCompressedTextureFormats().indexOf(g) > -1 ? n.compressedTexImage2D(t.TEXTURE_2D, M, g, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, M, g, x.width, x.height, 0, g, v, x.data);
                            else if (w.length > 0 && f) {
                                for (M = 0,
                                _ = w.length; M < _; M++)
                                    x = w[M],
                                    n.texImage2D(t.TEXTURE_2D, M, g, g, v, x);
                                r.generateMipmaps = !1
                            } else
                                n.texImage2D(t.TEXTURE_2D, 0, g, g, v, l);
                            d(r, f) && t.generateMipmap(t.TEXTURE_2D),
                            e.__version = r.version,
                            r.onUpdate && r.onUpdate(r)
                        }(g, e, f);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                }
            }
            n.activeTexture(t.TEXTURE0 + f),
            n.bindTexture(t.TEXTURE_2D, g.__webglTexture)
        }
        function y(n, a, s) {
            var c;
            if (s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, o.convert(a.wrapS)),
            t.texParameteri(n, t.TEXTURE_WRAP_T, o.convert(a.wrapT)),
            t.texParameteri(n, t.TEXTURE_MAG_FILTER, o.convert(a.magFilter)),
            t.texParameteri(n, t.TEXTURE_MIN_FILTER, o.convert(a.minFilter))) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
            t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
            a.wrapS === gt && a.wrapT === gt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", a),
            t.texParameteri(n, t.TEXTURE_MAG_FILTER, f(a.magFilter)),
            t.texParameteri(n, t.TEXTURE_MIN_FILTER, f(a.minFilter)),
            a.minFilter !== yt && a.minFilter !== bt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", a)),
            c = e.get("EXT_texture_filter_anisotropic")) {
                if (a.type === Pt && null === e.get("OES_texture_float_linear"))
                    return;
                if (a.type === Ct && null === e.get("OES_texture_half_float_linear"))
                    return;
                (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())),
                r.get(a).__currentAnisotropy = a.anisotropy)
            }
        }
        function x(e, i, a, s) {
            var c = o.convert(i.texture.format)
              , h = o.convert(i.texture.type);
            n.texImage2D(s, 0, c, i.width, i.height, 0, c, h, null),
            t.bindFramebuffer(t.FRAMEBUFFER, e),
            t.framebufferTexture2D(t.FRAMEBUFFER, a, s, r.get(i.texture).__webglTexture, 0),
            t.bindFramebuffer(t.FRAMEBUFFER, null)
        }
        function w(e, n) {
            t.bindRenderbuffer(t.RENDERBUFFER, e),
            n.depthBuffer && !n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, n.width, n.height),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : n.depthBuffer && n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height),
            t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, n.width, n.height),
            t.bindRenderbuffer(t.RENDERBUFFER, null)
        }
        this.setTexture2D = v,
        this.setTextureCube = function(e, s) {
            var c = r.get(e);
            if (6 === e.image.length)
                if (e.version > 0 && c.__version !== e.version) {
                    c.__image__webglTextureCube || (e.addEventListener("dispose", m),
                    c.__image__webglTextureCube = t.createTexture(),
                    a.textures++),
                    n.activeTexture(t.TEXTURE0 + s),
                    n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube),
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                    for (var h = e && e.isCompressedTexture, l = e.image[0] && e.image[0].isDataTexture, f = [], g = 0; g < 6; g++)
                        f[g] = h || l ? l ? e.image[g].image : e.image[g] : u(e.image[g], i.maxCubemapSize);
                    var v = p(f[0])
                      , x = o.convert(e.format)
                      , w = o.convert(e.type);
                    for (y(t.TEXTURE_CUBE_MAP, e, v),
                    g = 0; g < 6; g++)
                        if (h)
                            for (var b, M = f[g].mipmaps, _ = 0, E = M.length; _ < E; _++)
                                b = M[_],
                                e.format !== zt && e.format !== Bt ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, _, x, b.width, b.height, 0, b.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, _, x, b.width, b.height, 0, x, w, b.data);
                        else
                            l ? n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, x, f[g].width, f[g].height, 0, x, w, f[g].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, x, x, w, f[g]);
                    d(e, v) && t.generateMipmap(t.TEXTURE_CUBE_MAP),
                    c.__version = e.version,
                    e.onUpdate && e.onUpdate(e)
                } else
                    n.activeTexture(t.TEXTURE0 + s),
                    n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube)
        }
        ,
        this.setTextureCubeDynamic = function(e, i) {
            n.activeTexture(t.TEXTURE0 + i),
            n.bindTexture(t.TEXTURE_CUBE_MAP, r.get(e).__webglTexture)
        }
        ,
        this.setupRenderTarget = function(e) {
            var i = r.get(e)
              , o = r.get(e.texture);
            e.addEventListener("dispose", g),
            o.__webglTexture = t.createTexture(),
            a.textures++;
            var s = !0 === e.isWebGLRenderTargetCube
              , c = p(e);
            if (s) {
                i.__webglFramebuffer = [];
                for (var h = 0; h < 6; h++)
                    i.__webglFramebuffer[h] = t.createFramebuffer()
            } else
                i.__webglFramebuffer = t.createFramebuffer();
            if (s) {
                for (n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture),
                y(t.TEXTURE_CUBE_MAP, e.texture, c),
                h = 0; h < 6; h++)
                    x(i.__webglFramebuffer[h], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + h);
                d(e.texture, c) && t.generateMipmap(t.TEXTURE_CUBE_MAP),
                n.bindTexture(t.TEXTURE_CUBE_MAP, null)
            } else
                n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
                y(t.TEXTURE_2D, e.texture, c),
                x(i.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D),
                d(e.texture, c) && t.generateMipmap(t.TEXTURE_2D),
                n.bindTexture(t.TEXTURE_2D, null);
            e.depthBuffer && function(e) {
                var n = r.get(e)
                  , i = !0 === e.isWebGLRenderTargetCube;
                if (e.depthTexture) {
                    if (i)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(e, n) {
                        if (n && n.isWebGLRenderTargetCube)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (t.bindFramebuffer(t.FRAMEBUFFER, e),
                        !n.depthTexture || !n.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width,
                        n.depthTexture.image.height = n.height,
                        n.depthTexture.needsUpdate = !0),
                        v(n.depthTexture, 0);
                        var i = r.get(n.depthTexture).__webglTexture;
                        if (n.depthTexture.format === Gt)
                            t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, i, 0);
                        else {
                            if (n.depthTexture.format !== Vt)
                                throw new Error("Unknown depthTexture format");
                            t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, i, 0)
                        }
                    }(n.__webglFramebuffer, e)
                } else if (i) {
                    n.__webglDepthbuffer = [];
                    for (var o = 0; o < 6; o++)
                        t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[o]),
                        n.__webglDepthbuffer[o] = t.createRenderbuffer(),
                        w(n.__webglDepthbuffer[o], e)
                } else
                    t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer),
                    n.__webglDepthbuffer = t.createRenderbuffer(),
                    w(n.__webglDepthbuffer, e);
                t.bindFramebuffer(t.FRAMEBUFFER, null)
            }(e)
        }
        ,
        this.updateRenderTargetMipmap = function(e) {
            var i = e.texture;
            if (d(i, p(e))) {
                var o = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D
                  , a = r.get(i).__webglTexture;
                n.bindTexture(o, a),
                t.generateMipmap(o),
                n.bindTexture(o, null)
            }
        }
    }
    function Vr(t, e, n, r) {
        tr.call(this),
        this.type = "PerspectiveCamera",
        this.fov = void 0 !== t ? t : 50,
        this.zoom = 1,
        this.near = void 0 !== n ? n : .1,
        this.far = void 0 !== r ? r : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== e ? e : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    function jr(t) {
        Vr.call(this),
        this.cameras = t || []
    }
    function Wr(t) {
        var e = this
          , n = null
          , r = null
          , i = null
          , o = new Be
          , a = new Be;
        "undefined" != typeof window && "VRFrameData"in window && (r = new window.VRFrameData);
        var s = new Be
          , c = new Vr;
        c.bounds = new Ve(0,0,.5,1),
        c.layers.enable(1);
        var h = new Vr;
        h.bounds = new Ve(.5,0,.5,1),
        h.layers.enable(2);
        var l, u, p = new jr([c, h]);
        function d() {
            if (null !== n && n.isPresenting) {
                var r = n.getEyeParameters("left")
                  , i = r.renderWidth
                  , o = r.renderHeight;
                u = t.getPixelRatio(),
                l = t.getSize(),
                t.setDrawingBufferSize(2 * i, o, 1)
            } else
                e.enabled && t.setDrawingBufferSize(l.width, l.height, u)
        }
        p.layers.enable(1),
        p.layers.enable(2),
        "undefined" != typeof window && window.addEventListener("vrdisplaypresentchange", d, !1),
        this.enabled = !1,
        this.userHeight = 1.6,
        this.getDevice = function() {
            return n
        }
        ,
        this.setDevice = function(t) {
            void 0 !== t && (n = t)
        }
        ,
        this.setPoseTarget = function(t) {
            void 0 !== t && (i = t)
        }
        ,
        this.getCamera = function(t) {
            if (null === n)
                return t;
            n.depthNear = t.near,
            n.depthFar = t.far,
            n.getFrameData(r);
            var l = r.pose
              , u = null !== i ? i : t;
            null !== l.position ? u.position.fromArray(l.position) : u.position.set(0, 0, 0),
            null !== l.orientation && u.quaternion.fromArray(l.orientation);
            var d = n.stageParameters;
            if (d ? o.fromArray(d.sittingToStandingTransform) : o.makeTranslation(0, e.userHeight, 0),
            u.position.applyMatrix4(o),
            u.updateMatrixWorld(),
            !1 === n.isPresenting)
                return t;
            c.near = t.near,
            h.near = t.near,
            c.far = t.far,
            h.far = t.far,
            p.matrixWorld.copy(t.matrixWorld),
            p.matrixWorldInverse.copy(t.matrixWorldInverse),
            c.matrixWorldInverse.fromArray(r.leftViewMatrix),
            h.matrixWorldInverse.fromArray(r.rightViewMatrix),
            a.getInverse(o),
            c.matrixWorldInverse.multiply(a),
            h.matrixWorldInverse.multiply(a);
            var f = u.parent;
            null !== f && (s.getInverse(f.matrixWorld),
            c.matrixWorldInverse.multiply(s),
            h.matrixWorldInverse.multiply(s)),
            c.matrixWorld.getInverse(c.matrixWorldInverse),
            h.matrixWorld.getInverse(h.matrixWorldInverse),
            c.projectionMatrix.fromArray(r.leftProjectionMatrix),
            h.projectionMatrix.fromArray(r.rightProjectionMatrix),
            p.projectionMatrix.copy(c.projectionMatrix);
            var m = n.getLayers();
            if (m.length) {
                var g = m[0];
                null !== g.leftBounds && 4 === g.leftBounds.length && c.bounds.fromArray(g.leftBounds),
                null !== g.rightBounds && 4 === g.rightBounds.length && h.bounds.fromArray(g.rightBounds)
            }
            return p
        }
        ,
        this.getStandingMatrix = function() {
            return o
        }
        ,
        this.submitFrame = function() {
            n && n.isPresenting && n.submitFrame()
        }
        ,
        this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", d)
        }
    }
    function Yr(t, e) {
        return {
            convert: function(n) {
                var r;
                if (n === mt)
                    return t.REPEAT;
                if (n === gt)
                    return t.CLAMP_TO_EDGE;
                if (n === vt)
                    return t.MIRRORED_REPEAT;
                if (n === yt)
                    return t.NEAREST;
                if (n === xt)
                    return t.NEAREST_MIPMAP_NEAREST;
                if (n === wt)
                    return t.NEAREST_MIPMAP_LINEAR;
                if (n === bt)
                    return t.LINEAR;
                if (n === Mt)
                    return t.LINEAR_MIPMAP_NEAREST;
                if (n === _t)
                    return t.LINEAR_MIPMAP_LINEAR;
                if (n === Et)
                    return t.UNSIGNED_BYTE;
                if (n === It)
                    return t.UNSIGNED_SHORT_4_4_4_4;
                if (n === Ot)
                    return t.UNSIGNED_SHORT_5_5_5_1;
                if (n === Dt)
                    return t.UNSIGNED_SHORT_5_6_5;
                if (n === St)
                    return t.BYTE;
                if (n === Tt)
                    return t.SHORT;
                if (n === At)
                    return t.UNSIGNED_SHORT;
                if (n === Lt)
                    return t.INT;
                if (n === Rt)
                    return t.UNSIGNED_INT;
                if (n === Pt)
                    return t.FLOAT;
                if (n === Ct && null !== (r = e.get("OES_texture_half_float")))
                    return r.HALF_FLOAT_OES;
                if (n === Nt)
                    return t.ALPHA;
                if (n === Bt)
                    return t.RGB;
                if (n === zt)
                    return t.RGBA;
                if (n === Ft)
                    return t.LUMINANCE;
                if (n === kt)
                    return t.LUMINANCE_ALPHA;
                if (n === Gt)
                    return t.DEPTH_COMPONENT;
                if (n === Vt)
                    return t.DEPTH_STENCIL;
                if (n === R)
                    return t.FUNC_ADD;
                if (n === P)
                    return t.FUNC_SUBTRACT;
                if (n === C)
                    return t.FUNC_REVERSE_SUBTRACT;
                if (n === D)
                    return t.ZERO;
                if (n === U)
                    return t.ONE;
                if (n === N)
                    return t.SRC_COLOR;
                if (n === B)
                    return t.ONE_MINUS_SRC_COLOR;
                if (n === z)
                    return t.SRC_ALPHA;
                if (n === F)
                    return t.ONE_MINUS_SRC_ALPHA;
                if (n === k)
                    return t.DST_ALPHA;
                if (n === H)
                    return t.ONE_MINUS_DST_ALPHA;
                if (n === G)
                    return t.DST_COLOR;
                if (n === V)
                    return t.ONE_MINUS_DST_COLOR;
                if (n === j)
                    return t.SRC_ALPHA_SATURATE;
                if ((n === jt || n === Wt || n === Yt || n === Xt) && null !== (r = e.get("WEBGL_compressed_texture_s3tc"))) {
                    if (n === jt)
                        return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (n === Wt)
                        return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (n === Yt)
                        return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (n === Xt)
                        return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((n === qt || n === Zt || n === Jt || n === Kt) && null !== (r = e.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (n === qt)
                        return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (n === Zt)
                        return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (n === Jt)
                        return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (n === Kt)
                        return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (n === Qt && null !== (r = e.get("WEBGL_compressed_texture_etc1")))
                    return r.COMPRESSED_RGB_ETC1_WEBGL;
                if ((n === $t || n === te || n === ee || n === ne || n === re || n === ie || n === oe || n === ae || n === se || n === ce || n === he || n === le || n === ue || n === pe) && null !== (r = e.get("WEBGL_compressed_texture_astc")))
                    return n;
                if ((n === I || n === O) && null !== (r = e.get("EXT_blend_minmax"))) {
                    if (n === I)
                        return r.MIN_EXT;
                    if (n === O)
                        return r.MAX_EXT
                }
                return n === Ut && null !== (r = e.get("WEBGL_depth_texture")) ? r.UNSIGNED_INT_24_8_WEBGL : 0
            }
        }
    }
    Vr.prototype = Object.assign(Object.create(tr.prototype), {
        constructor: Vr,
        isPerspectiveCamera: !0,
        copy: function(t, e) {
            return tr.prototype.copy.call(this, t, e),
            this.fov = t.fov,
            this.zoom = t.zoom,
            this.near = t.near,
            this.far = t.far,
            this.focus = t.focus,
            this.aspect = t.aspect,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this.filmGauge = t.filmGauge,
            this.filmOffset = t.filmOffset,
            this
        },
        setFocalLength: function(t) {
            var e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * Ue.RAD2DEG * Math.atan(e),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var t = Math.tan(.5 * Ue.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * Ue.RAD2DEG * Math.atan(Math.tan(.5 * Ue.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, n, r, i, o) {
            this.aspect = t / e,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = r,
            this.view.width = i,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = this.near
              , e = t * Math.tan(.5 * Ue.DEG2RAD * this.fov) / this.zoom
              , n = 2 * e
              , r = this.aspect * n
              , i = -.5 * r
              , o = this.view;
            if (null !== this.view && this.view.enabled) {
                var a = o.fullWidth
                  , s = o.fullHeight;
                i += o.offsetX * r / a,
                e -= o.offsetY * n / s,
                r *= o.width / a,
                n *= o.height / s
            }
            var c = this.filmOffset;
            0 !== c && (i += t * c / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far)
        },
        toJSON: function(t) {
            var e = $n.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov,
            e.object.zoom = this.zoom,
            e.object.near = this.near,
            e.object.far = this.far,
            e.object.focus = this.focus,
            e.object.aspect = this.aspect,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e.object.filmGauge = this.filmGauge,
            e.object.filmOffset = this.filmOffset,
            e
        }
    }),
    jr.prototype = Object.assign(Object.create(Vr.prototype), {
        constructor: jr,
        isArrayCamera: !0
    });
    var Xr = 0;
    function qr() {
        var t = {};
        return {
            get: function(e, n) {
                var r = e.id + "," + n.id
                  , i = t[r];
                return void 0 === i && (i = new function() {
                    var t = new function() {
                        var t = new function() {
                            var t = {};
                            return {
                                get: function(e) {
                                    if (void 0 !== t[e.id])
                                        return t[e.id];
                                    var n;
                                    switch (e.type) {
                                    case "DirectionalLight":
                                        n = {
                                            direction: new Fe,
                                            color: new Un,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ne
                                        };
                                        break;
                                    case "SpotLight":
                                        n = {
                                            position: new Fe,
                                            direction: new Fe,
                                            color: new Un,
                                            distance: 0,
                                            coneCos: 0,
                                            penumbraCos: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ne
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            position: new Fe,
                                            color: new Un,
                                            distance: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ne,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        };
                                        break;
                                    case "HemisphereLight":
                                        n = {
                                            direction: new Fe,
                                            skyColor: new Un,
                                            groundColor: new Un
                                        };
                                        break;
                                    case "RectAreaLight":
                                        n = {
                                            color: new Un,
                                            position: new Fe,
                                            halfWidth: new Fe,
                                            halfHeight: new Fe
                                        }
                                    }
                                    return t[e.id] = n,
                                    n
                                }
                            }
                        }
                          , e = {
                            id: Xr++,
                            hash: "",
                            ambient: [0, 0, 0],
                            directional: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotShadowMap: [],
                            spotShadowMatrix: [],
                            rectArea: [],
                            point: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: []
                        }
                          , n = new Fe
                          , r = new Be
                          , i = new Be;
                        return {
                            setup: function(o, a, s) {
                                for (var c = 0, h = 0, l = 0, u = 0, p = 0, d = 0, f = 0, m = 0, g = s.matrixWorldInverse, v = 0, y = o.length; v < y; v++) {
                                    var x = o[v]
                                      , w = x.color
                                      , b = x.intensity
                                      , M = x.distance
                                      , _ = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                                    if (x.isAmbientLight)
                                        c += w.r * b,
                                        h += w.g * b,
                                        l += w.b * b;
                                    else if (x.isDirectionalLight) {
                                        if ((S = t.get(x)).color.copy(x.color).multiplyScalar(x.intensity),
                                        S.direction.setFromMatrixPosition(x.matrixWorld),
                                        n.setFromMatrixPosition(x.target.matrixWorld),
                                        S.direction.sub(n),
                                        S.direction.transformDirection(g),
                                        S.shadow = x.castShadow,
                                        x.castShadow) {
                                            var E = x.shadow;
                                            S.shadowBias = E.bias,
                                            S.shadowRadius = E.radius,
                                            S.shadowMapSize = E.mapSize
                                        }
                                        e.directionalShadowMap[u] = _,
                                        e.directionalShadowMatrix[u] = x.shadow.matrix,
                                        e.directional[u] = S,
                                        u++
                                    } else if (x.isSpotLight)
                                        (S = t.get(x)).position.setFromMatrixPosition(x.matrixWorld),
                                        S.position.applyMatrix4(g),
                                        S.color.copy(w).multiplyScalar(b),
                                        S.distance = M,
                                        S.direction.setFromMatrixPosition(x.matrixWorld),
                                        n.setFromMatrixPosition(x.target.matrixWorld),
                                        S.direction.sub(n),
                                        S.direction.transformDirection(g),
                                        S.coneCos = Math.cos(x.angle),
                                        S.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)),
                                        S.decay = 0 === x.distance ? 0 : x.decay,
                                        S.shadow = x.castShadow,
                                        x.castShadow && (E = x.shadow,
                                        S.shadowBias = E.bias,
                                        S.shadowRadius = E.radius,
                                        S.shadowMapSize = E.mapSize),
                                        e.spotShadowMap[d] = _,
                                        e.spotShadowMatrix[d] = x.shadow.matrix,
                                        e.spot[d] = S,
                                        d++;
                                    else if (x.isRectAreaLight)
                                        (S = t.get(x)).color.copy(w).multiplyScalar(b),
                                        S.position.setFromMatrixPosition(x.matrixWorld),
                                        S.position.applyMatrix4(g),
                                        i.identity(),
                                        r.copy(x.matrixWorld),
                                        r.premultiply(g),
                                        i.extractRotation(r),
                                        S.halfWidth.set(.5 * x.width, 0, 0),
                                        S.halfHeight.set(0, .5 * x.height, 0),
                                        S.halfWidth.applyMatrix4(i),
                                        S.halfHeight.applyMatrix4(i),
                                        e.rectArea[f] = S,
                                        f++;
                                    else if (x.isPointLight)
                                        (S = t.get(x)).position.setFromMatrixPosition(x.matrixWorld),
                                        S.position.applyMatrix4(g),
                                        S.color.copy(x.color).multiplyScalar(x.intensity),
                                        S.distance = x.distance,
                                        S.decay = 0 === x.distance ? 0 : x.decay,
                                        S.shadow = x.castShadow,
                                        x.castShadow && (E = x.shadow,
                                        S.shadowBias = E.bias,
                                        S.shadowRadius = E.radius,
                                        S.shadowMapSize = E.mapSize,
                                        S.shadowCameraNear = E.camera.near,
                                        S.shadowCameraFar = E.camera.far),
                                        e.pointShadowMap[p] = _,
                                        e.pointShadowMatrix[p] = x.shadow.matrix,
                                        e.point[p] = S,
                                        p++;
                                    else if (x.isHemisphereLight) {
                                        var S;
                                        (S = t.get(x)).direction.setFromMatrixPosition(x.matrixWorld),
                                        S.direction.transformDirection(g),
                                        S.direction.normalize(),
                                        S.skyColor.copy(x.color).multiplyScalar(b),
                                        S.groundColor.copy(x.groundColor).multiplyScalar(b),
                                        e.hemi[m] = S,
                                        m++
                                    }
                                }
                                e.ambient[0] = c,
                                e.ambient[1] = h,
                                e.ambient[2] = l,
                                e.directional.length = u,
                                e.spot.length = d,
                                e.rectArea.length = f,
                                e.point.length = p,
                                e.hemi.length = m,
                                e.hash = e.id + "," + u + "," + p + "," + d + "," + f + "," + m + "," + a.length
                            },
                            state: e
                        }
                    }
                      , e = []
                      , n = []
                      , r = [];
                    return {
                        init: function() {
                            e.length = 0,
                            n.length = 0,
                            r.length = 0
                        },
                        state: {
                            lightsArray: e,
                            shadowsArray: n,
                            spritesArray: r,
                            lights: t
                        },
                        setupLights: function(r) {
                            t.setup(e, n, r)
                        },
                        pushLight: function(t) {
                            e.push(t)
                        },
                        pushShadow: function(t) {
                            n.push(t)
                        },
                        pushSprite: function(t) {
                            r.push(t)
                        }
                    }
                }
                ,
                t[r] = i),
                i
            },
            dispose: function() {
                t = {}
            }
        }
    }
    function Zr(t) {
        console.log("THREE.WebGLRenderer", i);
        var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
          , n = void 0 !== t.context ? t.context : null
          , r = void 0 !== t.alpha && t.alpha
          , o = void 0 === t.depth || t.depth
          , h = void 0 === t.stencil || t.stencil
          , l = void 0 !== t.antialias && t.antialias
          , u = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
          , p = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
          , d = void 0 !== t.powerPreference ? t.powerPreference : "default"
          , f = null
          , m = null;
        this.domElement = e,
        this.context = null,
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.gammaInput = !1,
        this.gammaOutput = !1,
        this.physicallyCorrectLights = !1,
        this.toneMapping = rt,
        this.toneMappingExposure = 1,
        this.toneMappingWhitePoint = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var y, x, b, M, R, P, C, I, O, D, U, N, B, z, F, k, H, G, V = this, j = !1, $ = null, tt = null, et = -1, nt = "", it = null, ot = null, at = new Ve, st = new Ve, ct = null, ht = 0, lt = e.width, ut = e.height, pt = 1, dt = new Ve(0,0,lt,ut), ft = new Ve(0,0,lt,ut), mt = !1, gt = new qn, vt = new function() {
            var t = this
              , e = null
              , n = 0
              , r = !1
              , i = !1
              , o = new Xn
              , a = new ke
              , s = {
                value: null,
                needsUpdate: !1
            };
            function c() {
                s.value !== e && (s.value = e,
                s.needsUpdate = n > 0),
                t.numPlanes = n,
                t.numIntersection = 0
            }
            function h(e, n, r, i) {
                var c = null !== e ? e.length : 0
                  , h = null;
                if (0 !== c) {
                    if (h = s.value,
                    !0 !== i || null === h) {
                        var l = r + 4 * c
                          , u = n.matrixWorldInverse;
                        a.getNormalMatrix(u),
                        (null === h || h.length < l) && (h = new Float32Array(l));
                        for (var p = 0, d = r; p !== c; ++p,
                        d += 4)
                            o.copy(e[p]).applyMatrix4(u, a),
                            o.normal.toArray(h, d),
                            h[d + 3] = o.constant
                    }
                    s.value = h,
                    s.needsUpdate = !0
                }
                return t.numPlanes = c,
                h
            }
            this.uniform = s,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(t, i, o) {
                var a = 0 !== t.length || i || 0 !== n || r;
                return r = i,
                e = h(t, o, 0),
                n = t.length,
                a
            }
            ,
            this.beginShadows = function() {
                i = !0,
                h(null)
            }
            ,
            this.endShadows = function() {
                i = !1,
                c()
            }
            ,
            this.setState = function(t, o, a, l, u, p) {
                if (!r || null === t || 0 === t.length || i && !a)
                    i ? h(null) : c();
                else {
                    var d = i ? 0 : n
                      , f = 4 * d
                      , m = u.clippingState || null;
                    s.value = m,
                    m = h(t, l, f, p);
                    for (var g = 0; g !== f; ++g)
                        m[g] = e[g];
                    u.clippingState = m,
                    this.numIntersection = o ? this.numPlanes : 0,
                    this.numPlanes += d
                }
            }
        }
        , yt = !1, xt = !1, wt = new Be, bt = new Fe, Mt = {
            geometries: 0,
            textures: 0
        }, _t = {
            frame: 0,
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        };
        function St() {
            return null === $ ? pt : 1
        }
        this.info = {
            render: _t,
            memory: Mt,
            programs: null,
            autoReset: !0,
            reset: function() {
                _t.frame++,
                _t.calls = 0,
                _t.vertices = 0,
                _t.faces = 0,
                _t.points = 0
            }
        };
        try {
            var Tt = {
                alpha: r,
                depth: o,
                stencil: h,
                antialias: l,
                premultipliedAlpha: u,
                preserveDrawingBuffer: p,
                powerPreference: d
            };
            if (e.addEventListener("webglcontextlost", It, !1),
            e.addEventListener("webglcontextrestored", Ot, !1),
            null === (y = n || e.getContext("webgl", Tt) || e.getContext("experimental-webgl", Tt)))
                throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === y.getShaderPrecisionFormat && (y.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (t) {
            console.error("THREE.WebGLRenderer: " + t.message)
        }
        function At() {
            (x = new function(t) {
                var e = {};
                return {
                    get: function(n) {
                        if (void 0 !== e[n])
                            return e[n];
                        var r;
                        switch (n) {
                        case "WEBGL_depth_texture":
                            r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case "WEBGL_compressed_texture_etc1":
                            r = t.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            r = t.getExtension(n)
                        }
                        return null === r && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."),
                        e[n] = r,
                        r
                    }
                }
            }
            (y)).get("WEBGL_depth_texture"),
            x.get("OES_texture_float"),
            x.get("OES_texture_float_linear"),
            x.get("OES_texture_half_float"),
            x.get("OES_texture_half_float_linear"),
            x.get("OES_standard_derivatives"),
            x.get("OES_element_index_uint"),
            x.get("ANGLE_instanced_arrays"),
            G = new Yr(y,x),
            b = new function(t, e, n) {
                var r;
                function i(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
                            return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                var o = void 0 !== n.precision ? n.precision : "highp"
                  , a = i(o);
                a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."),
                o = a);
                var s = !0 === n.logarithmicDepthBuffer
                  , c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
                  , h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                  , l = t.getParameter(t.MAX_TEXTURE_SIZE)
                  , u = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)
                  , p = t.getParameter(t.MAX_VERTEX_ATTRIBS)
                  , d = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)
                  , f = t.getParameter(t.MAX_VARYING_VECTORS)
                  , m = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS)
                  , g = h > 0
                  , v = !!e.get("OES_texture_float");
                return {
                    getMaxAnisotropy: function() {
                        if (void 0 !== r)
                            return r;
                        var n = e.get("EXT_texture_filter_anisotropic");
                        return r = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: i,
                    precision: o,
                    logarithmicDepthBuffer: s,
                    maxTextures: c,
                    maxVertexTextures: h,
                    maxTextureSize: l,
                    maxCubemapSize: u,
                    maxAttributes: p,
                    maxVertexUniforms: d,
                    maxVaryings: f,
                    maxFragmentUniforms: m,
                    vertexTextures: g,
                    floatFragmentTextures: v,
                    floatVertexTextures: g && v
                }
            }
            (y,x,t),
            (M = new function(t, e, n) {
                var r = new function() {
                    var e = !1
                      , n = new Ve
                      , r = null
                      , i = new Ve(0,0,0,0);
                    return {
                        setMask: function(n) {
                            r === n || e || (t.colorMask(n, n, n, n),
                            r = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, r, o, a, s) {
                            !0 === s && (e *= a,
                            r *= a,
                            o *= a),
                            n.set(e, r, o, a),
                            !1 === i.equals(n) && (t.clearColor(e, r, o, a),
                            i.copy(n))
                        },
                        reset: function() {
                            e = !1,
                            r = null,
                            i.set(-1, 0, 0, 0)
                        }
                    }
                }
                  , i = new function() {
                    var e = !1
                      , n = null
                      , r = null
                      , i = null;
                    return {
                        setTest: function(e) {
                            e ? et(t.DEPTH_TEST) : nt(t.DEPTH_TEST)
                        },
                        setMask: function(r) {
                            n === r || e || (t.depthMask(r),
                            n = r)
                        },
                        setFunc: function(e) {
                            if (r !== e) {
                                if (e)
                                    switch (e) {
                                    case W:
                                        t.depthFunc(t.NEVER);
                                        break;
                                    case Y:
                                        t.depthFunc(t.ALWAYS);
                                        break;
                                    case X:
                                        t.depthFunc(t.LESS);
                                        break;
                                    case q:
                                        t.depthFunc(t.LEQUAL);
                                        break;
                                    case Z:
                                        t.depthFunc(t.EQUAL);
                                        break;
                                    case J:
                                        t.depthFunc(t.GEQUAL);
                                        break;
                                    case K:
                                        t.depthFunc(t.GREATER);
                                        break;
                                    case Q:
                                        t.depthFunc(t.NOTEQUAL);
                                        break;
                                    default:
                                        t.depthFunc(t.LEQUAL)
                                    }
                                else
                                    t.depthFunc(t.LEQUAL);
                                r = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            i !== e && (t.clearDepth(e),
                            i = e)
                        },
                        reset: function() {
                            e = !1,
                            n = null,
                            r = null,
                            i = null
                        }
                    }
                }
                  , o = new function() {
                    var e = !1
                      , n = null
                      , r = null
                      , i = null
                      , o = null
                      , a = null
                      , s = null
                      , c = null
                      , h = null;
                    return {
                        setTest: function(e) {
                            e ? et(t.STENCIL_TEST) : nt(t.STENCIL_TEST)
                        },
                        setMask: function(r) {
                            n === r || e || (t.stencilMask(r),
                            n = r)
                        },
                        setFunc: function(e, n, a) {
                            r === e && i === n && o === a || (t.stencilFunc(e, n, a),
                            r = e,
                            i = n,
                            o = a)
                        },
                        setOp: function(e, n, r) {
                            a === e && s === n && c === r || (t.stencilOp(e, n, r),
                            a = e,
                            s = n,
                            c = r)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            h !== e && (t.clearStencil(e),
                            h = e)
                        },
                        reset: function() {
                            e = !1,
                            n = null,
                            r = null,
                            i = null,
                            o = null,
                            a = null,
                            s = null,
                            c = null,
                            h = null
                        }
                    }
                }
                  , h = t.getParameter(t.MAX_VERTEX_ATTRIBS)
                  , l = new Uint8Array(h)
                  , u = new Uint8Array(h)
                  , p = new Uint8Array(h)
                  , d = {}
                  , f = null
                  , m = null
                  , y = null
                  , x = null
                  , w = null
                  , b = null
                  , M = null
                  , R = null
                  , P = null
                  , C = !1
                  , I = null
                  , O = null
                  , D = null
                  , U = null
                  , N = null
                  , B = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
                  , z = !1
                  , F = 0
                  , k = t.getParameter(t.VERSION);
                -1 !== k.indexOf("WebGL") ? (F = parseFloat(/^WebGL\ ([0-9])/.exec(k)[1]),
                z = F >= 1) : -1 !== k.indexOf("OpenGL ES") && (F = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(k)[1]),
                z = F >= 2);
                var H = null
                  , G = {}
                  , V = new Ve
                  , j = new Ve;
                function $(e, n, r) {
                    var i = new Uint8Array(4)
                      , o = t.createTexture();
                    t.bindTexture(e, o),
                    t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
                    t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                    for (var a = 0; a < r; a++)
                        t.texImage2D(n + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, i);
                    return o
                }
                var tt = {};
                function et(e) {
                    !0 !== d[e] && (t.enable(e),
                    d[e] = !0)
                }
                function nt(e) {
                    !1 !== d[e] && (t.disable(e),
                    d[e] = !1)
                }
                function rt(e, r, i, o, a, s, c, h) {
                    if (e !== _ ? et(t.BLEND) : nt(t.BLEND),
                    e !== L) {
                        if (e !== y || h !== C)
                            switch (e) {
                            case S:
                                h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                                t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD),
                                t.blendFunc(t.SRC_ALPHA, t.ONE));
                                break;
                            case T:
                                h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                                t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD),
                                t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR));
                                break;
                            case A:
                                h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD),
                                t.blendFunc(t.ZERO, t.SRC_COLOR));
                                break;
                            default:
                                h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                                t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                                t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA))
                            }
                        x = null,
                        w = null,
                        b = null,
                        M = null,
                        R = null,
                        P = null
                    } else
                        a = a || r,
                        s = s || i,
                        c = c || o,
                        r === x && a === M || (t.blendEquationSeparate(n.convert(r), n.convert(a)),
                        x = r,
                        M = a),
                        i === w && o === b && s === R && c === P || (t.blendFuncSeparate(n.convert(i), n.convert(o), n.convert(s), n.convert(c)),
                        w = i,
                        b = o,
                        R = s,
                        P = c);
                    y = e,
                    C = h
                }
                function it(e) {
                    I !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
                    I = e)
                }
                function ot(e) {
                    e !== a ? (et(t.CULL_FACE),
                    e !== O && (e === s ? t.cullFace(t.BACK) : e === c ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : nt(t.CULL_FACE),
                    O = e
                }
                function at(e, n, r) {
                    e ? (et(t.POLYGON_OFFSET_FILL),
                    U === n && N === r || (t.polygonOffset(n, r),
                    U = n,
                    N = r)) : nt(t.POLYGON_OFFSET_FILL)
                }
                function st(e) {
                    void 0 === e && (e = t.TEXTURE0 + B - 1),
                    H !== e && (t.activeTexture(e),
                    H = e)
                }
                return tt[t.TEXTURE_2D] = $(t.TEXTURE_2D, t.TEXTURE_2D, 1),
                tt[t.TEXTURE_CUBE_MAP] = $(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                r.setClear(0, 0, 0, 1),
                i.setClear(1),
                o.setClear(0),
                et(t.DEPTH_TEST),
                i.setFunc(q),
                it(!1),
                ot(s),
                et(t.CULL_FACE),
                et(t.BLEND),
                rt(E),
                {
                    buffers: {
                        color: r,
                        depth: i,
                        stencil: o
                    },
                    initAttributes: function() {
                        for (var t = 0, e = l.length; t < e; t++)
                            l[t] = 0
                    },
                    enableAttribute: function(n) {
                        l[n] = 1,
                        0 === u[n] && (t.enableVertexAttribArray(n),
                        u[n] = 1),
                        0 !== p[n] && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, 0),
                        p[n] = 0)
                    },
                    enableAttributeAndDivisor: function(n, r) {
                        l[n] = 1,
                        0 === u[n] && (t.enableVertexAttribArray(n),
                        u[n] = 1),
                        p[n] !== r && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, r),
                        p[n] = r)
                    },
                    disableUnusedAttributes: function() {
                        for (var e = 0, n = u.length; e !== n; ++e)
                            u[e] !== l[e] && (t.disableVertexAttribArray(e),
                            u[e] = 0)
                    },
                    enable: et,
                    disable: nt,
                    getCompressedTextureFormats: function() {
                        if (null === f && (f = [],
                        e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                            for (var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), r = 0; r < n.length; r++)
                                f.push(n[r]);
                        return f
                    },
                    useProgram: function(e) {
                        return m !== e && (t.useProgram(e),
                        m = e,
                        !0)
                    },
                    setBlending: rt,
                    setMaterial: function(e, n) {
                        e.side === v ? nt(t.CULL_FACE) : et(t.CULL_FACE);
                        var o = e.side === g;
                        n && (o = !o),
                        it(o),
                        !0 === e.transparent ? rt(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : rt(_),
                        i.setFunc(e.depthFunc),
                        i.setTest(e.depthTest),
                        i.setMask(e.depthWrite),
                        r.setMask(e.colorWrite),
                        at(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                    },
                    setFlipSided: it,
                    setCullFace: ot,
                    setLineWidth: function(e) {
                        e !== D && (z && t.lineWidth(e),
                        D = e)
                    },
                    setPolygonOffset: at,
                    setScissorTest: function(e) {
                        e ? et(t.SCISSOR_TEST) : nt(t.SCISSOR_TEST)
                    },
                    activeTexture: st,
                    bindTexture: function(e, n) {
                        null === H && st();
                        var r = G[H];
                        void 0 === r && (r = {
                            type: void 0,
                            texture: void 0
                        },
                        G[H] = r),
                        r.type === e && r.texture === n || (t.bindTexture(e, n || tt[e]),
                        r.type = e,
                        r.texture = n)
                    },
                    compressedTexImage2D: function() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage2D: function() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    scissor: function(e) {
                        !1 === V.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                        V.copy(e))
                    },
                    viewport: function(e) {
                        !1 === j.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                        j.copy(e))
                    },
                    reset: function() {
                        for (var e = 0; e < u.length; e++)
                            1 === u[e] && (t.disableVertexAttribArray(e),
                            u[e] = 0);
                        d = {},
                        f = null,
                        H = null,
                        G = {},
                        m = null,
                        y = null,
                        I = null,
                        O = null,
                        r.reset(),
                        i.reset(),
                        o.reset()
                    }
                }
            }
            (y,x,G)).scissor(st.copy(ft).multiplyScalar(pt)),
            M.viewport(at.copy(dt).multiplyScalar(pt)),
            R = new function() {
                var t = {};
                return {
                    get: function(e) {
                        var n = e.uuid
                          , r = t[n];
                        return void 0 === r && (r = {},
                        t[n] = r),
                        r
                    },
                    remove: function(e) {
                        delete t[e.uuid]
                    },
                    update: function(e, n, r) {
                        var i = e.uuid;
                        t[i][n] = r
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }
            ,
            P = new Gr(y,x,M,R,b,G,Mt,_t),
            C = new function(t) {
                var e = {};
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data),
                        e[t.uuid]
                    },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var r = e[n.uuid];
                        r && (t.deleteBuffer(r.buffer),
                        delete e[n.uuid])
                    },
                    update: function(n, r) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var i = e[n.uuid];
                        void 0 === i ? e[n.uuid] = function(e, n) {
                            var r = e.array
                              , i = e.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW
                              , o = t.createBuffer();
                            t.bindBuffer(n, o),
                            t.bufferData(n, r, i),
                            e.onUploadCallback();
                            var a = t.FLOAT;
                            return r instanceof Float32Array ? a = t.FLOAT : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? a = t.UNSIGNED_SHORT : r instanceof Int16Array ? a = t.SHORT : r instanceof Uint32Array ? a = t.UNSIGNED_INT : r instanceof Int32Array ? a = t.INT : r instanceof Int8Array ? a = t.BYTE : r instanceof Uint8Array && (a = t.UNSIGNED_BYTE),
                            {
                                buffer: o,
                                type: a,
                                bytesPerElement: r.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(n, r) : i.version < n.version && (function(e, n, r) {
                            var i = n.array
                              , o = n.updateRange;
                            t.bindBuffer(r, e),
                            !1 === n.dynamic ? t.bufferData(r, i, t.STATIC_DRAW) : -1 === o.count ? t.bufferSubData(r, 0, i) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(r, o.offset * i.BYTES_PER_ELEMENT, i.subarray(o.offset, o.offset + o.count)),
                            o.count = -1)
                        }(i.buffer, n, r),
                        i.version = n.version)
                    }
                }
            }
            (y),
            I = new function(t, e, n) {
                var r = {}
                  , i = {};
                function o(t) {
                    var a = t.target
                      , s = r[a.id];
                    for (var c in null !== s.index && e.remove(s.index),
                    s.attributes)
                        e.remove(s.attributes[c]);
                    a.removeEventListener("dispose", o),
                    delete r[a.id];
                    var h = i[a.id];
                    h && (e.remove(h),
                    delete i[a.id]),
                    (h = i[s.id]) && (e.remove(h),
                    delete i[s.id]),
                    n.geometries--
                }
                return {
                    get: function(t, e) {
                        var i = r[e.id];
                        return i || (e.addEventListener("dispose", o),
                        e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new yr).setFromObject(t)),
                        i = e._bufferGeometry),
                        r[e.id] = i,
                        n.geometries++,
                        i)
                    },
                    update: function(n) {
                        var r = n.index
                          , i = n.attributes;
                        for (var o in null !== r && e.update(r, t.ELEMENT_ARRAY_BUFFER),
                        i)
                            e.update(i[o], t.ARRAY_BUFFER);
                        var a = n.morphAttributes;
                        for (var o in a)
                            for (var s = a[o], c = 0, h = s.length; c < h; c++)
                                e.update(s[c], t.ARRAY_BUFFER)
                    },
                    getWireframeAttribute: function(n) {
                        var r = i[n.id];
                        if (r)
                            return r;
                        var o, a = [], s = n.index, c = n.attributes;
                        if (null !== s)
                            for (var h = 0, l = (o = s.array).length; h < l; h += 3) {
                                var u = o[h + 0]
                                  , p = o[h + 1]
                                  , d = o[h + 2];
                                a.push(u, p, p, d, d, u)
                            }
                        else
                            for (h = 0,
                            l = (o = c.position.array).length / 3 - 1; h < l; h += 3)
                                u = h + 0,
                                p = h + 1,
                                d = h + 2,
                                a.push(u, p, p, d, d, u);
                        return r = new (gr(a) > 65535 ? pr : lr)(a,1),
                        e.update(r, t.ELEMENT_ARRAY_BUFFER),
                        i[n.id] = r,
                        r
                    }
                }
            }
            (y,C,Mt),
            O = new function(t, e) {
                var n = {};
                return {
                    update: function(r) {
                        var i = e.frame
                          , o = r.geometry
                          , a = t.get(r, o);
                        return n[a.id] !== i && (o.isGeometry && a.updateFromObject(r),
                        t.update(a),
                        n[a.id] = i),
                        a
                    },
                    dispose: function() {
                        n = {}
                    }
                }
            }
            (I,_t),
            z = new function(t) {
                var e = {}
                  , n = new Float32Array(8);
                return {
                    update: function(r, i, o, a) {
                        var s = r.morphTargetInfluences
                          , c = s.length
                          , h = e[i.id];
                        if (void 0 === h) {
                            h = [];
                            for (var l = 0; l < c; l++)
                                h[l] = [l, 0];
                            e[i.id] = h
                        }
                        var u = o.morphTargets && i.morphAttributes.position
                          , p = o.morphNormals && i.morphAttributes.normal;
                        for (l = 0; l < c; l++)
                            0 !== (d = h[l])[1] && (u && i.removeAttribute("morphTarget" + l),
                            p && i.removeAttribute("morphNormal" + l));
                        for (l = 0; l < c; l++)
                            (d = h[l])[0] = l,
                            d[1] = s[l];
                        for (h.sort(Cr),
                        l = 0; l < 8; l++) {
                            var d;
                            if (d = h[l]) {
                                var f = d[0]
                                  , m = d[1];
                                if (m) {
                                    u && i.addAttribute("morphTarget" + l, u[f]),
                                    p && i.addAttribute("morphNormal" + l, p[f]),
                                    n[l] = m;
                                    continue
                                }
                            }
                            n[l] = 0
                        }
                        a.getUniforms().setValue(t, "morphTargetInfluences", n)
                    }
                }
            }
            (y),
            D = new Hr(V,x,b),
            U = new function() {
                var t = {};
                return {
                    get: function(e, n) {
                        var r = e.id + "," + n.id
                          , i = t[r];
                        return void 0 === i && (i = new function() {
                            var t = []
                              , e = 0
                              , n = []
                              , r = [];
                            return {
                                opaque: n,
                                transparent: r,
                                init: function() {
                                    e = 0,
                                    n.length = 0,
                                    r.length = 0
                                },
                                push: function(i, o, a, s, c) {
                                    var h = t[e];
                                    void 0 === h ? (h = {
                                        id: i.id,
                                        object: i,
                                        geometry: o,
                                        material: a,
                                        program: a.program,
                                        renderOrder: i.renderOrder,
                                        z: s,
                                        group: c
                                    },
                                    t[e] = h) : (h.id = i.id,
                                    h.object = i,
                                    h.geometry = o,
                                    h.material = a,
                                    h.program = a.program,
                                    h.renderOrder = i.renderOrder,
                                    h.z = s,
                                    h.group = c),
                                    (!0 === a.transparent ? r : n).push(h),
                                    e++
                                },
                                sort: function() {
                                    n.length > 1 && n.sort(Rr),
                                    r.length > 1 && r.sort(Pr)
                                }
                            }
                        }
                        ,
                        t[r] = i),
                        i
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }
            ,
            N = new qr,
            B = new function(t, e, n, r) {
                var i, o, a, s = new Un(0), c = 0;
                function h(t, n) {
                    e.buffers.color.setClear(t.r, t.g, t.b, n, r)
                }
                return {
                    getClearColor: function() {
                        return s
                    },
                    setClearColor: function(t, e) {
                        s.set(t),
                        h(s, c = void 0 !== e ? e : 1)
                    },
                    getClearAlpha: function() {
                        return c
                    },
                    setClearAlpha: function(t) {
                        h(s, c = t)
                    },
                    render: function(e, r, l, u) {
                        var p = r.background;
                        null === p ? h(s, c) : p && p.isColor && (h(p, 1),
                        u = !0),
                        (t.autoClear || u) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                        p && p.isCubeTexture ? (void 0 === a && ((a = new Lr(new wr(1,1,1),new Er({
                            uniforms: Fn.cube.uniforms,
                            vertexShader: Fn.cube.vertexShader,
                            fragmentShader: Fn.cube.fragmentShader,
                            side: g,
                            depthTest: !0,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.removeAttribute("normal"),
                        a.geometry.removeAttribute("uv"),
                        a.onBeforeRender = function(t, e, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }
                        ,
                        n.update(a.geometry)),
                        a.material.uniforms.tCube.value = p,
                        e.push(a, a.geometry, a.material, 0, null)) : p && p.isTexture && (void 0 === i && (i = new er(-1,1,1,-1,0,1),
                        o = new Lr(new Mr(2,2),new _r({
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })),
                        n.update(o.geometry)),
                        o.material.map = p,
                        t.renderBufferDirect(i, null, o.geometry, o.material, o, null))
                    }
                }
            }
            (V,M,I,u),
            F = new function(t, e, n) {
                var r;
                this.setMode = function(t) {
                    r = t
                }
                ,
                this.render = function(e, i) {
                    t.drawArrays(r, e, i),
                    n.calls++,
                    n.vertices += i,
                    r === t.TRIANGLES ? n.faces += i / 3 : r === t.POINTS && (n.points += i)
                }
                ,
                this.renderInstances = function(i, o, a) {
                    var s = e.get("ANGLE_instanced_arrays");
                    if (null !== s) {
                        var c = i.attributes.position;
                        c.isInterleavedBufferAttribute ? (a = c.data.count,
                        s.drawArraysInstancedANGLE(r, 0, a, i.maxInstancedCount)) : s.drawArraysInstancedANGLE(r, o, a, i.maxInstancedCount),
                        n.calls++,
                        n.vertices += a * i.maxInstancedCount,
                        r === t.TRIANGLES ? n.faces += i.maxInstancedCount * a / 3 : r === t.POINTS && (n.points += i.maxInstancedCount * a)
                    } else
                        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                }
            }
            (y,x,_t),
            k = new function(t, e, n) {
                var r, i, o;
                this.setMode = function(t) {
                    r = t
                }
                ,
                this.setIndex = function(t) {
                    i = t.type,
                    o = t.bytesPerElement
                }
                ,
                this.render = function(e, a) {
                    t.drawElements(r, a, i, e * o),
                    n.calls++,
                    n.vertices += a,
                    r === t.TRIANGLES ? n.faces += a / 3 : r === t.POINTS && (n.points += a)
                }
                ,
                this.renderInstances = function(a, s, c) {
                    var h = e.get("ANGLE_instanced_arrays");
                    null !== h ? (h.drawElementsInstancedANGLE(r, c, i, s * o, a.maxInstancedCount),
                    n.calls++,
                    n.vertices += c * a.maxInstancedCount,
                    r === t.TRIANGLES ? n.faces += a.maxInstancedCount * c / 3 : r === t.POINTS && (n.points += a.maxInstancedCount * c)) : console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                }
            }
            (y,x,_t),
            H = new function(t, e, n, r, i) {
                var o, a, s, c, h, l, u = new Fe, p = new ze, d = new Fe;
                function f() {
                    var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1])
                      , n = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    o = e.createBuffer(),
                    a = e.createBuffer(),
                    e.bindBuffer(e.ARRAY_BUFFER, o),
                    e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW),
                    e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, a),
                    e.bufferData(e.ELEMENT_ARRAY_BUFFER, n, e.STATIC_DRAW),
                    s = function() {
                        var t = e.createProgram()
                          , n = e.createShader(e.VERTEX_SHADER)
                          , r = e.createShader(e.FRAGMENT_SHADER);
                        return e.shaderSource(n, ["precision " + i.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 center;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvUV = uvOffset + uv * uvScale;", "\tvec2 alignedPosition = ( position - center ) * scale;", "\tvec2 rotatedPosition;", "\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "\tvec4 mvPosition;", "\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "\tmvPosition.xy += rotatedPosition;", "\tgl_Position = projectionMatrix * mvPosition;", "\tfogDepth = - mvPosition.z;", "}"].join("\n")),
                        e.shaderSource(r, ["precision " + i.precision + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "varying float fogDepth;", "void main() {", "\tvec4 texture = texture2D( map, vUV );", "\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "\tif ( gl_FragColor.a < alphaTest ) discard;", "\tif ( fogType > 0 ) {", "\t\tfloat fogFactor = 0.0;", "\t\tif ( fogType == 1 ) {", "\t\t\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );", "\t\t} else {", "\t\t\tconst float LOG2 = 1.442695;", "\t\t\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );", "\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "\t\t}", "\t\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );", "\t}", "}"].join("\n")),
                        e.compileShader(n),
                        e.compileShader(r),
                        e.attachShader(t, n),
                        e.attachShader(t, r),
                        e.linkProgram(t),
                        t
                    }(),
                    c = {
                        position: e.getAttribLocation(s, "position"),
                        uv: e.getAttribLocation(s, "uv")
                    },
                    h = {
                        uvOffset: e.getUniformLocation(s, "uvOffset"),
                        uvScale: e.getUniformLocation(s, "uvScale"),
                        rotation: e.getUniformLocation(s, "rotation"),
                        center: e.getUniformLocation(s, "center"),
                        scale: e.getUniformLocation(s, "scale"),
                        color: e.getUniformLocation(s, "color"),
                        map: e.getUniformLocation(s, "map"),
                        opacity: e.getUniformLocation(s, "opacity"),
                        modelViewMatrix: e.getUniformLocation(s, "modelViewMatrix"),
                        projectionMatrix: e.getUniformLocation(s, "projectionMatrix"),
                        fogType: e.getUniformLocation(s, "fogType"),
                        fogDensity: e.getUniformLocation(s, "fogDensity"),
                        fogNear: e.getUniformLocation(s, "fogNear"),
                        fogFar: e.getUniformLocation(s, "fogFar"),
                        fogColor: e.getUniformLocation(s, "fogColor"),
                        fogDepth: e.getUniformLocation(s, "fogDepth"),
                        alphaTest: e.getUniformLocation(s, "alphaTest")
                    };
                    var r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    r.width = 8,
                    r.height = 8;
                    var u = r.getContext("2d");
                    u.fillStyle = "white",
                    u.fillRect(0, 0, 8, 8),
                    l = new kn(r)
                }
                function m(t, e) {
                    return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
                }
                this.render = function(i, g, v) {
                    if (0 !== i.length) {
                        void 0 === s && f(),
                        n.useProgram(s),
                        n.initAttributes(),
                        n.enableAttribute(c.position),
                        n.enableAttribute(c.uv),
                        n.disableUnusedAttributes(),
                        n.disable(e.CULL_FACE),
                        n.enable(e.BLEND),
                        e.bindBuffer(e.ARRAY_BUFFER, o),
                        e.vertexAttribPointer(c.position, 2, e.FLOAT, !1, 16, 0),
                        e.vertexAttribPointer(c.uv, 2, e.FLOAT, !1, 16, 8),
                        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, a),
                        e.uniformMatrix4fv(h.projectionMatrix, !1, v.projectionMatrix.elements),
                        n.activeTexture(e.TEXTURE0),
                        e.uniform1i(h.map, 0);
                        var y = 0
                          , x = 0
                          , w = g.fog;
                        w ? (e.uniform3f(h.fogColor, w.color.r, w.color.g, w.color.b),
                        w.isFog ? (e.uniform1f(h.fogNear, w.near),
                        e.uniform1f(h.fogFar, w.far),
                        e.uniform1i(h.fogType, 1),
                        y = 1,
                        x = 1) : w.isFogExp2 && (e.uniform1f(h.fogDensity, w.density),
                        e.uniform1i(h.fogType, 2),
                        y = 2,
                        x = 2)) : (e.uniform1i(h.fogType, 0),
                        y = 0,
                        x = 0);
                        for (var b = 0, M = i.length; b < M; b++)
                            (S = i[b]).modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, S.matrixWorld),
                            S.z = -S.modelViewMatrix.elements[14];
                        i.sort(m);
                        var _ = []
                          , E = [];
                        for (b = 0,
                        M = i.length; b < M; b++) {
                            var S, T = (S = i[b]).material;
                            if (!1 !== T.visible) {
                                S.onBeforeRender(t, g, v, void 0, T, void 0),
                                e.uniform1f(h.alphaTest, T.alphaTest),
                                e.uniformMatrix4fv(h.modelViewMatrix, !1, S.modelViewMatrix.elements),
                                S.matrixWorld.decompose(u, p, d),
                                _[0] = d.x,
                                _[1] = d.y,
                                E[0] = S.center.x - .5,
                                E[1] = S.center.y - .5;
                                var A = 0;
                                g.fog && T.fog && (A = x),
                                y !== A && (e.uniform1i(h.fogType, A),
                                y = A),
                                null !== T.map ? (e.uniform2f(h.uvOffset, T.map.offset.x, T.map.offset.y),
                                e.uniform2f(h.uvScale, T.map.repeat.x, T.map.repeat.y)) : (e.uniform2f(h.uvOffset, 0, 0),
                                e.uniform2f(h.uvScale, 1, 1)),
                                e.uniform1f(h.opacity, T.opacity),
                                e.uniform3f(h.color, T.color.r, T.color.g, T.color.b),
                                e.uniform1f(h.rotation, T.rotation),
                                e.uniform2fv(h.center, E),
                                e.uniform2fv(h.scale, _),
                                n.setBlending(T.blending, T.blendEquation, T.blendSrc, T.blendDst, T.blendEquationAlpha, T.blendSrcAlpha, T.blendDstAlpha, T.premultipliedAlpha),
                                n.buffers.depth.setTest(T.depthTest),
                                n.buffers.depth.setMask(T.depthWrite),
                                n.buffers.color.setMask(T.colorWrite),
                                r.setTexture2D(T.map || l, 0),
                                e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0),
                                S.onAfterRender(t, g, v, void 0, T, void 0)
                            }
                        }
                        n.enable(e.CULL_FACE),
                        n.reset()
                    }
                }
            }
            (V,y,M,P,b),
            V.info.programs = D.programs,
            V.context = y,
            V.capabilities = b,
            V.extensions = x,
            V.properties = R,
            V.renderLists = U,
            V.state = M
        }
        At();
        var Lt = new Wr(V);
        this.vr = Lt;
        var Rt = new Zn(V,O,b.maxTextureSize);
        function It(t) {
            t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            j = !0
        }
        function Ot() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            j = !1,
            At()
        }
        function Dt(t) {
            var e = t.target;
            e.removeEventListener("dispose", Dt),
            function(t) {
                Ut(t),
                R.remove(t)
            }(e)
        }
        function Ut(t) {
            var e = R.get(t).program;
            t.program = void 0,
            void 0 !== e && D.releaseProgram(e)
        }
        this.shadowMap = Rt,
        this.getContext = function() {
            return y
        }
        ,
        this.getContextAttributes = function() {
            return y.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var t = x.get("WEBGL_lose_context");
            t && t.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var t = x.get("WEBGL_lose_context");
            t && t.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return pt
        }
        ,
        this.setPixelRatio = function(t) {
            void 0 !== t && (pt = t,
            this.setSize(lt, ut, !1))
        }
        ,
        this.getSize = function() {
            return {
                width: lt,
                height: ut
            }
        }
        ,
        this.setSize = function(t, n, r) {
            var i = Lt.getDevice();
            i && i.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (lt = t,
            ut = n,
            e.width = t * pt,
            e.height = n * pt,
            !1 !== r && (e.style.width = t + "px",
            e.style.height = n + "px"),
            this.setViewport(0, 0, t, n))
        }
        ,
        this.getDrawingBufferSize = function() {
            return {
                width: lt * pt,
                height: ut * pt
            }
        }
        ,
        this.setDrawingBufferSize = function(t, n, r) {
            lt = t,
            ut = n,
            pt = r,
            e.width = t * r,
            e.height = n * r,
            this.setViewport(0, 0, t, n)
        }
        ,
        this.getCurrentViewport = function() {
            return at
        }
        ,
        this.setViewport = function(t, e, n, r) {
            dt.set(t, ut - e - r, n, r),
            M.viewport(at.copy(dt).multiplyScalar(pt))
        }
        ,
        this.setScissor = function(t, e, n, r) {
            ft.set(t, ut - e - r, n, r),
            M.scissor(st.copy(ft).multiplyScalar(pt))
        }
        ,
        this.setScissorTest = function(t) {
            M.setScissorTest(mt = t)
        }
        ,
        this.getClearColor = function() {
            return B.getClearColor()
        }
        ,
        this.setClearColor = function() {
            B.setClearColor.apply(B, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return B.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            B.setClearAlpha.apply(B, arguments)
        }
        ,
        this.clear = function(t, e, n) {
            var r = 0;
            (void 0 === t || t) && (r |= y.COLOR_BUFFER_BIT),
            (void 0 === e || e) && (r |= y.DEPTH_BUFFER_BIT),
            (void 0 === n || n) && (r |= y.STENCIL_BUFFER_BIT),
            y.clear(r)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.clearTarget = function(t, e, n, r) {
            this.setRenderTarget(t),
            this.clear(e, n, r)
        }
        ,
        this.dispose = function() {
            e.removeEventListener("webglcontextlost", It, !1),
            e.removeEventListener("webglcontextrestored", Ot, !1),
            U.dispose(),
            N.dispose(),
            R.dispose(),
            O.dispose(),
            Lt.dispose(),
            Ft()
        }
        ,
        this.renderBufferImmediate = function(t, e, n) {
            M.initAttributes();
            var r = R.get(t);
            t.hasPositions && !r.position && (r.position = y.createBuffer()),
            t.hasNormals && !r.normal && (r.normal = y.createBuffer()),
            t.hasUvs && !r.uv && (r.uv = y.createBuffer()),
            t.hasColors && !r.color && (r.color = y.createBuffer());
            var i = e.getAttributes();
            if (t.hasPositions && (y.bindBuffer(y.ARRAY_BUFFER, r.position),
            y.bufferData(y.ARRAY_BUFFER, t.positionArray, y.DYNAMIC_DRAW),
            M.enableAttribute(i.position),
            y.vertexAttribPointer(i.position, 3, y.FLOAT, !1, 0, 0)),
            t.hasNormals) {
                if (y.bindBuffer(y.ARRAY_BUFFER, r.normal),
                !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && !0 === n.flatShading)
                    for (var o = 0, a = 3 * t.count; o < a; o += 9) {
                        var s = t.normalArray
                          , c = (s[o + 0] + s[o + 3] + s[o + 6]) / 3
                          , h = (s[o + 1] + s[o + 4] + s[o + 7]) / 3
                          , l = (s[o + 2] + s[o + 5] + s[o + 8]) / 3;
                        s[o + 0] = c,
                        s[o + 1] = h,
                        s[o + 2] = l,
                        s[o + 3] = c,
                        s[o + 4] = h,
                        s[o + 5] = l,
                        s[o + 6] = c,
                        s[o + 7] = h,
                        s[o + 8] = l
                    }
                y.bufferData(y.ARRAY_BUFFER, t.normalArray, y.DYNAMIC_DRAW),
                M.enableAttribute(i.normal),
                y.vertexAttribPointer(i.normal, 3, y.FLOAT, !1, 0, 0)
            }
            t.hasUvs && n.map && (y.bindBuffer(y.ARRAY_BUFFER, r.uv),
            y.bufferData(y.ARRAY_BUFFER, t.uvArray, y.DYNAMIC_DRAW),
            M.enableAttribute(i.uv),
            y.vertexAttribPointer(i.uv, 2, y.FLOAT, !1, 0, 0)),
            t.hasColors && n.vertexColors !== w && (y.bindBuffer(y.ARRAY_BUFFER, r.color),
            y.bufferData(y.ARRAY_BUFFER, t.colorArray, y.DYNAMIC_DRAW),
            M.enableAttribute(i.color),
            y.vertexAttribPointer(i.color, 3, y.FLOAT, !1, 0, 0)),
            M.disableUnusedAttributes(),
            y.drawArrays(y.TRIANGLES, 0, t.count),
            t.count = 0
        }
        ,
        this.renderBufferDirect = function(t, e, n, r, i, o) {
            var a = i.isMesh && i.matrixWorld.determinant() < 0;
            M.setMaterial(r, a);
            var s = Wt(t, e, r, i)
              , c = n.id + "_" + s.id + "_" + (!0 === r.wireframe)
              , h = !1;
            c !== nt && (nt = c,
            h = !0),
            i.morphTargetInfluences && (z.update(i, n, r, s),
            h = !0);
            var l, u = n.index, p = n.attributes.position, d = 1;
            !0 === r.wireframe && (u = I.getWireframeAttribute(n),
            d = 2);
            var f = F;
            null !== u && (l = C.get(u),
            (f = k).setIndex(l)),
            h && (function(t, e, n, r) {
                if (n && n.isInstancedBufferGeometry && null === x.get("ANGLE_instanced_arrays"))
                    console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    void 0 === r && (r = 0),
                    M.initAttributes();
                    var i = n.attributes
                      , o = e.getAttributes()
                      , a = t.defaultAttributeValues;
                    for (var s in o) {
                        var c = o[s];
                        if (c >= 0) {
                            var h = i[s];
                            if (void 0 !== h) {
                                var l = h.normalized
                                  , u = h.itemSize
                                  , p = C.get(h);
                                if (void 0 === p)
                                    continue;
                                var d = p.buffer
                                  , f = p.type
                                  , m = p.bytesPerElement;
                                if (h.isInterleavedBufferAttribute) {
                                    var g = h.data
                                      , v = g.stride
                                      , w = h.offset;
                                    g && g.isInstancedInterleavedBuffer ? (M.enableAttributeAndDivisor(c, g.meshPerAttribute),
                                    void 0 === n.maxInstancedCount && (n.maxInstancedCount = g.meshPerAttribute * g.count)) : M.enableAttribute(c),
                                    y.bindBuffer(y.ARRAY_BUFFER, d),
                                    y.vertexAttribPointer(c, u, f, l, v * m, (r * v + w) * m)
                                } else
                                    h.isInstancedBufferAttribute ? (M.enableAttributeAndDivisor(c, h.meshPerAttribute),
                                    void 0 === n.maxInstancedCount && (n.maxInstancedCount = h.meshPerAttribute * h.count)) : M.enableAttribute(c),
                                    y.bindBuffer(y.ARRAY_BUFFER, d),
                                    y.vertexAttribPointer(c, u, f, l, 0, r * u * m)
                            } else if (void 0 !== a) {
                                var b = a[s];
                                if (void 0 !== b)
                                    switch (b.length) {
                                    case 2:
                                        y.vertexAttrib2fv(c, b);
                                        break;
                                    case 3:
                                        y.vertexAttrib3fv(c, b);
                                        break;
                                    case 4:
                                        y.vertexAttrib4fv(c, b);
                                        break;
                                    default:
                                        y.vertexAttrib1fv(c, b)
                                    }
                            }
                        }
                    }
                    M.disableUnusedAttributes()
                }
            }(r, s, n),
            null !== u && y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, l.buffer));
            var m = 1 / 0;
            null !== u ? m = u.count : void 0 !== p && (m = p.count);
            var g = n.drawRange.start * d
              , v = n.drawRange.count * d
              , w = null !== o ? o.start * d : 0
              , b = null !== o ? o.count * d : 1 / 0
              , _ = Math.max(g, w)
              , E = Math.min(m, g + v, w + b) - 1
              , S = Math.max(0, E - _ + 1);
            if (0 !== S) {
                if (i.isMesh)
                    if (!0 === r.wireframe)
                        M.setLineWidth(r.wireframeLinewidth * St()),
                        f.setMode(y.LINES);
                    else
                        switch (i.drawMode) {
                        case Me:
                            f.setMode(y.TRIANGLES);
                            break;
                        case _e:
                            f.setMode(y.TRIANGLE_STRIP);
                            break;
                        case Ee:
                            f.setMode(y.TRIANGLE_FAN)
                        }
                else if (i.isLine) {
                    var T = r.linewidth;
                    void 0 === T && (T = 1),
                    M.setLineWidth(T * St()),
                    i.isLineSegments ? f.setMode(y.LINES) : i.isLineLoop ? f.setMode(y.LINE_LOOP) : f.setMode(y.LINE_STRIP)
                } else
                    i.isPoints && f.setMode(y.POINTS);
                n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && f.renderInstances(n, _, S) : f.render(_, S)
            }
        }
        ,
        this.compile = function(t, e) {
            (m = N.get(t, e)).init(),
            t.traverse(function(t) {
                t.isLight && (m.pushLight(t),
                t.castShadow && m.pushShadow(t))
            }),
            m.setupLights(e),
            t.traverse(function(e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var n = 0; n < e.material.length; n++)
                            jt(e.material[n], t.fog, e);
                    else
                        jt(e.material, t.fog, e)
            })
        }
        ;
        var Nt = !1
          , Bt = null;
        function Ft() {
            Nt = !1
        }
        function kt() {
            var t = Lt.getDevice();
            t && t.isPresenting ? t.requestAnimationFrame(Ht) : window.requestAnimationFrame(Ht)
        }
        function Ht(t) {
            !1 !== Nt && (Bt(t),
            kt())
        }
        function Gt(t, e, n, r) {
            for (var i = 0, o = t.length; i < o; i++) {
                var a = t[i]
                  , s = a.object
                  , c = a.geometry
                  , h = void 0 === r ? a.material : r
                  , l = a.group;
                if (n.isArrayCamera) {
                    ot = n;
                    for (var u = n.cameras, p = 0, d = u.length; p < d; p++) {
                        var f = u[p];
                        if (s.layers.test(f.layers)) {
                            var m = f.bounds
                              , g = m.x * lt
                              , v = m.y * ut
                              , y = m.z * lt
                              , x = m.w * ut;
                            M.viewport(at.set(g, v, y, x).multiplyScalar(pt)),
                            Vt(s, e, f, c, h, l)
                        }
                    }
                } else
                    ot = null,
                    Vt(s, e, n, c, h, l)
            }
        }
        function Vt(t, e, n, r, i, o) {
            if (t.onBeforeRender(V, e, n, r, i, o),
            m = N.get(e, ot || n),
            t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            t.isImmediateRenderObject) {
                var a = t.isMesh && t.matrixWorld.determinant() < 0;
                M.setMaterial(i, a);
                var s = Wt(n, e.fog, i, t);
                nt = "",
                function(t, e, n) {
                    t.render(function(t) {
                        V.renderBufferImmediate(t, e, n)
                    })
                }(t, s, i)
            } else
                V.renderBufferDirect(n, e.fog, r, i, t, o);
            t.onAfterRender(V, e, n, r, i, o),
            m = N.get(e, ot || n)
        }
        function jt(t, e, n) {
            var r = R.get(t)
              , i = m.state.lights
              , o = m.state.shadowsArray
              , a = D.getParameters(t, i.state, o, e, vt.numPlanes, vt.numIntersection, n)
              , s = D.getProgramCode(t, a)
              , c = r.program
              , h = !0;
            if (void 0 === c)
                t.addEventListener("dispose", Dt);
            else if (c.code !== s)
                Ut(t);
            else if (r.lightsHash !== i.state.hash)
                R.update(t, "lightsHash", i.state.hash),
                h = !1;
            else {
                if (void 0 !== a.shaderID)
                    return;
                h = !1
            }
            if (h) {
                if (a.shaderID) {
                    var l = Fn[a.shaderID];
                    r.shader = {
                        name: t.type,
                        uniforms: Bn.clone(l.uniforms),
                        vertexShader: l.vertexShader,
                        fragmentShader: l.fragmentShader
                    }
                } else
                    r.shader = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    };
                t.onBeforeCompile(r.shader),
                c = D.acquireProgram(t, r.shader, a, s),
                r.program = c,
                t.program = c
            }
            var u = c.getAttributes();
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                for (var p = 0; p < V.maxMorphTargets; p++)
                    u["morphTarget" + p] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals)
                for (t.numSupportedMorphNormals = 0,
                p = 0; p < V.maxMorphNormals; p++)
                    u["morphNormal" + p] >= 0 && t.numSupportedMorphNormals++;
            var d = r.shader.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (r.numClippingPlanes = vt.numPlanes,
            r.numIntersection = vt.numIntersection,
            d.clippingPlanes = vt.uniform),
            r.fog = e,
            r.lightsHash = i.state.hash,
            t.lights && (d.ambientLightColor.value = i.state.ambient,
            d.directionalLights.value = i.state.directional,
            d.spotLights.value = i.state.spot,
            d.rectAreaLights.value = i.state.rectArea,
            d.pointLights.value = i.state.point,
            d.hemisphereLights.value = i.state.hemi,
            d.directionalShadowMap.value = i.state.directionalShadowMap,
            d.directionalShadowMatrix.value = i.state.directionalShadowMatrix,
            d.spotShadowMap.value = i.state.spotShadowMap,
            d.spotShadowMatrix.value = i.state.spotShadowMatrix,
            d.pointShadowMap.value = i.state.pointShadowMap,
            d.pointShadowMatrix.value = i.state.pointShadowMatrix);
            var f = r.program.getUniforms()
              , g = On.seqWithValue(f.seq, d);
            r.uniformsList = g
        }
        function Wt(t, e, n, r) {
            ht = 0;
            var i = R.get(n)
              , o = m.state.lights;
            if (yt && (xt || t !== it)) {
                var a = t === it && n.id === et;
                vt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, i, a)
            }
            !1 === n.needsUpdate && (void 0 === i.program ? n.needsUpdate = !0 : n.fog && i.fog !== e ? n.needsUpdate = !0 : n.lights && i.lightsHash !== o.state.hash ? n.needsUpdate = !0 : void 0 === i.numClippingPlanes || i.numClippingPlanes === vt.numPlanes && i.numIntersection === vt.numIntersection || (n.needsUpdate = !0)),
            n.needsUpdate && (jt(n, e, r),
            n.needsUpdate = !1);
            var s = !1
              , c = !1
              , h = !1
              , l = i.program
              , u = l.getUniforms()
              , p = i.shader.uniforms;
            if (M.useProgram(l.program) && (s = !0,
            c = !0,
            h = !0),
            n.id !== et && (et = n.id,
            c = !0),
            s || t !== it) {
                if (u.setValue(y, "projectionMatrix", t.projectionMatrix),
                b.logarithmicDepthBuffer && u.setValue(y, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                it !== (ot || t) && (it = ot || t,
                c = !0,
                h = !0),
                n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                    var d = u.map.cameraPosition;
                    void 0 !== d && d.setValue(y, bt.setFromMatrixPosition(t.matrixWorld))
                }
                (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && u.setValue(y, "viewMatrix", t.matrixWorldInverse)
            }
            if (n.skinning) {
                u.setOptional(y, r, "bindMatrix"),
                u.setOptional(y, r, "bindMatrixInverse");
                var f = r.skeleton;
                if (f) {
                    var g = f.bones;
                    if (b.floatVertexTextures) {
                        if (void 0 === f.boneTexture) {
                            var v = Math.sqrt(4 * g.length);
                            v = Ue.ceilPowerOfTwo(v),
                            v = Math.max(v, 4);
                            var x = new Float32Array(v * v * 4);
                            x.set(f.boneMatrices);
                            var w = new Ye(x,v,v,zt,Pt);
                            w.needsUpdate = !0,
                            f.boneMatrices = x,
                            f.boneTexture = w,
                            f.boneTextureSize = v
                        }
                        u.setValue(y, "boneTexture", f.boneTexture),
                        u.setValue(y, "boneTextureSize", f.boneTextureSize)
                    } else
                        u.setOptional(y, f, "boneMatrices")
                }
            }
            return c && (u.setValue(y, "toneMappingExposure", V.toneMappingExposure),
            u.setValue(y, "toneMappingWhitePoint", V.toneMappingWhitePoint),
            n.lights && function(t, e) {
                t.ambientLightColor.needsUpdate = e,
                t.directionalLights.needsUpdate = e,
                t.pointLights.needsUpdate = e,
                t.spotLights.needsUpdate = e,
                t.rectAreaLights.needsUpdate = e,
                t.hemisphereLights.needsUpdate = e
            }(p, h),
            e && n.fog && function(t, e) {
                t.fogColor.value = e.color,
                e.isFog ? (t.fogNear.value = e.near,
                t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }(p, e),
            n.isMeshBasicMaterial ? Yt(p, n) : n.isMeshLambertMaterial ? (Yt(p, n),
            function(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }(p, n)) : n.isMeshPhongMaterial ? (Yt(p, n),
            n.isMeshToonMaterial ? function(t, e) {
                Xt(t, e),
                e.gradientMap && (t.gradientMap.value = e.gradientMap)
            }(p, n) : Xt(p, n)) : n.isMeshStandardMaterial ? (Yt(p, n),
            n.isMeshPhysicalMaterial ? function(t, e) {
                t.clearCoat.value = e.clearCoat,
                t.clearCoatRoughness.value = e.clearCoatRoughness,
                qt(t, e)
            }(p, n) : qt(p, n)) : n.isMeshDepthMaterial ? (Yt(p, n),
            function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                t.displacementScale.value = e.displacementScale,
                t.displacementBias.value = e.displacementBias)
            }(p, n)) : n.isMeshDistanceMaterial ? (Yt(p, n),
            function(t, e) {
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                t.displacementScale.value = e.displacementScale,
                t.displacementBias.value = e.displacementBias),
                t.referencePosition.value.copy(e.referencePosition),
                t.nearDistance.value = e.nearDistance,
                t.farDistance.value = e.farDistance
            }(p, n)) : n.isMeshNormalMaterial ? (Yt(p, n),
            function(t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap,
                t.bumpScale.value = e.bumpScale),
                e.normalMap && (t.normalMap.value = e.normalMap,
                t.normalScale.value.copy(e.normalScale)),
                e.displacementMap && (t.displacementMap.value = e.displacementMap,
                t.displacementScale.value = e.displacementScale,
                t.displacementBias.value = e.displacementBias)
            }(p, n)) : n.isLineBasicMaterial ? (function(t, e) {
                t.diffuse.value = e.color,
                t.opacity.value = e.opacity
            }(p, n),
            n.isLineDashedMaterial && function(t, e) {
                t.dashSize.value = e.dashSize,
                t.totalSize.value = e.dashSize + e.gapSize,
                t.scale.value = e.scale
            }(p, n)) : n.isPointsMaterial ? function(t, e) {
                if (t.diffuse.value = e.color,
                t.opacity.value = e.opacity,
                t.size.value = e.size * pt,
                t.scale.value = .5 * ut,
                t.map.value = e.map,
                null !== e.map) {
                    if (!0 === e.map.matrixAutoUpdate) {
                        var n = e.map.offset
                          , r = e.map.repeat
                          , i = e.map.rotation
                          , o = e.map.center;
                        e.map.matrix.setUvTransform(n.x, n.y, r.x, r.y, i, o.x, o.y)
                    }
                    t.uvTransform.value.copy(e.map.matrix)
                }
            }(p, n) : n.isShadowMaterial && (p.color.value = n.color,
            p.opacity.value = n.opacity),
            void 0 !== p.ltc_1 && (p.ltc_1.value = Nn.LTC_1),
            void 0 !== p.ltc_2 && (p.ltc_2.value = Nn.LTC_2),
            On.upload(y, i.uniformsList, p, V)),
            n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (On.upload(y, i.uniformsList, p, V),
            n.uniformsNeedUpdate = !1),
            u.setValue(y, "modelViewMatrix", r.modelViewMatrix),
            u.setValue(y, "normalMatrix", r.normalMatrix),
            u.setValue(y, "modelMatrix", r.matrixWorld),
            l
        }
        function Yt(t, e) {
            var n;
            if (t.opacity.value = e.opacity,
            e.color && (t.diffuse.value = e.color),
            e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
            e.map && (t.map.value = e.map),
            e.alphaMap && (t.alphaMap.value = e.alphaMap),
            e.specularMap && (t.specularMap.value = e.specularMap),
            e.envMap && (t.envMap.value = e.envMap,
            t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1,
            t.reflectivity.value = e.reflectivity,
            t.refractionRatio.value = e.refractionRatio),
            e.lightMap && (t.lightMap.value = e.lightMap,
            t.lightMapIntensity.value = e.lightMapIntensity),
            e.aoMap && (t.aoMap.value = e.aoMap,
            t.aoMapIntensity.value = e.aoMapIntensity),
            e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap),
            void 0 !== n) {
                if (n.isWebGLRenderTarget && (n = n.texture),
                !0 === n.matrixAutoUpdate) {
                    var r = n.offset
                      , i = n.repeat
                      , o = n.rotation
                      , a = n.center;
                    n.matrix.setUvTransform(r.x, r.y, i.x, i.y, o, a.x, a.y)
                }
                t.uvTransform.value.copy(n.matrix)
            }
        }
        function Xt(t, e) {
            t.specular.value = e.specular,
            t.shininess.value = Math.max(e.shininess, 1e-4),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap,
            t.bumpScale.value = e.bumpScale),
            e.normalMap && (t.normalMap.value = e.normalMap,
            t.normalScale.value.copy(e.normalScale)),
            e.displacementMap && (t.displacementMap.value = e.displacementMap,
            t.displacementScale.value = e.displacementScale,
            t.displacementBias.value = e.displacementBias)
        }
        function qt(t, e) {
            t.roughness.value = e.roughness,
            t.metalness.value = e.metalness,
            e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
            e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap,
            t.bumpScale.value = e.bumpScale),
            e.normalMap && (t.normalMap.value = e.normalMap,
            t.normalScale.value.copy(e.normalScale)),
            e.displacementMap && (t.displacementMap.value = e.displacementMap,
            t.displacementScale.value = e.displacementScale,
            t.displacementBias.value = e.displacementBias),
            e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
        }
        this.animate = function(t) {
            null !== (Bt = t) ? Nt || (kt(),
            Nt = !0) : Ft()
        }
        ,
        this.render = function(t, e, n, r) {
            if (e && e.isCamera) {
                if (!j) {
                    nt = "",
                    et = -1,
                    it = null,
                    !0 === t.autoUpdate && t.updateMatrixWorld(),
                    null === e.parent && e.updateMatrixWorld(),
                    Lt.enabled && (e = Lt.getCamera(e)),
                    (m = N.get(t, e)).init(),
                    t.onBeforeRender(V, t, e, n),
                    wt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                    gt.setFromMatrix(wt),
                    xt = this.localClippingEnabled,
                    yt = vt.init(this.clippingPlanes, xt, e),
                    (f = U.get(t, e)).init(),
                    function t(e, n, r) {
                        if (!1 !== e.visible) {
                            if (e.layers.test(n.layers))
                                if (e.isLight)
                                    m.pushLight(e),
                                    e.castShadow && m.pushShadow(e);
                                else if (e.isSprite)
                                    e.frustumCulled && !gt.intersectsSprite(e) || m.pushSprite(e);
                                else if (e.isImmediateRenderObject)
                                    r && bt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(wt),
                                    f.push(e, null, e.material, bt.z, null);
                                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(),
                                !e.frustumCulled || gt.intersectsObject(e))) {
                                    r && bt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(wt);
                                    var i = O.update(e)
                                      , o = e.material;
                                    if (Array.isArray(o))
                                        for (var a = i.groups, s = 0, c = a.length; s < c; s++) {
                                            var h = a[s]
                                              , l = o[h.materialIndex];
                                            l && l.visible && f.push(e, i, l, bt.z, h)
                                        }
                                    else
                                        o.visible && f.push(e, i, o, bt.z, null)
                                }
                            var u = e.children;
                            for (s = 0,
                            c = u.length; s < c; s++)
                                t(u[s], n, r)
                        }
                    }(t, e, V.sortObjects),
                    !0 === V.sortObjects && f.sort(),
                    yt && vt.beginShadows();
                    var i = m.state.shadowsArray;
                    Rt.render(i, t, e),
                    m.setupLights(e),
                    yt && vt.endShadows(),
                    this.info.autoReset && this.info.reset(),
                    void 0 === n && (n = null),
                    this.setRenderTarget(n),
                    B.render(f, t, e, r);
                    var o = f.opaque
                      , a = f.transparent;
                    if (t.overrideMaterial) {
                        var s = t.overrideMaterial;
                        o.length && Gt(o, t, e, s),
                        a.length && Gt(a, t, e, s)
                    } else
                        o.length && Gt(o, t, e),
                        a.length && Gt(a, t, e);
                    var c = m.state.spritesArray;
                    H.render(c, t, e),
                    n && P.updateRenderTargetMipmap(n),
                    M.buffers.depth.setTest(!0),
                    M.buffers.depth.setMask(!0),
                    M.buffers.color.setMask(!0),
                    M.setPolygonOffset(!1),
                    t.onAfterRender(V, t, e),
                    Lt.enabled && Lt.submitFrame(),
                    f = null,
                    m = null
                }
            } else
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }
        ,
        this.allocTextureUnit = function() {
            var t = ht;
            return t >= b.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + b.maxTextures),
            ht += 1,
            t
        }
        ,
        this.setTexture2D = function() {
            var t = !1;
            return function(e, n) {
                e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),
                t = !0),
                e = e.texture),
                P.setTexture2D(e, n)
            }
        }(),
        this.setTexture = function() {
            var t = !1;
            return function(e, n) {
                t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
                t = !0),
                P.setTexture2D(e, n)
            }
        }(),
        this.setTextureCube = function() {
            var t = !1;
            return function(e, n) {
                e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                t = !0),
                e = e.texture),
                e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? P.setTextureCube(e, n) : P.setTextureCubeDynamic(e, n)
            }
        }(),
        this.getRenderTarget = function() {
            return $
        }
        ,
        this.setRenderTarget = function(t) {
            $ = t,
            t && void 0 === R.get(t).__webglFramebuffer && P.setupRenderTarget(t);
            var e = null
              , n = !1;
            if (t) {
                var r = R.get(t).__webglFramebuffer;
                t.isWebGLRenderTargetCube ? (e = r[t.activeCubeFace],
                n = !0) : e = r,
                at.copy(t.viewport),
                st.copy(t.scissor),
                ct = t.scissorTest
            } else
                at.copy(dt).multiplyScalar(pt),
                st.copy(ft).multiplyScalar(pt),
                ct = mt;
            if (tt !== e && (y.bindFramebuffer(y.FRAMEBUFFER, e),
            tt = e),
            M.viewport(at),
            M.scissor(st),
            M.setScissorTest(ct),
            n) {
                var i = R.get(t.texture);
                y.framebufferTexture2D(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0, y.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, i.__webglTexture, t.activeMipMapLevel)
            }
        }
        ,
        this.readRenderTargetPixels = function(t, e, n, r, i, o) {
            if (t && t.isWebGLRenderTarget) {
                var a = R.get(t).__webglFramebuffer;
                if (a) {
                    var s = !1;
                    a !== tt && (y.bindFramebuffer(y.FRAMEBUFFER, a),
                    s = !0);
                    try {
                        var c = t.texture
                          , h = c.format
                          , l = c.type;
                        if (h !== zt && G.convert(h) !== y.getParameter(y.IMPLEMENTATION_COLOR_READ_FORMAT))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(l === Et || G.convert(l) === y.getParameter(y.IMPLEMENTATION_COLOR_READ_TYPE) || l === Pt && (x.get("OES_texture_float") || x.get("WEBGL_color_buffer_float")) || l === Ct && x.get("EXT_color_buffer_half_float")))
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        y.checkFramebufferStatus(y.FRAMEBUFFER) === y.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && y.readPixels(e, n, r, i, G.convert(h), G.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        s && y.bindFramebuffer(y.FRAMEBUFFER, tt)
                    }
                }
            } else
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }
        ,
        this.copyFramebufferToTexture = function(t, e, n) {
            var r = e.image.width
              , i = e.image.height
              , o = G.convert(e.format);
            this.setTexture2D(e, 0),
            y.copyTexImage2D(y.TEXTURE_2D, n || 0, o, t.x, t.y, r, i, 0)
        }
    }
    function Jr(t, e) {
        this.name = "",
        this.color = new Un(t),
        this.density = void 0 !== e ? e : 25e-5
    }
    function Kr(t, e, n) {
        this.name = "",
        this.color = new Un(t),
        this.near = void 0 !== e ? e : 1,
        this.far = void 0 !== n ? n : 1e3
    }
    function Qr() {
        $n.call(this),
        this.type = "Scene",
        this.background = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0
    }
    function $r(t) {
        Gn.call(this),
        this.type = "SpriteMaterial",
        this.color = new Un(16777215),
        this.map = null,
        this.rotation = 0,
        this.fog = !1,
        this.lights = !1,
        this.setValues(t)
    }
    function ti(t) {
        $n.call(this),
        this.type = "Sprite",
        this.material = void 0 !== t ? t : new $r,
        this.center = new Ne(.5,.5)
    }
    function ei() {
        $n.call(this),
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }
    function ni(t, e) {
        if (t = t || [],
        this.bones = t.slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        void 0 === e)
            this.calculateInverses();
        else if (this.bones.length === e.length)
            this.boneInverses = e.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."),
            this.boneInverses = [];
            for (var n = 0, r = this.bones.length; n < r; n++)
                this.boneInverses.push(new Be)
        }
    }
    function ri() {
        $n.call(this),
        this.type = "Bone"
    }
    function ii(t, e) {
        Lr.call(this, t, e),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Be,
        this.bindMatrixInverse = new Be;
        var n = new ni(this.initBones());
        this.bind(n, this.matrixWorld),
        this.normalizeSkinWeights()
    }
    function oi(t) {
        Gn.call(this),
        this.type = "LineBasicMaterial",
        this.color = new Un(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.lights = !1,
        this.setValues(t)
    }
    function ai(t, e, n) {
        if (1 === n)
            return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
            new si(t,e);
        $n.call(this),
        this.type = "Line",
        this.geometry = void 0 !== t ? t : new yr,
        this.material = void 0 !== e ? e : new oi({
            color: 16777215 * Math.random()
        })
    }
    function si(t, e) {
        ai.call(this, t, e),
        this.type = "LineSegments"
    }
    function ci(t, e) {
        ai.call(this, t, e),
        this.type = "LineLoop"
    }
    function hi(t) {
        Gn.call(this),
        this.type = "PointsMaterial",
        this.color = new Un(16777215),
        this.map = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.lights = !1,
        this.setValues(t)
    }
    function li(t, e) {
        $n.call(this),
        this.type = "Points",
        this.geometry = void 0 !== t ? t : new yr,
        this.material = void 0 !== e ? e : new hi({
            color: 16777215 * Math.random()
        })
    }
    function ui() {
        $n.call(this),
        this.type = "Group"
    }
    function pi(t, e, n, r, i, o, a, s, c) {
        Ge.call(this, t, e, n, r, i, o, a, s, c),
        this.generateMipmaps = !1
    }
    function di(t, e, n, r, i, o, a, s, c, h, l, u) {
        Ge.call(this, null, o, a, s, c, h, r, i, l, u),
        this.image = {
            width: e,
            height: n
        },
        this.mipmaps = t,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function fi(t, e, n, r, i, o, a, s, c, h) {
        if ((h = void 0 !== h ? h : Gt) !== Gt && h !== Vt)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && h === Gt && (n = At),
        void 0 === n && h === Vt && (n = Ut),
        Ge.call(this, null, r, i, o, a, s, h, n, c),
        this.image = {
            width: t,
            height: e
        },
        this.magFilter = void 0 !== a ? a : yt,
        this.minFilter = void 0 !== s ? s : yt,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function mi(t) {
        yr.call(this),
        this.type = "WireframeGeometry";
        var e, n, r, i, o, a, s, c, h, l, u = [], p = [0, 0], d = {}, f = ["a", "b", "c"];
        if (t && t.isGeometry) {
            var m = t.faces;
            for (e = 0,
            r = m.length; e < r; e++) {
                var g = m[e];
                for (n = 0; n < 3; n++)
                    s = g[f[n]],
                    c = g[f[(n + 1) % 3]],
                    p[0] = Math.min(s, c),
                    p[1] = Math.max(s, c),
                    void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
                        index1: p[0],
                        index2: p[1]
                    })
            }
            for (h in d)
                a = d[h],
                l = t.vertices[a.index1],
                u.push(l.x, l.y, l.z),
                l = t.vertices[a.index2],
                u.push(l.x, l.y, l.z)
        } else if (t && t.isBufferGeometry) {
            var v, y, x, w, b, M, _;
            if (l = new Fe,
            null !== t.index) {
                for (v = t.attributes.position,
                y = t.index,
                0 === (x = t.groups).length && (x = [{
                    start: 0,
                    count: y.count,
                    materialIndex: 0
                }]),
                i = 0,
                o = x.length; i < o; ++i)
                    for (e = b = (w = x[i]).start,
                    r = b + w.count; e < r; e += 3)
                        for (n = 0; n < 3; n++)
                            s = y.getX(e + n),
                            c = y.getX(e + (n + 1) % 3),
                            p[0] = Math.min(s, c),
                            p[1] = Math.max(s, c),
                            void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
                                index1: p[0],
                                index2: p[1]
                            });
                for (h in d)
                    a = d[h],
                    l.fromBufferAttribute(v, a.index1),
                    u.push(l.x, l.y, l.z),
                    l.fromBufferAttribute(v, a.index2),
                    u.push(l.x, l.y, l.z)
            } else
                for (e = 0,
                r = (v = t.attributes.position).count / 3; e < r; e++)
                    for (n = 0; n < 3; n++)
                        M = 3 * e + n,
                        l.fromBufferAttribute(v, M),
                        u.push(l.x, l.y, l.z),
                        _ = 3 * e + (n + 1) % 3,
                        l.fromBufferAttribute(v, _),
                        u.push(l.x, l.y, l.z)
        }
        this.addAttribute("position", new dr(u,3))
    }
    function gi(t, e, n) {
        ir.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: t,
            slices: e,
            stacks: n
        },
        this.fromBufferGeometry(new vi(t,e,n)),
        this.mergeVertices()
    }
    function vi(t, e, n) {
        yr.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: t,
            slices: e,
            stacks: n
        };
        var r, i, o = [], a = [], s = [], c = [], h = new Fe, l = new Fe, u = new Fe, p = new Fe, d = new Fe, f = e + 1;
        for (r = 0; r <= n; r++) {
            var m = r / n;
            for (i = 0; i <= e; i++) {
                var g = i / e;
                l = t(g, m, l),
                a.push(l.x, l.y, l.z),
                g - 1e-5 >= 0 ? (u = t(g - 1e-5, m, u),
                p.subVectors(l, u)) : (u = t(g + 1e-5, m, u),
                p.subVectors(u, l)),
                m - 1e-5 >= 0 ? (u = t(g, m - 1e-5, u),
                d.subVectors(l, u)) : (u = t(g, m + 1e-5, u),
                d.subVectors(u, l)),
                h.crossVectors(p, d).normalize(),
                s.push(h.x, h.y, h.z),
                c.push(g, m)
            }
        }
        for (r = 0; r < n; r++)
            for (i = 0; i < e; i++) {
                var v = r * f + i
                  , y = r * f + i + 1
                  , x = (r + 1) * f + i + 1
                  , w = (r + 1) * f + i;
                o.push(v, y, w),
                o.push(y, x, w)
            }
        this.setIndex(o),
        this.addAttribute("position", new dr(a,3)),
        this.addAttribute("normal", new dr(s,3)),
        this.addAttribute("uv", new dr(c,2))
    }
    function yi(t, e, n, r) {
        ir.call(this),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: r
        },
        this.fromBufferGeometry(new xi(t,e,n,r)),
        this.mergeVertices()
    }
    function xi(t, e, n, r) {
        yr.call(this),
        this.type = "PolyhedronBufferGeometry",
        this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: r
        },
        n = n || 1;
        var i = []
          , o = [];
        function a(t, e, n, r) {
            var i, o, a = Math.pow(2, r), c = [];
            for (i = 0; i <= a; i++) {
                c[i] = [];
                var h = t.clone().lerp(n, i / a)
                  , l = e.clone().lerp(n, i / a)
                  , u = a - i;
                for (o = 0; o <= u; o++)
                    c[i][o] = 0 === o && i === a ? h : h.clone().lerp(l, o / u)
            }
            for (i = 0; i < a; i++)
                for (o = 0; o < 2 * (a - i) - 1; o++) {
                    var p = Math.floor(o / 2);
                    o % 2 == 0 ? (s(c[i][p + 1]),
                    s(c[i + 1][p]),
                    s(c[i][p])) : (s(c[i][p + 1]),
                    s(c[i + 1][p + 1]),
                    s(c[i + 1][p]))
                }
        }
        function s(t) {
            i.push(t.x, t.y, t.z)
        }
        function c(e, n) {
            var r = 3 * e;
            n.x = t[r + 0],
            n.y = t[r + 1],
            n.z = t[r + 2]
        }
        function h(t, e, n, r) {
            r < 0 && 1 === t.x && (o[e] = t.x - 1),
            0 === n.x && 0 === n.z && (o[e] = r / 2 / Math.PI + .5)
        }
        function l(t) {
            return Math.atan2(t.z, -t.x)
        }
        function u(t) {
            return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
        }
        !function(t) {
            for (var n = new Fe, r = new Fe, i = new Fe, o = 0; o < e.length; o += 3)
                c(e[o + 0], n),
                c(e[o + 1], r),
                c(e[o + 2], i),
                a(n, r, i, t)
        }(r = r || 0),
        function(t) {
            for (var e = new Fe, n = 0; n < i.length; n += 3)
                e.x = i[n + 0],
                e.y = i[n + 1],
                e.z = i[n + 2],
                e.normalize().multiplyScalar(t),
                i[n + 0] = e.x,
                i[n + 1] = e.y,
                i[n + 2] = e.z
        }(n),
        function() {
            for (var t = new Fe, e = 0; e < i.length; e += 3) {
                t.x = i[e + 0],
                t.y = i[e + 1],
                t.z = i[e + 2];
                var n = l(t) / 2 / Math.PI + .5
                  , r = u(t) / Math.PI + .5;
                o.push(n, 1 - r)
            }
            (function() {
                for (var t = new Fe, e = new Fe, n = new Fe, r = new Fe, a = new Ne, s = new Ne, c = new Ne, u = 0, p = 0; u < i.length; u += 9,
                p += 6) {
                    t.set(i[u + 0], i[u + 1], i[u + 2]),
                    e.set(i[u + 3], i[u + 4], i[u + 5]),
                    n.set(i[u + 6], i[u + 7], i[u + 8]),
                    a.set(o[p + 0], o[p + 1]),
                    s.set(o[p + 2], o[p + 3]),
                    c.set(o[p + 4], o[p + 5]),
                    r.copy(t).add(e).add(n).divideScalar(3);
                    var d = l(r);
                    h(a, p + 0, t, d),
                    h(s, p + 2, e, d),
                    h(c, p + 4, n, d)
                }
            }
            )(),
            function() {
                for (var t = 0; t < o.length; t += 6) {
                    var e = o[t + 0]
                      , n = o[t + 2]
                      , r = o[t + 4]
                      , i = Math.max(e, n, r)
                      , a = Math.min(e, n, r);
                    i > .9 && a < .1 && (e < .2 && (o[t + 0] += 1),
                    n < .2 && (o[t + 2] += 1),
                    r < .2 && (o[t + 4] += 1))
                }
            }()
        }(),
        this.addAttribute("position", new dr(i,3)),
        this.addAttribute("normal", new dr(i.slice(),3)),
        this.addAttribute("uv", new dr(o,2)),
        0 === r ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function wi(t, e) {
        ir.call(this),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new bi(t,e)),
        this.mergeVertices()
    }
    function bi(t, e) {
        xi.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e),
        this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Mi(t, e) {
        ir.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new _i(t,e)),
        this.mergeVertices()
    }
    function _i(t, e) {
        xi.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Ei(t, e) {
        ir.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new Si(t,e)),
        this.mergeVertices()
    }
    function Si(t, e) {
        var n = (1 + Math.sqrt(5)) / 2
          , r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
        xi.call(this, r, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Ti(t, e) {
        ir.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new Ai(t,e)),
        this.mergeVertices()
    }
    function Ai(t, e) {
        var n = (1 + Math.sqrt(5)) / 2
          , r = 1 / n
          , i = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r];
        xi.call(this, i, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    function Li(t, e, n, r, i, o) {
        ir.call(this),
        this.type = "TubeGeometry",
        this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: r,
            closed: i
        },
        void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
        var a = new Ri(t,e,n,r,i);
        this.tangents = a.tangents,
        this.normals = a.normals,
        this.binormals = a.binormals,
        this.fromBufferGeometry(a),
        this.mergeVertices()
    }
    function Ri(t, e, n, r, i) {
        yr.call(this),
        this.type = "TubeBufferGeometry",
        this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: r,
            closed: i
        },
        e = e || 64,
        n = n || 1,
        r = r || 8,
        i = i || !1;
        var o = t.computeFrenetFrames(e, i);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        var a, s, c = new Fe, h = new Fe, l = new Ne, u = new Fe, p = [], d = [], f = [], m = [];
        function g(i) {
            u = t.getPointAt(i / e, u);
            var a = o.normals[i]
              , l = o.binormals[i];
            for (s = 0; s <= r; s++) {
                var f = s / r * Math.PI * 2
                  , m = Math.sin(f)
                  , g = -Math.cos(f);
                h.x = g * a.x + m * l.x,
                h.y = g * a.y + m * l.y,
                h.z = g * a.z + m * l.z,
                h.normalize(),
                d.push(h.x, h.y, h.z),
                c.x = u.x + n * h.x,
                c.y = u.y + n * h.y,
                c.z = u.z + n * h.z,
                p.push(c.x, c.y, c.z)
            }
        }
        !function() {
            for (a = 0; a < e; a++)
                g(a);
            g(!1 === i ? e : 0),
            function() {
                for (a = 0; a <= e; a++)
                    for (s = 0; s <= r; s++)
                        l.x = a / e,
                        l.y = s / r,
                        f.push(l.x, l.y)
            }(),
            function() {
                for (s = 1; s <= e; s++)
                    for (a = 1; a <= r; a++) {
                        var t = (r + 1) * (s - 1) + (a - 1)
                          , n = (r + 1) * s + (a - 1)
                          , i = (r + 1) * s + a
                          , o = (r + 1) * (s - 1) + a;
                        m.push(t, n, o),
                        m.push(n, i, o)
                    }
            }()
        }(),
        this.setIndex(m),
        this.addAttribute("position", new dr(p,3)),
        this.addAttribute("normal", new dr(d,3)),
        this.addAttribute("uv", new dr(f,2))
    }
    function Pi(t, e, n, r, i, o, a) {
        ir.call(this),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: o
        },
        void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
        this.fromBufferGeometry(new Ci(t,e,n,r,i,o)),
        this.mergeVertices()
    }
    function Ci(t, e, n, r, i, o) {
        yr.call(this),
        this.type = "TorusKnotBufferGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: r,
            p: i,
            q: o
        },
        t = t || 1,
        e = e || .4,
        n = Math.floor(n) || 64,
        r = Math.floor(r) || 8,
        i = i || 2,
        o = o || 3;
        var a, s, c = [], h = [], l = [], u = [], p = new Fe, d = new Fe, f = new Fe, m = new Fe, g = new Fe, v = new Fe, y = new Fe;
        for (a = 0; a <= n; ++a) {
            var x = a / n * i * Math.PI * 2;
            for (A(x, i, o, t, f),
            A(x + .01, i, o, t, m),
            v.subVectors(m, f),
            y.addVectors(m, f),
            g.crossVectors(v, y),
            y.crossVectors(g, v),
            g.normalize(),
            y.normalize(),
            s = 0; s <= r; ++s) {
                var w = s / r * Math.PI * 2
                  , b = -e * Math.cos(w)
                  , M = e * Math.sin(w);
                p.x = f.x + (b * y.x + M * g.x),
                p.y = f.y + (b * y.y + M * g.y),
                p.z = f.z + (b * y.z + M * g.z),
                h.push(p.x, p.y, p.z),
                d.subVectors(p, f).normalize(),
                l.push(d.x, d.y, d.z),
                u.push(a / n),
                u.push(s / r)
            }
        }
        for (s = 1; s <= n; s++)
            for (a = 1; a <= r; a++) {
                var _ = (r + 1) * (s - 1) + (a - 1)
                  , E = (r + 1) * s + (a - 1)
                  , S = (r + 1) * s + a
                  , T = (r + 1) * (s - 1) + a;
                c.push(_, E, T),
                c.push(E, S, T)
            }
        function A(t, e, n, r, i) {
            var o = Math.cos(t)
              , a = Math.sin(t)
              , s = n / e * t
              , c = Math.cos(s);
            i.x = r * (2 + c) * .5 * o,
            i.y = r * (2 + c) * a * .5,
            i.z = r * Math.sin(s) * .5
        }
        this.setIndex(c),
        this.addAttribute("position", new dr(h,3)),
        this.addAttribute("normal", new dr(l,3)),
        this.addAttribute("uv", new dr(u,2))
    }
    function Ii(t, e, n, r, i) {
        ir.call(this),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        },
        this.fromBufferGeometry(new Oi(t,e,n,r,i)),
        this.mergeVertices()
    }
    function Oi(t, e, n, r, i) {
        yr.call(this),
        this.type = "TorusBufferGeometry",
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: r,
            arc: i
        },
        t = t || 1,
        e = e || .4,
        n = Math.floor(n) || 8,
        r = Math.floor(r) || 6,
        i = i || 2 * Math.PI;
        var o, a, s = [], c = [], h = [], l = [], u = new Fe, p = new Fe, d = new Fe;
        for (o = 0; o <= n; o++)
            for (a = 0; a <= r; a++) {
                var f = a / r * i
                  , m = o / n * Math.PI * 2;
                p.x = (t + e * Math.cos(m)) * Math.cos(f),
                p.y = (t + e * Math.cos(m)) * Math.sin(f),
                p.z = e * Math.sin(m),
                c.push(p.x, p.y, p.z),
                u.x = t * Math.cos(f),
                u.y = t * Math.sin(f),
                d.subVectors(p, u).normalize(),
                h.push(d.x, d.y, d.z),
                l.push(a / r),
                l.push(o / n)
            }
        for (o = 1; o <= n; o++)
            for (a = 1; a <= r; a++) {
                var g = (r + 1) * o + a - 1
                  , v = (r + 1) * (o - 1) + a - 1
                  , y = (r + 1) * (o - 1) + a
                  , x = (r + 1) * o + a;
                s.push(g, v, x),
                s.push(v, y, x)
            }
        this.setIndex(s),
        this.addAttribute("position", new dr(c,3)),
        this.addAttribute("normal", new dr(h,3)),
        this.addAttribute("uv", new dr(l,2))
    }
    Jr.prototype.isFogExp2 = !0,
    Jr.prototype.clone = function() {
        return new Jr(this.color.getHex(),this.density)
    }
    ,
    Jr.prototype.toJSON = function() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
    ,
    Kr.prototype.isFog = !0,
    Kr.prototype.clone = function() {
        return new Kr(this.color.getHex(),this.near,this.far)
    }
    ,
    Kr.prototype.toJSON = function() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
    ,
    Qr.prototype = Object.assign(Object.create($n.prototype), {
        constructor: Qr,
        copy: function(t, e) {
            return $n.prototype.copy.call(this, t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            this.autoUpdate = t.autoUpdate,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this
        },
        toJSON: function(t) {
            var e = $n.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
        }
    }),
    $r.prototype = Object.create(Gn.prototype),
    $r.prototype.constructor = $r,
    $r.prototype.isSpriteMaterial = !0,
    $r.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.rotation = t.rotation,
        this
    }
    ,
    ti.prototype = Object.assign(Object.create($n.prototype), {
        constructor: ti,
        isSprite: !0,
        raycast: function() {
            var t = new Fe
              , e = new Fe
              , n = new Fe;
            return function(r, i) {
                e.setFromMatrixPosition(this.matrixWorld),
                r.ray.closestPointToPoint(e, t),
                n.setFromMatrixScale(this.matrixWorld);
                var o = n.x * n.y / 4;
                if (!(e.distanceToSquared(t) > o)) {
                    var a = r.ray.origin.distanceTo(t);
                    a < r.near || a > r.far || i.push({
                        distance: a,
                        point: t.clone(),
                        face: null,
                        object: this
                    })
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(t) {
            return $n.prototype.copy.call(this, t),
            void 0 !== t.center && this.center.copy(t.center),
            this
        }
    }),
    ei.prototype = Object.assign(Object.create($n.prototype), {
        constructor: ei,
        copy: function(t) {
            $n.prototype.copy.call(this, t, !1);
            for (var e = t.levels, n = 0, r = e.length; n < r; n++) {
                var i = e[n];
                this.addLevel(i.object.clone(), i.distance)
            }
            return this
        },
        addLevel: function(t, e) {
            void 0 === e && (e = 0),
            e = Math.abs(e);
            for (var n = this.levels, r = 0; r < n.length && !(e < n[r].distance); r++)
                ;
            n.splice(r, 0, {
                distance: e,
                object: t
            }),
            this.add(t)
        },
        getObjectForDistance: function(t) {
            for (var e = this.levels, n = 1, r = e.length; n < r && !(t < e[n].distance); n++)
                ;
            return e[n - 1].object
        },
        raycast: function() {
            var t = new Fe;
            return function(e, n) {
                t.setFromMatrixPosition(this.matrixWorld);
                var r = e.ray.origin.distanceTo(t);
                this.getObjectForDistance(r).raycast(e, n)
            }
        }(),
        update: function() {
            var t = new Fe
              , e = new Fe;
            return function(n) {
                var r = this.levels;
                if (r.length > 1) {
                    t.setFromMatrixPosition(n.matrixWorld),
                    e.setFromMatrixPosition(this.matrixWorld);
                    var i = t.distanceTo(e);
                    r[0].object.visible = !0;
                    for (var o = 1, a = r.length; o < a && i >= r[o].distance; o++)
                        r[o - 1].object.visible = !1,
                        r[o].object.visible = !0;
                    for (; o < a; o++)
                        r[o].object.visible = !1
                }
            }
        }(),
        toJSON: function(t) {
            var e = $n.prototype.toJSON.call(this, t);
            e.object.levels = [];
            for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                var o = n[r];
                e.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance
                })
            }
            return e
        }
    }),
    Object.assign(ni.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var n = new Be;
                this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
                this.boneInverses.push(n)
            }
        },
        pose: function() {
            var t, e, n;
            for (e = 0,
            n = this.bones.length; e < n; e++)
                (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (e = 0,
            n = this.bones.length; e < n; e++)
                (t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld),
                t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                t.matrix.decompose(t.position, t.quaternion, t.scale))
        },
        update: function() {
            var t = new Be
              , e = new Be;
            return function() {
                for (var n = this.bones, r = this.boneInverses, i = this.boneMatrices, o = this.boneTexture, a = 0, s = n.length; a < s; a++) {
                    var c = n[a] ? n[a].matrixWorld : e;
                    t.multiplyMatrices(c, r[a]),
                    t.toArray(i, 16 * a)
                }
                void 0 !== o && (o.needsUpdate = !0)
            }
        }(),
        clone: function() {
            return new ni(this.bones,this.boneInverses)
        },
        getBoneByName: function(t) {
            for (var e = 0, n = this.bones.length; e < n; e++) {
                var r = this.bones[e];
                if (r.name === t)
                    return r
            }
        }
    }),
    ri.prototype = Object.assign(Object.create($n.prototype), {
        constructor: ri,
        isBone: !0
    }),
    ii.prototype = Object.assign(Object.create(Lr.prototype), {
        constructor: ii,
        isSkinnedMesh: !0,
        initBones: function() {
            var t, e, n, r, i = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (n = 0,
                r = this.geometry.bones.length; n < r; n++)
                    e = this.geometry.bones[n],
                    t = new ri,
                    i.push(t),
                    t.name = e.name,
                    t.position.fromArray(e.pos),
                    t.quaternion.fromArray(e.rotq),
                    void 0 !== e.scl && t.scale.fromArray(e.scl);
                for (n = 0,
                r = this.geometry.bones.length; n < r; n++)
                    -1 !== (e = this.geometry.bones[n]).parent && null !== e.parent && void 0 !== i[e.parent] ? i[e.parent].add(i[n]) : this.add(i[n])
            }
            return this.updateMatrixWorld(!0),
            i
        },
        bind: function(t, e) {
            this.skeleton = t,
            void 0 === e && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            e = this.matrixWorld),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            var t, e;
            if (this.geometry && this.geometry.isGeometry)
                for (e = 0; e < this.geometry.skinWeights.length; e++) {
                    var n = this.geometry.skinWeights[e];
                    (t = 1 / n.manhattanLength()) != 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0)
                }
            else if (this.geometry && this.geometry.isBufferGeometry) {
                var r = new Ve
                  , i = this.geometry.attributes.skinWeight;
                for (e = 0; e < i.count; e++)
                    r.x = i.getX(e),
                    r.y = i.getY(e),
                    r.z = i.getZ(e),
                    r.w = i.getW(e),
                    (t = 1 / r.manhattanLength()) != 1 / 0 ? r.multiplyScalar(t) : r.set(1, 0, 0, 0),
                    i.setXYZW(e, r.x, r.y, r.z, r.w)
            }
        },
        updateMatrixWorld: function(t) {
            Lr.prototype.updateMatrixWorld.call(this, t),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    oi.prototype = Object.create(Gn.prototype),
    oi.prototype.constructor = oi,
    oi.prototype.isLineBasicMaterial = !0,
    oi.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.linewidth = t.linewidth,
        this.linecap = t.linecap,
        this.linejoin = t.linejoin,
        this
    }
    ,
    ai.prototype = Object.assign(Object.create($n.prototype), {
        constructor: ai,
        isLine: !0,
        computeLineDistances: function() {
            var t = new Fe
              , e = new Fe;
            return function() {
                var n = this.geometry;
                if (n.isBufferGeometry)
                    if (null === n.index) {
                        for (var r = n.attributes.position, i = [0], o = 1, a = r.count; o < a; o++)
                            t.fromBufferAttribute(r, o - 1),
                            e.fromBufferAttribute(r, o),
                            i[o] = i[o - 1],
                            i[o] += t.distanceTo(e);
                        n.addAttribute("lineDistance", new THREE.Float32BufferAttribute(i,1))
                    } else
                        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (n.isGeometry) {
                    var s = n.vertices;
                    for ((i = n.lineDistances)[0] = 0,
                    o = 1,
                    a = s.length; o < a; o++)
                        i[o] = i[o - 1],
                        i[o] += s[o - 1].distanceTo(s[o])
                }
                return this
            }
        }(),
        raycast: function() {
            var t = new Be
              , e = new Sr
              , n = new Yn;
            return function(r, i) {
                var o = r.linePrecision
                  , a = o * o
                  , s = this.geometry
                  , c = this.matrixWorld;
                if (null === s.boundingSphere && s.computeBoundingSphere(),
                n.copy(s.boundingSphere),
                n.applyMatrix4(c),
                !1 !== r.ray.intersectsSphere(n)) {
                    t.getInverse(c),
                    e.copy(r.ray).applyMatrix4(t);
                    var h = new Fe
                      , l = new Fe
                      , u = new Fe
                      , p = new Fe
                      , d = this && this.isLineSegments ? 2 : 1;
                    if (s.isBufferGeometry) {
                        var f = s.index
                          , m = s.attributes.position.array;
                        if (null !== f)
                            for (var g = f.array, v = 0, y = g.length - 1; v < y; v += d) {
                                var x = g[v]
                                  , w = g[v + 1];
                                h.fromArray(m, 3 * x),
                                l.fromArray(m, 3 * w),
                                e.distanceSqToSegment(h, l, p, u) > a || (p.applyMatrix4(this.matrixWorld),
                                (_ = r.ray.origin.distanceTo(p)) < r.near || _ > r.far || i.push({
                                    distance: _,
                                    point: u.clone().applyMatrix4(this.matrixWorld),
                                    index: v,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        else
                            for (v = 0,
                            y = m.length / 3 - 1; v < y; v += d)
                                h.fromArray(m, 3 * v),
                                l.fromArray(m, 3 * v + 3),
                                e.distanceSqToSegment(h, l, p, u) > a || (p.applyMatrix4(this.matrixWorld),
                                (_ = r.ray.origin.distanceTo(p)) < r.near || _ > r.far || i.push({
                                    distance: _,
                                    point: u.clone().applyMatrix4(this.matrixWorld),
                                    index: v,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                    } else if (s.isGeometry) {
                        var b = s.vertices
                          , M = b.length;
                        for (v = 0; v < M - 1; v += d) {
                            var _;
                            e.distanceSqToSegment(b[v], b[v + 1], p, u) > a || (p.applyMatrix4(this.matrixWorld),
                            (_ = r.ray.origin.distanceTo(p)) < r.near || _ > r.far || i.push({
                                distance: _,
                                point: u.clone().applyMatrix4(this.matrixWorld),
                                index: v,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                        }
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    si.prototype = Object.assign(Object.create(ai.prototype), {
        constructor: si,
        isLineSegments: !0,
        computeLineDistances: function() {
            var t = new Fe
              , e = new Fe;
            return function() {
                var n = this.geometry;
                if (n.isBufferGeometry)
                    if (null === n.index) {
                        for (var r = n.attributes.position, i = [], o = 0, a = r.count; o < a; o += 2)
                            t.fromBufferAttribute(r, o),
                            e.fromBufferAttribute(r, o + 1),
                            i[o] = 0 === o ? 0 : i[o - 1],
                            i[o + 1] = i[o] + t.distanceTo(e);
                        n.addAttribute("lineDistance", new THREE.Float32BufferAttribute(i,1))
                    } else
                        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                else if (n.isGeometry) {
                    var s = n.vertices;
                    for (i = n.lineDistances,
                    o = 0,
                    a = s.length; o < a; o += 2)
                        t.copy(s[o]),
                        e.copy(s[o + 1]),
                        i[o] = 0 === o ? 0 : i[o - 1],
                        i[o + 1] = i[o] + t.distanceTo(e)
                }
                return this
            }
        }()
    }),
    ci.prototype = Object.assign(Object.create(ai.prototype), {
        constructor: ci,
        isLineLoop: !0
    }),
    hi.prototype = Object.create(Gn.prototype),
    hi.prototype.constructor = hi,
    hi.prototype.isPointsMaterial = !0,
    hi.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.size = t.size,
        this.sizeAttenuation = t.sizeAttenuation,
        this
    }
    ,
    li.prototype = Object.assign(Object.create($n.prototype), {
        constructor: li,
        isPoints: !0,
        raycast: function() {
            var t = new Be
              , e = new Sr
              , n = new Yn;
            return function(r, i) {
                var o = this
                  , a = this.geometry
                  , s = this.matrixWorld
                  , c = r.params.Points.threshold;
                if (null === a.boundingSphere && a.computeBoundingSphere(),
                n.copy(a.boundingSphere),
                n.applyMatrix4(s),
                n.radius += c,
                !1 !== r.ray.intersectsSphere(n)) {
                    t.getInverse(s),
                    e.copy(r.ray).applyMatrix4(t);
                    var h = c / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , l = h * h
                      , u = new Fe;
                    if (a.isBufferGeometry) {
                        var p = a.index
                          , d = a.attributes.position.array;
                        if (null !== p)
                            for (var f = p.array, m = 0, g = f.length; m < g; m++) {
                                var v = f[m];
                                u.fromArray(d, 3 * v),
                                w(u, v)
                            }
                        else {
                            m = 0;
                            for (var y = d.length / 3; m < y; m++)
                                u.fromArray(d, 3 * m),
                                w(u, m)
                        }
                    } else {
                        var x = a.vertices;
                        for (m = 0,
                        y = x.length; m < y; m++)
                            w(x[m], m)
                    }
                }
                function w(t, n) {
                    var a = e.distanceSqToPoint(t);
                    if (a < l) {
                        var c = e.closestPointToPoint(t);
                        c.applyMatrix4(s);
                        var h = r.ray.origin.distanceTo(c);
                        if (h < r.near || h > r.far)
                            return;
                        i.push({
                            distance: h,
                            distanceToRay: Math.sqrt(a),
                            point: c.clone(),
                            index: n,
                            face: null,
                            object: o
                        })
                    }
                }
            }
        }(),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    ui.prototype = Object.assign(Object.create($n.prototype), {
        constructor: ui,
        isGroup: !0
    }),
    pi.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: pi,
        isVideoTexture: !0,
        update: function() {
            var t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    di.prototype = Object.create(Ge.prototype),
    di.prototype.constructor = di,
    di.prototype.isCompressedTexture = !0,
    fi.prototype = Object.create(Ge.prototype),
    fi.prototype.constructor = fi,
    fi.prototype.isDepthTexture = !0,
    mi.prototype = Object.create(yr.prototype),
    mi.prototype.constructor = mi,
    gi.prototype = Object.create(ir.prototype),
    gi.prototype.constructor = gi,
    vi.prototype = Object.create(yr.prototype),
    vi.prototype.constructor = vi,
    yi.prototype = Object.create(ir.prototype),
    yi.prototype.constructor = yi,
    xi.prototype = Object.create(yr.prototype),
    xi.prototype.constructor = xi,
    wi.prototype = Object.create(ir.prototype),
    wi.prototype.constructor = wi,
    bi.prototype = Object.create(xi.prototype),
    bi.prototype.constructor = bi,
    Mi.prototype = Object.create(ir.prototype),
    Mi.prototype.constructor = Mi,
    _i.prototype = Object.create(xi.prototype),
    _i.prototype.constructor = _i,
    Ei.prototype = Object.create(ir.prototype),
    Ei.prototype.constructor = Ei,
    Si.prototype = Object.create(xi.prototype),
    Si.prototype.constructor = Si,
    Ti.prototype = Object.create(ir.prototype),
    Ti.prototype.constructor = Ti,
    Ai.prototype = Object.create(xi.prototype),
    Ai.prototype.constructor = Ai,
    Li.prototype = Object.create(ir.prototype),
    Li.prototype.constructor = Li,
    Ri.prototype = Object.create(yr.prototype),
    Ri.prototype.constructor = Ri,
    Pi.prototype = Object.create(ir.prototype),
    Pi.prototype.constructor = Pi,
    Ci.prototype = Object.create(yr.prototype),
    Ci.prototype.constructor = Ci,
    Ii.prototype = Object.create(ir.prototype),
    Ii.prototype.constructor = Ii,
    Oi.prototype = Object.create(yr.prototype),
    Oi.prototype.constructor = Oi;
    function Di(t, e, n, r, i) {
        var o, a;
        if (i === function(t, e, n, r) {
            for (var i = 0, o = e, a = n - r; o < n; o += r)
                i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]),
                a = o;
            return i
        }(t, e, n, r) > 0)
            for (o = e; o < n; o += r)
                a = Qi(o, t[o], t[o + 1], a);
        else
            for (o = n - r; o >= e; o -= r)
                a = Qi(o, t[o], t[o + 1], a);
        return a && qi(a, a.next) && ($i(a),
        a = a.next),
        a
    }
    function Ui(t, e) {
        if (!t)
            return t;
        e || (e = t);
        var n, r = t;
        do {
            if (n = !1,
            r.steiner || !qi(r, r.next) && 0 !== Xi(r.prev, r, r.next))
                r = r.next;
            else {
                if ($i(r),
                (r = e = r.prev) === r.next)
                    break;
                n = !0
            }
        } while (n || r !== e);return e
    }
    function Ni(t, e, n, r, i, o, a) {
        if (t) {
            !a && o && function(t, e, n, r) {
                var i = t;
                do {
                    null === i.z && (i.z = Vi(i.x, i.y, e, n, r)),
                    i.prevZ = i.prev,
                    i.nextZ = i.next,
                    i = i.next
                } while (i !== t);i.prevZ.nextZ = null,
                i.prevZ = null,
                function(t) {
                    var e, n, r, i, o, a, s, c, h = 1;
                    do {
                        for (n = t,
                        t = null,
                        o = null,
                        a = 0; n; ) {
                            for (a++,
                            r = n,
                            s = 0,
                            e = 0; e < h && (s++,
                            r = r.nextZ); e++)
                                ;
                            for (c = h; s > 0 || c > 0 && r; )
                                0 !== s && (0 === c || !r || n.z <= r.z) ? (i = n,
                                n = n.nextZ,
                                s--) : (i = r,
                                r = r.nextZ,
                                c--),
                                o ? o.nextZ = i : t = i,
                                i.prevZ = o,
                                o = i;
                            n = r
                        }
                        o.nextZ = null,
                        h *= 2
                    } while (a > 1)
                }(i)
            }(t, r, i, o);
            for (var s, c, h = t; t.prev !== t.next; )
                if (s = t.prev,
                c = t.next,
                o ? zi(t, r, i, o) : Bi(t))
                    e.push(s.i / n),
                    e.push(t.i / n),
                    e.push(c.i / n),
                    $i(t),
                    t = c.next,
                    h = c.next;
                else if ((t = c) === h) {
                    a ? 1 === a ? Ni(t = Fi(t, e, n), e, n, r, i, o, 2) : 2 === a && ki(t, e, n, r, i, o) : Ni(Ui(t), e, n, r, i, o, 1);
                    break
                }
        }
    }
    function Bi(t) {
        var e = t.prev
          , n = t
          , r = t.next;
        if (Xi(e, n, r) >= 0)
            return !1;
        for (var i = t.next.next; i !== t.prev; ) {
            if (Wi(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && Xi(i.prev, i, i.next) >= 0)
                return !1;
            i = i.next
        }
        return !0
    }
    function zi(t, e, n, r) {
        var i = t.prev
          , o = t
          , a = t.next;
        if (Xi(i, o, a) >= 0)
            return !1;
        for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, c = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, h = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, l = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, u = Vi(s, c, e, n, r), p = Vi(h, l, e, n, r), d = t.nextZ; d && d.z <= p; ) {
            if (d !== t.prev && d !== t.next && Wi(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && Xi(d.prev, d, d.next) >= 0)
                return !1;
            d = d.nextZ
        }
        for (d = t.prevZ; d && d.z >= u; ) {
            if (d !== t.prev && d !== t.next && Wi(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && Xi(d.prev, d, d.next) >= 0)
                return !1;
            d = d.prevZ
        }
        return !0
    }
    function Fi(t, e, n) {
        var r = t;
        do {
            var i = r.prev
              , o = r.next.next;
            !qi(i, o) && Zi(i, r, r.next, o) && Ji(i, o) && Ji(o, i) && (e.push(i.i / n),
            e.push(r.i / n),
            e.push(o.i / n),
            $i(r),
            $i(r.next),
            r = t = o),
            r = r.next
        } while (r !== t);return r
    }
    function ki(t, e, n, r, i, o) {
        var a = t;
        do {
            for (var s = a.next.next; s !== a.prev; ) {
                if (a.i !== s.i && Yi(a, s)) {
                    var c = Ki(a, s);
                    return a = Ui(a, a.next),
                    c = Ui(c, c.next),
                    Ni(a, e, n, r, i, o),
                    void Ni(c, e, n, r, i, o)
                }
                s = s.next
            }
            a = a.next
        } while (a !== t)
    }
    function Hi(t, e) {
        return t.x - e.x
    }
    function Gi(t, e) {
        if (e = function(t, e) {
            var n, r = e, i = t.x, o = t.y, a = -1 / 0;
            do {
                if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                    var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                    if (s <= i && s > a) {
                        if (a = s,
                        s === i) {
                            if (o === r.y)
                                return r;
                            if (o === r.next.y)
                                return r.next
                        }
                        n = r.x < r.next.x ? r : r.next
                    }
                }
                r = r.next
            } while (r !== e);if (!n)
                return null;
            if (i === a)
                return n.prev;
            var c, h = n, l = n.x, u = n.y, p = 1 / 0;
            for (r = n.next; r !== h; )
                i >= r.x && r.x >= l && i !== r.x && Wi(o < u ? i : a, o, l, u, o < u ? a : i, o, r.x, r.y) && ((c = Math.abs(o - r.y) / (i - r.x)) < p || c === p && r.x > n.x) && Ji(r, t) && (n = r,
                p = c),
                r = r.next;
            return n
        }(t, e)) {
            var n = Ki(e, t);
            Ui(n, n.next)
        }
    }
    function Vi(t, e, n, r, i) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }
    function ji(t) {
        var e = t
          , n = t;
        do {
            e.x < n.x && (n = e),
            e = e.next
        } while (e !== t);return n
    }
    function Wi(t, e, n, r, i, o, a, s) {
        return (i - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (r - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0
    }
    function Yi(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
            var n = t;
            do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Zi(n, n.next, t, e))
                    return !0;
                n = n.next
            } while (n !== t);return !1
        }(t, e) && Ji(t, e) && Ji(e, t) && function(t, e) {
            var n = t
              , r = !1
              , i = (t.x + e.x) / 2
              , o = (t.y + e.y) / 2;
            do {
                n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r),
                n = n.next
            } while (n !== t);return r
        }(t, e)
    }
    function Xi(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }
    function qi(t, e) {
        return t.x === e.x && t.y === e.y
    }
    function Zi(t, e, n, r) {
        return !!(qi(t, e) && qi(n, r) || qi(t, r) && qi(n, e)) || Xi(t, e, n) > 0 != Xi(t, e, r) > 0 && Xi(n, r, t) > 0 != Xi(n, r, e) > 0
    }
    function Ji(t, e) {
        return Xi(t.prev, t, t.next) < 0 ? Xi(t, e, t.next) >= 0 && Xi(t, t.prev, e) >= 0 : Xi(t, e, t.prev) < 0 || Xi(t, t.next, e) < 0
    }
    function Ki(t, e) {
        var n = new to(t.i,t.x,t.y)
          , r = new to(e.i,e.x,e.y)
          , i = t.next
          , o = e.prev;
        return t.next = e,
        e.prev = t,
        n.next = i,
        i.prev = n,
        r.next = n,
        n.prev = r,
        o.next = r,
        r.prev = o,
        r
    }
    function Qi(t, e, n, r) {
        var i = new to(t,e,n);
        return r ? (i.next = r.next,
        i.prev = r,
        r.next.prev = i,
        r.next = i) : (i.prev = i,
        i.next = i),
        i
    }
    function $i(t) {
        t.next.prev = t.prev,
        t.prev.next = t.next,
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }
    function to(t, e, n) {
        this.i = t,
        this.x = e,
        this.y = n,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    var eo = {
        area: function(t) {
            for (var e = t.length, n = 0, r = e - 1, i = 0; i < e; r = i++)
                n += t[r].x * t[i].y - t[i].x * t[r].y;
            return .5 * n
        },
        isClockWise: function(t) {
            return eo.area(t) < 0
        },
        triangulateShape: function(t, e) {
            var n = []
              , r = []
              , i = [];
            no(t),
            ro(n, t);
            var o = t.length;
            e.forEach(no);
            for (var a = 0; a < e.length; a++)
                r.push(o),
                o += e[a].length,
                ro(n, e[a]);
            var s = function(t, e, n) {
                n = n || 2;
                var r, i, o, a, s, c, h, l = e && e.length, u = l ? e[0] * n : t.length, p = Di(t, 0, u, n, !0), d = [];
                if (!p)
                    return d;
                if (l && (p = function(t, e, n, r) {
                    var i, o, a, s = [];
                    for (i = 0,
                    o = e.length; i < o; i++)
                        (a = Di(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === a.next && (a.steiner = !0),
                        s.push(ji(a));
                    for (s.sort(Hi),
                    i = 0; i < s.length; i++)
                        Gi(s[i], n),
                        n = Ui(n, n.next);
                    return n
                }(t, e, p, n)),
                t.length > 80 * n) {
                    r = o = t[0],
                    i = a = t[1];
                    for (var f = n; f < u; f += n)
                        s = t[f],
                        c = t[f + 1],
                        s < r && (r = s),
                        c < i && (i = c),
                        s > o && (o = s),
                        c > a && (a = c);
                    h = 0 !== (h = Math.max(o - r, a - i)) ? 1 / h : 0
                }
                return Ni(p, d, n, r, i, h),
                d
            }(n, r);
            for (a = 0; a < s.length; a += 3)
                i.push(s.slice(a, a + 3));
            return i
        }
    };
    function no(t) {
        var e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }
    function ro(t, e) {
        for (var n = 0; n < e.length; n++)
            t.push(e[n].x),
            t.push(e[n].y)
    }
    function io(t, e) {
        ir.call(this),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: t,
            options: e
        },
        this.fromBufferGeometry(new oo(t,e)),
        this.mergeVertices()
    }
    function oo(t, e) {
        void 0 !== t && (yr.call(this),
        this.type = "ExtrudeBufferGeometry",
        t = Array.isArray(t) ? t : [t],
        this.addShapeList(t, e),
        this.computeVertexNormals())
    }
    function ao(t, e) {
        ir.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: t,
            parameters: e
        },
        this.fromBufferGeometry(new so(t,e)),
        this.mergeVertices()
    }
    function so(t, e) {
        var n = (e = e || {}).font;
        if (!n || !n.isFont)
            return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
            new ir;
        var r = n.generateShapes(t, e.size, e.curveSegments);
        e.amount = void 0 !== e.height ? e.height : 50,
        void 0 === e.bevelThickness && (e.bevelThickness = 10),
        void 0 === e.bevelSize && (e.bevelSize = 8),
        void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
        oo.call(this, r, e),
        this.type = "TextBufferGeometry"
    }
    function co(t, e, n, r, i, o, a) {
        ir.call(this),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        },
        this.fromBufferGeometry(new ho(t,e,n,r,i,o,a)),
        this.mergeVertices()
    }
    function ho(t, e, n, r, i, o, a) {
        yr.call(this),
        this.type = "SphereBufferGeometry",
        this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: n,
            phiStart: r,
            phiLength: i,
            thetaStart: o,
            thetaLength: a
        },
        t = t || 1,
        e = Math.max(3, Math.floor(e) || 8),
        n = Math.max(2, Math.floor(n) || 6),
        r = void 0 !== r ? r : 0,
        i = void 0 !== i ? i : 2 * Math.PI;
        var s, c, h = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI), l = 0, u = [], p = new Fe, d = new Fe, f = [], m = [], g = [], v = [];
        for (c = 0; c <= n; c++) {
            var y = []
              , x = c / n;
            for (s = 0; s <= e; s++) {
                var w = s / e;
                p.x = -t * Math.cos(r + w * i) * Math.sin(o + x * a),
                p.y = t * Math.cos(o + x * a),
                p.z = t * Math.sin(r + w * i) * Math.sin(o + x * a),
                m.push(p.x, p.y, p.z),
                d.set(p.x, p.y, p.z).normalize(),
                g.push(d.x, d.y, d.z),
                v.push(w, 1 - x),
                y.push(l++)
            }
            u.push(y)
        }
        for (c = 0; c < n; c++)
            for (s = 0; s < e; s++) {
                var b = u[c][s + 1]
                  , M = u[c][s]
                  , _ = u[c + 1][s]
                  , E = u[c + 1][s + 1];
                (0 !== c || o > 0) && f.push(b, M, E),
                (c !== n - 1 || h < Math.PI) && f.push(M, _, E)
            }
        this.setIndex(f),
        this.addAttribute("position", new dr(m,3)),
        this.addAttribute("normal", new dr(g,3)),
        this.addAttribute("uv", new dr(v,2))
    }
    function lo(t, e, n, r, i, o) {
        ir.call(this),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: o
        },
        this.fromBufferGeometry(new uo(t,e,n,r,i,o)),
        this.mergeVertices()
    }
    function uo(t, e, n, r, i, o) {
        yr.call(this),
        this.type = "RingBufferGeometry",
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: i,
            thetaLength: o
        },
        t = t || .5,
        e = e || 1,
        i = void 0 !== i ? i : 0,
        o = void 0 !== o ? o : 2 * Math.PI,
        n = void 0 !== n ? Math.max(3, n) : 8;
        var a, s, c, h = [], l = [], u = [], p = [], d = t, f = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1), m = new Fe, g = new Ne;
        for (s = 0; s <= r; s++) {
            for (c = 0; c <= n; c++)
                a = i + c / n * o,
                m.x = d * Math.cos(a),
                m.y = d * Math.sin(a),
                l.push(m.x, m.y, m.z),
                u.push(0, 0, 1),
                g.x = (m.x / e + 1) / 2,
                g.y = (m.y / e + 1) / 2,
                p.push(g.x, g.y);
            d += f
        }
        for (s = 0; s < r; s++) {
            var v = s * (n + 1);
            for (c = 0; c < n; c++) {
                var y = a = c + v
                  , x = a + n + 1
                  , w = a + n + 2
                  , b = a + 1;
                h.push(y, x, b),
                h.push(x, w, b)
            }
        }
        this.setIndex(h),
        this.addAttribute("position", new dr(l,3)),
        this.addAttribute("normal", new dr(u,3)),
        this.addAttribute("uv", new dr(p,2))
    }
    function po(t, e, n, r) {
        ir.call(this),
        this.type = "LatheGeometry",
        this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: r
        },
        this.fromBufferGeometry(new fo(t,e,n,r)),
        this.mergeVertices()
    }
    function fo(t, e, n, r) {
        yr.call(this),
        this.type = "LatheBufferGeometry",
        this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: r
        },
        e = Math.floor(e) || 12,
        n = n || 0,
        r = r || 2 * Math.PI,
        r = Ue.clamp(r, 0, 2 * Math.PI);
        var i, o, a, s = [], c = [], h = [], l = 1 / e, u = new Fe, p = new Ne;
        for (o = 0; o <= e; o++) {
            var d = n + o * l * r
              , f = Math.sin(d)
              , m = Math.cos(d);
            for (a = 0; a <= t.length - 1; a++)
                u.x = t[a].x * f,
                u.y = t[a].y,
                u.z = t[a].x * m,
                c.push(u.x, u.y, u.z),
                p.x = o / e,
                p.y = a / (t.length - 1),
                h.push(p.x, p.y)
        }
        for (o = 0; o < e; o++)
            for (a = 0; a < t.length - 1; a++) {
                var g = i = a + o * t.length
                  , v = i + t.length
                  , y = i + t.length + 1
                  , x = i + 1;
                s.push(g, v, x),
                s.push(v, y, x)
            }
        if (this.setIndex(s),
        this.addAttribute("position", new dr(c,3)),
        this.addAttribute("uv", new dr(h,2)),
        this.computeVertexNormals(),
        r === 2 * Math.PI) {
            var w = this.attributes.normal.array
              , b = new Fe
              , M = new Fe
              , _ = new Fe;
            for (i = e * t.length * 3,
            o = 0,
            a = 0; o < t.length; o++,
            a += 3)
                b.x = w[a + 0],
                b.y = w[a + 1],
                b.z = w[a + 2],
                M.x = w[i + a + 0],
                M.y = w[i + a + 1],
                M.z = w[i + a + 2],
                _.addVectors(b, M).normalize(),
                w[a + 0] = w[i + a + 0] = _.x,
                w[a + 1] = w[i + a + 1] = _.y,
                w[a + 2] = w[i + a + 2] = _.z
        }
    }
    function mo(t, e) {
        ir.call(this),
        this.type = "ShapeGeometry",
        "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
        e = e.curveSegments),
        this.parameters = {
            shapes: t,
            curveSegments: e
        },
        this.fromBufferGeometry(new go(t,e)),
        this.mergeVertices()
    }
    function go(t, e) {
        yr.call(this),
        this.type = "ShapeBufferGeometry",
        this.parameters = {
            shapes: t,
            curveSegments: e
        },
        e = e || 12;
        var n = []
          , r = []
          , i = []
          , o = []
          , a = 0
          , s = 0;
        if (!1 === Array.isArray(t))
            h(t);
        else
            for (var c = 0; c < t.length; c++)
                h(t[c]),
                this.addGroup(a, s, c),
                a += s,
                s = 0;
        function h(t) {
            var a, c, h, l = r.length / 3, u = t.extractPoints(e), p = u.shape, d = u.holes;
            if (!1 === eo.isClockWise(p))
                for (p = p.reverse(),
                a = 0,
                c = d.length; a < c; a++)
                    h = d[a],
                    !0 === eo.isClockWise(h) && (d[a] = h.reverse());
            var f = eo.triangulateShape(p, d);
            for (a = 0,
            c = d.length; a < c; a++)
                h = d[a],
                p = p.concat(h);
            for (a = 0,
            c = p.length; a < c; a++) {
                var m = p[a];
                r.push(m.x, m.y, 0),
                i.push(0, 0, 1),
                o.push(m.x, m.y)
            }
            for (a = 0,
            c = f.length; a < c; a++) {
                var g = f[a]
                  , v = g[0] + l
                  , y = g[1] + l
                  , x = g[2] + l;
                n.push(v, y, x),
                s += 3
            }
        }
        this.setIndex(n),
        this.addAttribute("position", new dr(r,3)),
        this.addAttribute("normal", new dr(i,3)),
        this.addAttribute("uv", new dr(o,2))
    }
    function vo(t, e) {
        if (e.shapes = [],
        Array.isArray(t))
            for (var n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                e.shapes.push(i.uuid)
            }
        else
            e.shapes.push(t.uuid);
        return e
    }
    function yo(t, e) {
        yr.call(this),
        this.type = "EdgesGeometry",
        this.parameters = {
            thresholdAngle: e
        },
        e = void 0 !== e ? e : 1;
        var n, r, i, o, a = [], s = Math.cos(Ue.DEG2RAD * e), c = [0, 0], h = {}, l = ["a", "b", "c"];
        t.isBufferGeometry ? (o = new ir).fromBufferGeometry(t) : o = t.clone(),
        o.mergeVertices(),
        o.computeFaceNormals();
        for (var u = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
            for (var m = p[d], g = 0; g < 3; g++)
                n = m[l[g]],
                r = m[l[(g + 1) % 3]],
                c[0] = Math.min(n, r),
                c[1] = Math.max(n, r),
                void 0 === h[i = c[0] + "," + c[1]] ? h[i] = {
                    index1: c[0],
                    index2: c[1],
                    face1: d,
                    face2: void 0
                } : h[i].face2 = d;
        for (i in h) {
            var v = h[i];
            if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= s) {
                var y = u[v.index1];
                a.push(y.x, y.y, y.z),
                y = u[v.index2],
                a.push(y.x, y.y, y.z)
            }
        }
        this.addAttribute("position", new dr(a,3))
    }
    function xo(t, e, n, r, i, o, a, s) {
        ir.call(this),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        },
        this.fromBufferGeometry(new wo(t,e,n,r,i,o,a,s)),
        this.mergeVertices()
    }
    function wo(t, e, n, r, i, o, a, s) {
        yr.call(this),
        this.type = "CylinderBufferGeometry",
        this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: r,
            heightSegments: i,
            openEnded: o,
            thetaStart: a,
            thetaLength: s
        };
        var c = this;
        t = void 0 !== t ? t : 1,
        e = void 0 !== e ? e : 1,
        n = n || 1,
        r = Math.floor(r) || 8,
        i = Math.floor(i) || 1,
        o = void 0 !== o && o,
        a = void 0 !== a ? a : 0,
        s = void 0 !== s ? s : 2 * Math.PI;
        var h = []
          , l = []
          , u = []
          , p = []
          , d = 0
          , f = []
          , m = n / 2
          , g = 0;
        function v(n) {
            var i, o, f, v = new Ne, y = new Fe, x = 0, w = !0 === n ? t : e, b = !0 === n ? 1 : -1;
            for (o = d,
            i = 1; i <= r; i++)
                l.push(0, m * b, 0),
                u.push(0, b, 0),
                p.push(.5, .5),
                d++;
            for (f = d,
            i = 0; i <= r; i++) {
                var M = i / r * s + a
                  , _ = Math.cos(M)
                  , E = Math.sin(M);
                y.x = w * E,
                y.y = m * b,
                y.z = w * _,
                l.push(y.x, y.y, y.z),
                u.push(0, b, 0),
                v.x = .5 * _ + .5,
                v.y = .5 * E * b + .5,
                p.push(v.x, v.y),
                d++
            }
            for (i = 0; i < r; i++) {
                var S = o + i
                  , T = f + i;
                !0 === n ? h.push(T, T + 1, S) : h.push(T + 1, T, S),
                x += 3
            }
            c.addGroup(g, x, !0 === n ? 1 : 2),
            g += x
        }
        !function() {
            var o, v, y = new Fe, x = new Fe, w = 0, b = (e - t) / n;
            for (v = 0; v <= i; v++) {
                var M = []
                  , _ = v / i
                  , E = _ * (e - t) + t;
                for (o = 0; o <= r; o++) {
                    var S = o / r
                      , T = S * s + a
                      , A = Math.sin(T)
                      , L = Math.cos(T);
                    x.x = E * A,
                    x.y = -_ * n + m,
                    x.z = E * L,
                    l.push(x.x, x.y, x.z),
                    y.set(A, b, L).normalize(),
                    u.push(y.x, y.y, y.z),
                    p.push(S, 1 - _),
                    M.push(d++)
                }
                f.push(M)
            }
            for (o = 0; o < r; o++)
                for (v = 0; v < i; v++) {
                    var R = f[v][o]
                      , P = f[v + 1][o]
                      , C = f[v + 1][o + 1]
                      , I = f[v][o + 1];
                    h.push(R, P, I),
                    h.push(P, C, I),
                    w += 6
                }
            c.addGroup(g, w, 0),
            g += w
        }(),
        !1 === o && (t > 0 && v(!0),
        e > 0 && v(!1)),
        this.setIndex(h),
        this.addAttribute("position", new dr(l,3)),
        this.addAttribute("normal", new dr(u,3)),
        this.addAttribute("uv", new dr(p,2))
    }
    function bo(t, e, n, r, i, o, a) {
        xo.call(this, 0, t, e, n, r, i, o, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }
    function Mo(t, e, n, r, i, o, a) {
        wo.call(this, 0, t, e, n, r, i, o, a),
        this.type = "ConeBufferGeometry",
        this.parameters = {
            radius: t,
            height: e,
            radialSegments: n,
            heightSegments: r,
            openEnded: i,
            thetaStart: o,
            thetaLength: a
        }
    }
    function _o(t, e, n, r) {
        ir.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: r
        },
        this.fromBufferGeometry(new Eo(t,e,n,r)),
        this.mergeVertices()
    }
    function Eo(t, e, n, r) {
        yr.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: r
        },
        t = t || 1,
        e = void 0 !== e ? Math.max(3, e) : 8,
        n = void 0 !== n ? n : 0,
        r = void 0 !== r ? r : 2 * Math.PI;
        var i, o, a = [], s = [], c = [], h = [], l = new Fe, u = new Ne;
        for (s.push(0, 0, 0),
        c.push(0, 0, 1),
        h.push(.5, .5),
        o = 0,
        i = 3; o <= e; o++,
        i += 3) {
            var p = n + o / e * r;
            l.x = t * Math.cos(p),
            l.y = t * Math.sin(p),
            s.push(l.x, l.y, l.z),
            c.push(0, 0, 1),
            u.x = (s[i] / t + 1) / 2,
            u.y = (s[i + 1] / t + 1) / 2,
            h.push(u.x, u.y)
        }
        for (i = 1; i <= e; i++)
            a.push(i, i + 1, 0);
        this.setIndex(a),
        this.addAttribute("position", new dr(s,3)),
        this.addAttribute("normal", new dr(c,3)),
        this.addAttribute("uv", new dr(h,2))
    }
    io.prototype = Object.create(ir.prototype),
    io.prototype.constructor = io,
    oo.prototype = Object.create(yr.prototype),
    oo.prototype.constructor = oo,
    oo.prototype.getArrays = function() {
        var t = this.getAttribute("position")
          , e = t ? Array.prototype.slice.call(t.array) : []
          , n = this.getAttribute("uv")
          , r = n ? Array.prototype.slice.call(n.array) : []
          , i = this.index;
        return {
            position: e,
            uv: r,
            index: i ? Array.prototype.slice.call(i.array) : []
        }
    }
    ,
    oo.prototype.addShapeList = function(t, e) {
        var n = t.length;
        e.arrays = this.getArrays();
        for (var r = 0; r < n; r++) {
            var i = t[r];
            this.addShape(i, e)
        }
        this.setIndex(e.arrays.index),
        this.addAttribute("position", new dr(e.arrays.position,3)),
        this.addAttribute("uv", new dr(e.arrays.uv,2))
    }
    ,
    oo.prototype.addShape = function(t, e) {
        var n, r, i, o, a, s, c, h, l = e.arrays ? e.arrays : this.getArrays(), u = l.position, p = l.index, d = l.uv, f = [], m = void 0 !== e.amount ? e.amount : 100, g = void 0 !== e.bevelThickness ? e.bevelThickness : 6, v = void 0 !== e.bevelSize ? e.bevelSize : g - 2, y = void 0 !== e.bevelSegments ? e.bevelSegments : 3, x = void 0 === e.bevelEnabled || e.bevelEnabled, w = void 0 !== e.curveSegments ? e.curveSegments : 12, b = void 0 !== e.steps ? e.steps : 1, M = e.extrudePath, _ = !1, E = void 0 !== e.UVGenerator ? e.UVGenerator : io.WorldUVGenerator;
        M && (n = M.getSpacedPoints(b),
        _ = !0,
        x = !1,
        r = void 0 !== e.frames ? e.frames : M.computeFrenetFrames(b, !1),
        i = new Fe,
        o = new Fe,
        a = new Fe),
        x || (y = 0,
        g = 0,
        v = 0);
        var S = this
          , T = t.extractPoints(w)
          , A = T.shape
          , L = T.holes;
        if (!eo.isClockWise(A))
            for (A = A.reverse(),
            c = 0,
            h = L.length; c < h; c++)
                s = L[c],
                eo.isClockWise(s) && (L[c] = s.reverse());
        var R = eo.triangulateShape(A, L)
          , P = A;
        for (c = 0,
        h = L.length; c < h; c++)
            s = L[c],
            A = A.concat(s);
        function C(t, e, n) {
            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
            e.clone().multiplyScalar(n).add(t)
        }
        var I, O, D, U, N, B, z = A.length, F = R.length;
        function k(t, e, n) {
            var r, i, o, a = t.x - e.x, s = t.y - e.y, c = n.x - t.x, h = n.y - t.y, l = a * a + s * s, u = a * h - s * c;
            if (Math.abs(u) > Number.EPSILON) {
                var p = Math.sqrt(l)
                  , d = Math.sqrt(c * c + h * h)
                  , f = e.x - s / p
                  , m = e.y + a / p
                  , g = ((n.x - h / d - f) * h - (n.y + c / d - m) * c) / (a * h - s * c)
                  , v = (r = f + a * g - t.x) * r + (i = m + s * g - t.y) * i;
                if (v <= 2)
                    return new Ne(r,i);
                o = Math.sqrt(v / 2)
            } else {
                var y = !1;
                a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(h) && (y = !0),
                y ? (r = -s,
                i = a,
                o = Math.sqrt(l)) : (r = a,
                i = s,
                o = Math.sqrt(l / 2))
            }
            return new Ne(r / o,i / o)
        }
        for (var H = [], G = 0, V = P.length, j = V - 1, W = G + 1; G < V; G++,
        j++,
        W++)
            j === V && (j = 0),
            W === V && (W = 0),
            H[G] = k(P[G], P[j], P[W]);
        var Y, X, q = [], Z = H.concat();
        for (c = 0,
        h = L.length; c < h; c++) {
            for (s = L[c],
            Y = [],
            G = 0,
            j = (V = s.length) - 1,
            W = G + 1; G < V; G++,
            j++,
            W++)
                j === V && (j = 0),
                W === V && (W = 0),
                Y[G] = k(s[G], s[j], s[W]);
            q.push(Y),
            Z = Z.concat(Y)
        }
        for (I = 0; I < y; I++) {
            for (D = I / y,
            U = g * Math.cos(D * Math.PI / 2),
            O = v * Math.sin(D * Math.PI / 2),
            G = 0,
            V = P.length; G < V; G++)
                K((N = C(P[G], H[G], O)).x, N.y, -U);
            for (c = 0,
            h = L.length; c < h; c++)
                for (s = L[c],
                Y = q[c],
                G = 0,
                V = s.length; G < V; G++)
                    K((N = C(s[G], Y[G], O)).x, N.y, -U)
        }
        for (O = v,
        G = 0; G < z; G++)
            N = x ? C(A[G], Z[G], O) : A[G],
            _ ? (o.copy(r.normals[0]).multiplyScalar(N.x),
            i.copy(r.binormals[0]).multiplyScalar(N.y),
            a.copy(n[0]).add(o).add(i),
            K(a.x, a.y, a.z)) : K(N.x, N.y, 0);
        for (X = 1; X <= b; X++)
            for (G = 0; G < z; G++)
                N = x ? C(A[G], Z[G], O) : A[G],
                _ ? (o.copy(r.normals[X]).multiplyScalar(N.x),
                i.copy(r.binormals[X]).multiplyScalar(N.y),
                a.copy(n[X]).add(o).add(i),
                K(a.x, a.y, a.z)) : K(N.x, N.y, m / b * X);
        for (I = y - 1; I >= 0; I--) {
            for (D = I / y,
            U = g * Math.cos(D * Math.PI / 2),
            O = v * Math.sin(D * Math.PI / 2),
            G = 0,
            V = P.length; G < V; G++)
                K((N = C(P[G], H[G], O)).x, N.y, m + U);
            for (c = 0,
            h = L.length; c < h; c++)
                for (s = L[c],
                Y = q[c],
                G = 0,
                V = s.length; G < V; G++)
                    N = C(s[G], Y[G], O),
                    _ ? K(N.x, N.y + n[b - 1].y, n[b - 1].x + U) : K(N.x, N.y, m + U)
        }
        function J(t, e) {
            var n, r;
            for (G = t.length; --G >= 0; ) {
                n = G,
                (r = G - 1) < 0 && (r = t.length - 1);
                var i = 0
                  , o = b + 2 * y;
                for (i = 0; i < o; i++) {
                    var a = z * i
                      , s = z * (i + 1);
                    $(e + n + a, e + r + a, e + r + s, e + n + s)
                }
            }
        }
        function K(t, e, n) {
            f.push(t),
            f.push(e),
            f.push(n)
        }
        function Q(t, e, n) {
            tt(t),
            tt(e),
            tt(n);
            var r = u.length / 3
              , i = E.generateTopUV(S, u, r - 3, r - 2, r - 1);
            et(i[0]),
            et(i[1]),
            et(i[2])
        }
        function $(t, e, n, r) {
            tt(t),
            tt(e),
            tt(r),
            tt(e),
            tt(n),
            tt(r);
            var i = u.length / 3
              , o = E.generateSideWallUV(S, u, i - 6, i - 3, i - 2, i - 1);
            et(o[0]),
            et(o[1]),
            et(o[3]),
            et(o[1]),
            et(o[2]),
            et(o[3])
        }
        function tt(t) {
            p.push(u.length / 3),
            u.push(f[3 * t + 0]),
            u.push(f[3 * t + 1]),
            u.push(f[3 * t + 2])
        }
        function et(t) {
            d.push(t.x),
            d.push(t.y)
        }
        !function() {
            var t = u.length / 3;
            if (x) {
                var n = 0
                  , r = z * n;
                for (G = 0; G < F; G++)
                    Q((B = R[G])[2] + r, B[1] + r, B[0] + r);
                for (r = z * (n = b + 2 * y),
                G = 0; G < F; G++)
                    Q((B = R[G])[0] + r, B[1] + r, B[2] + r)
            } else {
                for (G = 0; G < F; G++)
                    Q((B = R[G])[2], B[1], B[0]);
                for (G = 0; G < F; G++)
                    Q((B = R[G])[0] + z * b, B[1] + z * b, B[2] + z * b)
            }
            S.addGroup(t, u.length / 3 - t, void 0 !== e.material ? e.material : 0)
        }(),
        function() {
            var t = u.length / 3
              , n = 0;
            for (J(P, n),
            n += P.length,
            c = 0,
            h = L.length; c < h; c++)
                J(s = L[c], n),
                n += s.length;
            S.addGroup(t, u.length / 3 - t, void 0 !== e.extrudeMaterial ? e.extrudeMaterial : 1)
        }(),
        e.arrays || (this.setIndex(p),
        this.addAttribute("position", new dr(u,3)),
        this.addAttribute("uv", new dr(d,2)))
    }
    ,
    io.WorldUVGenerator = {
        generateTopUV: function(t, e, n, r, i) {
            var o = e[3 * n]
              , a = e[3 * n + 1]
              , s = e[3 * r]
              , c = e[3 * r + 1]
              , h = e[3 * i]
              , l = e[3 * i + 1];
            return [new Ne(o,a), new Ne(s,c), new Ne(h,l)]
        },
        generateSideWallUV: function(t, e, n, r, i, o) {
            var a = e[3 * n]
              , s = e[3 * n + 1]
              , c = e[3 * n + 2]
              , h = e[3 * r]
              , l = e[3 * r + 1]
              , u = e[3 * r + 2]
              , p = e[3 * i]
              , d = e[3 * i + 1]
              , f = e[3 * i + 2]
              , m = e[3 * o]
              , g = e[3 * o + 1]
              , v = e[3 * o + 2];
            return Math.abs(s - l) < .01 ? [new Ne(a,1 - c), new Ne(h,1 - u), new Ne(p,1 - f), new Ne(m,1 - v)] : [new Ne(s,1 - c), new Ne(l,1 - u), new Ne(d,1 - f), new Ne(g,1 - v)]
        }
    },
    ao.prototype = Object.create(ir.prototype),
    ao.prototype.constructor = ao,
    so.prototype = Object.create(oo.prototype),
    so.prototype.constructor = so,
    co.prototype = Object.create(ir.prototype),
    co.prototype.constructor = co,
    ho.prototype = Object.create(yr.prototype),
    ho.prototype.constructor = ho,
    lo.prototype = Object.create(ir.prototype),
    lo.prototype.constructor = lo,
    uo.prototype = Object.create(yr.prototype),
    uo.prototype.constructor = uo,
    po.prototype = Object.create(ir.prototype),
    po.prototype.constructor = po,
    fo.prototype = Object.create(yr.prototype),
    fo.prototype.constructor = fo,
    mo.prototype = Object.create(ir.prototype),
    mo.prototype.constructor = mo,
    mo.prototype.toJSON = function() {
        var t = ir.prototype.toJSON.call(this);
        return vo(this.parameters.shapes, t)
    }
    ,
    go.prototype = Object.create(yr.prototype),
    go.prototype.constructor = go,
    go.prototype.toJSON = function() {
        var t = yr.prototype.toJSON.call(this);
        return vo(this.parameters.shapes, t)
    }
    ,
    yo.prototype = Object.create(yr.prototype),
    yo.prototype.constructor = yo,
    xo.prototype = Object.create(ir.prototype),
    xo.prototype.constructor = xo,
    wo.prototype = Object.create(yr.prototype),
    wo.prototype.constructor = wo,
    bo.prototype = Object.create(xo.prototype),
    bo.prototype.constructor = bo,
    Mo.prototype = Object.create(wo.prototype),
    Mo.prototype.constructor = Mo,
    _o.prototype = Object.create(ir.prototype),
    _o.prototype.constructor = _o,
    Eo.prototype = Object.create(yr.prototype),
    Eo.prototype.constructor = Eo;
    var So = Object.freeze({
        WireframeGeometry: mi,
        ParametricGeometry: gi,
        ParametricBufferGeometry: vi,
        TetrahedronGeometry: wi,
        TetrahedronBufferGeometry: bi,
        OctahedronGeometry: Mi,
        OctahedronBufferGeometry: _i,
        IcosahedronGeometry: Ei,
        IcosahedronBufferGeometry: Si,
        DodecahedronGeometry: Ti,
        DodecahedronBufferGeometry: Ai,
        PolyhedronGeometry: yi,
        PolyhedronBufferGeometry: xi,
        TubeGeometry: Li,
        TubeBufferGeometry: Ri,
        TorusKnotGeometry: Pi,
        TorusKnotBufferGeometry: Ci,
        TorusGeometry: Ii,
        TorusBufferGeometry: Oi,
        TextGeometry: ao,
        TextBufferGeometry: so,
        SphereGeometry: co,
        SphereBufferGeometry: ho,
        RingGeometry: lo,
        RingBufferGeometry: uo,
        PlaneGeometry: br,
        PlaneBufferGeometry: Mr,
        LatheGeometry: po,
        LatheBufferGeometry: fo,
        ShapeGeometry: mo,
        ShapeBufferGeometry: go,
        ExtrudeGeometry: io,
        ExtrudeBufferGeometry: oo,
        EdgesGeometry: yo,
        ConeGeometry: bo,
        ConeBufferGeometry: Mo,
        CylinderGeometry: xo,
        CylinderBufferGeometry: wo,
        CircleGeometry: _o,
        CircleBufferGeometry: Eo,
        BoxGeometry: xr,
        BoxBufferGeometry: wr
    });
    function To(t) {
        Gn.call(this),
        this.type = "ShadowMaterial",
        this.color = new Un(0),
        this.opacity = 1,
        this.lights = !0,
        this.transparent = !0,
        this.setValues(t)
    }
    function Ao(t) {
        Er.call(this, t),
        this.type = "RawShaderMaterial"
    }
    function Lo(t) {
        Gn.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Un(16777215),
        this.roughness = .5,
        this.metalness = .5,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Un(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalScale = new Ne(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function Ro(t) {
        Lo.call(this),
        this.defines = {
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.reflectivity = .5,
        this.clearCoat = 0,
        this.clearCoatRoughness = 0,
        this.setValues(t)
    }
    function Po(t) {
        Gn.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new Un(16777215),
        this.specular = new Un(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Un(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalScale = new Ne(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = $,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function Co(t) {
        Po.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.gradientMap = null,
        this.setValues(t)
    }
    function Io(t) {
        Gn.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalScale = new Ne(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function Oo(t) {
        Gn.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new Un(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Un(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = $,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function Do(t) {
        oi.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(t)
    }
    To.prototype = Object.create(Gn.prototype),
    To.prototype.constructor = To,
    To.prototype.isShadowMaterial = !0,
    Ao.prototype = Object.create(Er.prototype),
    Ao.prototype.constructor = Ao,
    Ao.prototype.isRawShaderMaterial = !0,
    Lo.prototype = Object.create(Gn.prototype),
    Lo.prototype.constructor = Lo,
    Lo.prototype.isMeshStandardMaterial = !0,
    Lo.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(t.color),
        this.roughness = t.roughness,
        this.metalness = t.metalness,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.roughnessMap = t.roughnessMap,
        this.metalnessMap = t.metalnessMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.envMapIntensity = t.envMapIntensity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Ro.prototype = Object.create(Lo.prototype),
    Ro.prototype.constructor = Ro,
    Ro.prototype.isMeshPhysicalMaterial = !0,
    Ro.prototype.copy = function(t) {
        return Lo.prototype.copy.call(this, t),
        this.defines = {
            PHYSICAL: ""
        },
        this.reflectivity = t.reflectivity,
        this.clearCoat = t.clearCoat,
        this.clearCoatRoughness = t.clearCoatRoughness,
        this
    }
    ,
    Po.prototype = Object.create(Gn.prototype),
    Po.prototype.constructor = Po,
    Po.prototype.isMeshPhongMaterial = !0,
    Po.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        this.shininess = t.shininess,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Co.prototype = Object.create(Po.prototype),
    Co.prototype.constructor = Co,
    Co.prototype.isMeshToonMaterial = !0,
    Co.prototype.copy = function(t) {
        return Po.prototype.copy.call(this, t),
        this.gradientMap = t.gradientMap,
        this
    }
    ,
    Io.prototype = Object.create(Gn.prototype),
    Io.prototype.constructor = Io,
    Io.prototype.isMeshNormalMaterial = !0,
    Io.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Oo.prototype = Object.create(Gn.prototype),
    Oo.prototype.constructor = Oo,
    Oo.prototype.isMeshLambertMaterial = !0,
    Oo.prototype.copy = function(t) {
        return Gn.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    Do.prototype = Object.create(oi.prototype),
    Do.prototype.constructor = Do,
    Do.prototype.isLineDashedMaterial = !0,
    Do.prototype.copy = function(t) {
        return oi.prototype.copy.call(this, t),
        this.scale = t.scale,
        this.dashSize = t.dashSize,
        this.gapSize = t.gapSize,
        this
    }
    ;
    var Uo = Object.freeze({
        ShadowMaterial: To,
        SpriteMaterial: $r,
        RawShaderMaterial: Ao,
        ShaderMaterial: Er,
        PointsMaterial: hi,
        MeshPhysicalMaterial: Ro,
        MeshStandardMaterial: Lo,
        MeshPhongMaterial: Po,
        MeshToonMaterial: Co,
        MeshNormalMaterial: Io,
        MeshLambertMaterial: Oo,
        MeshDepthMaterial: Vn,
        MeshDistanceMaterial: jn,
        MeshBasicMaterial: _r,
        LineDashedMaterial: Do,
        LineBasicMaterial: oi,
        Material: Gn
    })
      , No = {
        enabled: !1,
        files: {},
        add: function(t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function(t) {
            if (!1 !== this.enabled)
                return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    };
    function Bo(t, e, n) {
        var r = this
          , i = !1
          , o = 0
          , a = 0
          , s = void 0;
        this.onStart = void 0,
        this.onLoad = t,
        this.onProgress = e,
        this.onError = n,
        this.itemStart = function(t) {
            a++,
            !1 === i && void 0 !== r.onStart && r.onStart(t, o, a),
            i = !0
        }
        ,
        this.itemEnd = function(t) {
            o++,
            void 0 !== r.onProgress && r.onProgress(t, o, a),
            o === a && (i = !1,
            void 0 !== r.onLoad && r.onLoad())
        }
        ,
        this.itemError = function(t) {
            void 0 !== r.onError && r.onError(t)
        }
        ,
        this.resolveURL = function(t) {
            return s ? s(t) : t
        }
        ,
        this.setURLModifier = function(t) {
            return s = t,
            this
        }
    }
    var zo = new Bo
      , Fo = {};
    function ko(t) {
        this.manager = void 0 !== t ? t : zo
    }
    function Ho(t) {
        this.manager = void 0 !== t ? t : zo,
        this._parser = null
    }
    function Go(t) {
        this.manager = void 0 !== t ? t : zo,
        this._parser = null
    }
    function Vo(t) {
        this.manager = void 0 !== t ? t : zo
    }
    function jo(t) {
        this.manager = void 0 !== t ? t : zo
    }
    function Wo(t) {
        this.manager = void 0 !== t ? t : zo
    }
    function Yo() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function Xo(t, e, n, r, i, o, a, s) {
        Yo.call(this),
        this.type = "EllipseCurve",
        this.aX = t || 0,
        this.aY = e || 0,
        this.xRadius = n || 1,
        this.yRadius = r || 1,
        this.aStartAngle = i || 0,
        this.aEndAngle = o || 2 * Math.PI,
        this.aClockwise = a || !1,
        this.aRotation = s || 0
    }
    function qo(t, e, n, r, i, o) {
        Xo.call(this, t, e, n, n, r, i, o),
        this.type = "ArcCurve"
    }
    function Zo() {
        var t = 0
          , e = 0
          , n = 0
          , r = 0;
        function i(i, o, a, s) {
            t = i,
            e = a,
            n = -3 * i + 3 * o - 2 * a - s,
            r = 2 * i - 2 * o + a + s
        }
        return {
            initCatmullRom: function(t, e, n, r, o) {
                i(e, n, o * (n - t), o * (r - e))
            },
            initNonuniformCatmullRom: function(t, e, n, r, o, a, s) {
                var c = (e - t) / o - (n - t) / (o + a) + (n - e) / a
                  , h = (n - e) / a - (r - e) / (a + s) + (r - n) / s;
                i(e, n, c *= a, h *= a)
            },
            calc: function(i) {
                var o = i * i;
                return t + e * i + n * o + r * (o * i)
            }
        }
    }
    Object.assign(ko.prototype, {
        load: function(t, e, n, r) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var i = this
              , o = No.get(t);
            if (void 0 !== o)
                return i.manager.itemStart(t),
                setTimeout(function() {
                    e && e(o),
                    i.manager.itemEnd(t)
                }, 0),
                o;
            if (void 0 === Fo[t]) {
                var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var s = a[1]
                      , c = !!a[2]
                      , h = a[3];
                    h = window.decodeURIComponent(h),
                    c && (h = window.atob(h));
                    try {
                        var l, u = (this.responseType || "").toLowerCase();
                        switch (u) {
                        case "arraybuffer":
                        case "blob":
                            for (var p = new Uint8Array(h.length), d = 0; d < h.length; d++)
                                p[d] = h.charCodeAt(d);
                            l = "blob" === u ? new Blob([p.buffer],{
                                type: s
                            }) : p.buffer;
                            break;
                        case "document":
                            var f = new DOMParser;
                            l = f.parseFromString(h, s);
                            break;
                        case "json":
                            l = JSON.parse(h);
                            break;
                        default:
                            l = h
                        }
                        window.setTimeout(function() {
                            e && e(l),
                            i.manager.itemEnd(t)
                        }, 0)
                    } catch (e) {
                        window.setTimeout(function() {
                            r && r(e),
                            i.manager.itemEnd(t),
                            i.manager.itemError(t)
                        }, 0)
                    }
                } else {
                    Fo[t] = [],
                    Fo[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: r
                    });
                    var m = new XMLHttpRequest;
                    for (var g in m.open("GET", t, !0),
                    m.addEventListener("load", function(e) {
                        var n = this.response;
                        No.add(t, n);
                        var r = Fo[t];
                        if (delete Fo[t],
                        200 === this.status) {
                            for (var o = 0, a = r.length; o < a; o++)
                                (s = r[o]).onLoad && s.onLoad(n);
                            i.manager.itemEnd(t)
                        } else if (0 === this.status) {
                            for (console.warn("THREE.FileLoader: HTTP Status 0 received."),
                            o = 0,
                            a = r.length; o < a; o++)
                                (s = r[o]).onLoad && s.onLoad(n);
                            i.manager.itemEnd(t)
                        } else {
                            for (o = 0,
                            a = r.length; o < a; o++) {
                                var s;
                                (s = r[o]).onError && s.onError(e)
                            }
                            i.manager.itemEnd(t),
                            i.manager.itemError(t)
                        }
                    }, !1),
                    m.addEventListener("progress", function(e) {
                        for (var n = Fo[t], r = 0, i = n.length; r < i; r++) {
                            var o = n[r];
                            o.onProgress && o.onProgress(e)
                        }
                    }, !1),
                    m.addEventListener("error", function(e) {
                        var n = Fo[t];
                        delete Fo[t];
                        for (var r = 0, o = n.length; r < o; r++) {
                            var a = n[r];
                            a.onError && a.onError(e)
                        }
                        i.manager.itemEnd(t),
                        i.manager.itemError(t)
                    }, !1),
                    void 0 !== this.responseType && (m.responseType = this.responseType),
                    void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
                    m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"),
                    this.requestHeader)
                        m.setRequestHeader(g, this.requestHeader[g]);
                    m.send(null)
                }
                return i.manager.itemStart(t),
                m
            }
            Fo[t].push({
                onLoad: e,
                onProgress: n,
                onError: r
            })
        },
        setPath: function(t) {
            return this.path = t,
            this
        },
        setResponseType: function(t) {
            return this.responseType = t,
            this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t,
            this
        },
        setMimeType: function(t) {
            return this.mimeType = t,
            this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t,
            this
        }
    }),
    Object.assign(Ho.prototype, {
        load: function(t, e, n, r) {
            var i = this
              , o = []
              , a = new di;
            a.image = o;
            var s = new ko(this.manager);
            function c(c) {
                s.load(t[c], function(t) {
                    var n = i._parser(t, !0);
                    o[c] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    },
                    6 === (h += 1) && (1 === n.mipmapCount && (a.minFilter = bt),
                    a.format = n.format,
                    a.needsUpdate = !0,
                    e && e(a))
                }, n, r)
            }
            if (s.setPath(this.path),
            s.setResponseType("arraybuffer"),
            Array.isArray(t))
                for (var h = 0, l = 0, u = t.length; l < u; ++l)
                    c(l);
            else
                s.load(t, function(t) {
                    var n = i._parser(t, !0);
                    if (n.isCubemap)
                        for (var r = n.mipmaps.length / n.mipmapCount, s = 0; s < r; s++) {
                            o[s] = {
                                mipmaps: []
                            };
                            for (var c = 0; c < n.mipmapCount; c++)
                                o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]),
                                o[s].format = n.format,
                                o[s].width = n.width,
                                o[s].height = n.height
                        }
                    else
                        a.image.width = n.width,
                        a.image.height = n.height,
                        a.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (a.minFilter = bt),
                    a.format = n.format,
                    a.needsUpdate = !0,
                    e && e(a)
                }, n, r);
            return a
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(Go.prototype, {
        load: function(t, e, n, r) {
            var i = this
              , o = new Ye
              , a = new ko(this.manager);
            return a.setResponseType("arraybuffer"),
            a.load(t, function(t) {
                var n = i._parser(t);
                n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width,
                o.image.height = n.height,
                o.image.data = n.data),
                o.wrapS = void 0 !== n.wrapS ? n.wrapS : gt,
                o.wrapT = void 0 !== n.wrapT ? n.wrapT : gt,
                o.magFilter = void 0 !== n.magFilter ? n.magFilter : bt,
                o.minFilter = void 0 !== n.minFilter ? n.minFilter : _t,
                o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                void 0 !== n.format && (o.format = n.format),
                void 0 !== n.type && (o.type = n.type),
                void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps),
                1 === n.mipmapCount && (o.minFilter = bt),
                o.needsUpdate = !0,
                e && e(o, n))
            }, n, r),
            o
        }
    }),
    Object.assign(Vo.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, e, n, r) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var i = this
              , o = No.get(t);
            if (void 0 !== o)
                return i.manager.itemStart(t),
                setTimeout(function() {
                    e && e(o),
                    i.manager.itemEnd(t)
                }, 0),
                o;
            var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return a.addEventListener("load", function() {
                No.add(t, this),
                e && e(this),
                i.manager.itemEnd(t)
            }, !1),
            a.addEventListener("error", function(e) {
                r && r(e),
                i.manager.itemEnd(t),
                i.manager.itemError(t)
            }, !1),
            "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
            i.manager.itemStart(t),
            a.src = t,
            a
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(jo.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, e, n, r) {
            var i = new Xe
              , o = new Vo(this.manager);
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path);
            var a = 0;
            function s(n) {
                o.load(t[n], function(t) {
                    i.images[n] = t,
                    6 == ++a && (i.needsUpdate = !0,
                    e && e(i))
                }, void 0, r)
            }
            for (var c = 0; c < t.length; ++c)
                s(c);
            return i
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(Wo.prototype, {
        crossOrigin: "Anonymous",
        load: function(t, e, n, r) {
            var i = new Ge
              , o = new Vo(this.manager);
            return o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(t, function(n) {
                i.image = n;
                var r = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                i.format = r ? Bt : zt,
                i.needsUpdate = !0,
                void 0 !== e && e(i)
            }, n, r),
            i
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    }),
    Object.assign(Yo.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        },
        getPointAt: function(t, e) {
            var n = this.getUtoTmapping(t);
            return this.getPoint(n, e)
        },
        getPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return e
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 5);
            for (var e = [], n = 0; n <= t; n++)
                e.push(this.getPointAt(n / t));
            return e
        },
        getLength: function() {
            var t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e, n, r = [], i = this.getPoint(0), o = 0;
            for (r.push(0),
            n = 1; n <= t; n++)
                o += (e = this.getPoint(n / t)).distanceTo(i),
                r.push(o),
                i = e;
            return this.cacheArcLengths = r,
            r
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            var n, r = this.getLengths(), i = 0, o = r.length;
            n = e || t * r[o - 1];
            for (var a, s = 0, c = o - 1; s <= c; )
                if ((a = r[i = Math.floor(s + (c - s) / 2)] - n) < 0)
                    s = i + 1;
                else {
                    if (!(a > 0)) {
                        c = i;
                        break
                    }
                    c = i - 1
                }
            if (r[i = c] === n)
                return i / (o - 1);
            var h = r[i];
            return (i + (n - h) / (r[i + 1] - h)) / (o - 1)
        },
        getTangent: function(t) {
            var e = t - 1e-4
              , n = t + 1e-4;
            e < 0 && (e = 0),
            n > 1 && (n = 1);
            var r = this.getPoint(e);
            return this.getPoint(n).clone().sub(r).normalize()
        },
        getTangentAt: function(t) {
            var e = this.getUtoTmapping(t);
            return this.getTangent(e)
        },
        computeFrenetFrames: function(t, e) {
            var n, r, i, o = new Fe, a = [], s = [], c = [], h = new Fe, l = new Be;
            for (n = 0; n <= t; n++)
                r = n / t,
                a[n] = this.getTangentAt(r),
                a[n].normalize();
            s[0] = new Fe,
            c[0] = new Fe;
            var u = Number.MAX_VALUE
              , p = Math.abs(a[0].x)
              , d = Math.abs(a[0].y)
              , f = Math.abs(a[0].z);
            for (p <= u && (u = p,
            o.set(1, 0, 0)),
            d <= u && (u = d,
            o.set(0, 1, 0)),
            f <= u && o.set(0, 0, 1),
            h.crossVectors(a[0], o).normalize(),
            s[0].crossVectors(a[0], h),
            c[0].crossVectors(a[0], s[0]),
            n = 1; n <= t; n++)
                s[n] = s[n - 1].clone(),
                c[n] = c[n - 1].clone(),
                h.crossVectors(a[n - 1], a[n]),
                h.length() > Number.EPSILON && (h.normalize(),
                i = Math.acos(Ue.clamp(a[n - 1].dot(a[n]), -1, 1)),
                s[n].applyMatrix4(l.makeRotationAxis(h, i))),
                c[n].crossVectors(a[n], s[n]);
            if (!0 === e)
                for (i = Math.acos(Ue.clamp(s[0].dot(s[t]), -1, 1)),
                i /= t,
                a[0].dot(h.crossVectors(s[0], s[t])) > 0 && (i = -i),
                n = 1; n <= t; n++)
                    s[n].applyMatrix4(l.makeRotationAxis(a[n], i * n)),
                    c[n].crossVectors(a[n], s[n]);
            return {
                tangents: a,
                normals: s,
                binormals: c
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions,
            t.type = this.type,
            t
        },
        fromJSON: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        }
    }),
    Xo.prototype = Object.create(Yo.prototype),
    Xo.prototype.constructor = Xo,
    Xo.prototype.isEllipseCurve = !0,
    Xo.prototype.getPoint = function(t, e) {
        for (var n = e || new Ne, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0; )
            i += r;
        for (; i > r; )
            i -= r;
        i < Number.EPSILON && (i = o ? 0 : r),
        !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
        var a = this.aStartAngle + t * i
          , s = this.aX + this.xRadius * Math.cos(a)
          , c = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            var h = Math.cos(this.aRotation)
              , l = Math.sin(this.aRotation)
              , u = s - this.aX
              , p = c - this.aY;
            s = u * h - p * l + this.aX,
            c = u * l + p * h + this.aY
        }
        return n.set(s, c)
    }
    ,
    Xo.prototype.copy = function(t) {
        return Yo.prototype.copy.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    Xo.prototype.toJSON = function() {
        var t = Yo.prototype.toJSON.call(this);
        return t.aX = this.aX,
        t.aY = this.aY,
        t.xRadius = this.xRadius,
        t.yRadius = this.yRadius,
        t.aStartAngle = this.aStartAngle,
        t.aEndAngle = this.aEndAngle,
        t.aClockwise = this.aClockwise,
        t.aRotation = this.aRotation,
        t
    }
    ,
    Xo.prototype.fromJSON = function(t) {
        return Yo.prototype.fromJSON.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    qo.prototype = Object.create(Xo.prototype),
    qo.prototype.constructor = qo,
    qo.prototype.isArcCurve = !0;
    var Jo = new Fe
      , Ko = new Zo
      , Qo = new Zo
      , $o = new Zo;
    function ta(t, e, n, r) {
        Yo.call(this),
        this.type = "CatmullRomCurve3",
        this.points = t || [],
        this.closed = e || !1,
        this.curveType = n || "centripetal",
        this.tension = r || .5
    }
    function ea(t, e, n, r, i) {
        var o = .5 * (r - e)
          , a = .5 * (i - n)
          , s = t * t;
        return (2 * n - 2 * r + o + a) * (t * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * t + n
    }
    function na(t, e, n, r) {
        return function(t, e) {
            var n = 1 - t;
            return n * n * e
        }(t, e) + function(t, e) {
            return 2 * (1 - t) * t * n
        }(t) + function(t, e) {
            return t * t * r
        }(t)
    }
    function ra(t, e, n, r, i) {
        return function(t, e) {
            var n = 1 - t;
            return n * n * n * e
        }(t, e) + function(t, e) {
            var n = 1 - t;
            return 3 * n * n * t * e
        }(t, n) + function(t, e) {
            return 3 * (1 - t) * t * t * r
        }(t) + function(t, e) {
            return t * t * t * i
        }(t)
    }
    function ia(t, e, n, r) {
        Yo.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = t || new Ne,
        this.v1 = e || new Ne,
        this.v2 = n || new Ne,
        this.v3 = r || new Ne
    }
    function oa(t, e, n, r) {
        Yo.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = t || new Fe,
        this.v1 = e || new Fe,
        this.v2 = n || new Fe,
        this.v3 = r || new Fe
    }
    function aa(t, e) {
        Yo.call(this),
        this.type = "LineCurve",
        this.v1 = t || new Ne,
        this.v2 = e || new Ne
    }
    function sa(t, e) {
        Yo.call(this),
        this.type = "LineCurve3",
        this.v1 = t || new Fe,
        this.v2 = e || new Fe
    }
    function ca(t, e, n) {
        Yo.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = t || new Ne,
        this.v1 = e || new Ne,
        this.v2 = n || new Ne
    }
    function ha(t, e, n) {
        Yo.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = t || new Fe,
        this.v1 = e || new Fe,
        this.v2 = n || new Fe
    }
    function la(t) {
        Yo.call(this),
        this.type = "SplineCurve",
        this.points = t || []
    }
    ta.prototype = Object.create(Yo.prototype),
    ta.prototype.constructor = ta,
    ta.prototype.isCatmullRomCurve3 = !0,
    ta.prototype.getPoint = function(t, e) {
        var n, r, i, o, a = e || new Fe, s = this.points, c = s.length, h = (c - (this.closed ? 0 : 1)) * t, l = Math.floor(h), u = h - l;
        if (this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s.length) + 1) * s.length : 0 === u && l === c - 1 && (l = c - 2,
        u = 1),
        this.closed || l > 0 ? n = s[(l - 1) % c] : (Jo.subVectors(s[0], s[1]).add(s[0]),
        n = Jo),
        r = s[l % c],
        i = s[(l + 1) % c],
        this.closed || l + 2 < c ? o = s[(l + 2) % c] : (Jo.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]),
        o = Jo),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
            var p = "chordal" === this.curveType ? .5 : .25
              , d = Math.pow(n.distanceToSquared(r), p)
              , f = Math.pow(r.distanceToSquared(i), p)
              , m = Math.pow(i.distanceToSquared(o), p);
            f < 1e-4 && (f = 1),
            d < 1e-4 && (d = f),
            m < 1e-4 && (m = f),
            Ko.initNonuniformCatmullRom(n.x, r.x, i.x, o.x, d, f, m),
            Qo.initNonuniformCatmullRom(n.y, r.y, i.y, o.y, d, f, m),
            $o.initNonuniformCatmullRom(n.z, r.z, i.z, o.z, d, f, m)
        } else
            "catmullrom" === this.curveType && (Ko.initCatmullRom(n.x, r.x, i.x, o.x, this.tension),
            Qo.initCatmullRom(n.y, r.y, i.y, o.y, this.tension),
            $o.initCatmullRom(n.z, r.z, i.z, o.z, this.tension));
        return a.set(Ko.calc(u), Qo.calc(u), $o.calc(u)),
        a
    }
    ,
    ta.prototype.copy = function(t) {
        Yo.prototype.copy.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push(r.clone())
        }
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    ta.prototype.toJSON = function() {
        var t = Yo.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var r = this.points[e];
            t.points.push(r.toArray())
        }
        return t.closed = this.closed,
        t.curveType = this.curveType,
        t.tension = this.tension,
        t
    }
    ,
    ta.prototype.fromJSON = function(t) {
        Yo.prototype.fromJSON.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push((new Fe).fromArray(r))
        }
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    ia.prototype = Object.create(Yo.prototype),
    ia.prototype.constructor = ia,
    ia.prototype.isCubicBezierCurve = !0,
    ia.prototype.getPoint = function(t, e) {
        var n = e || new Ne
          , r = this.v0
          , i = this.v1
          , o = this.v2
          , a = this.v3;
        return n.set(ra(t, r.x, i.x, o.x, a.x), ra(t, r.y, i.y, o.y, a.y)),
        n
    }
    ,
    ia.prototype.copy = function(t) {
        return Yo.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    ia.prototype.toJSON = function() {
        var t = Yo.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    ia.prototype.fromJSON = function(t) {
        return Yo.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    oa.prototype = Object.create(Yo.prototype),
    oa.prototype.constructor = oa,
    oa.prototype.isCubicBezierCurve3 = !0,
    oa.prototype.getPoint = function(t, e) {
        var n = e || new Fe
          , r = this.v0
          , i = this.v1
          , o = this.v2
          , a = this.v3;
        return n.set(ra(t, r.x, i.x, o.x, a.x), ra(t, r.y, i.y, o.y, a.y), ra(t, r.z, i.z, o.z, a.z)),
        n
    }
    ,
    oa.prototype.copy = function(t) {
        return Yo.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    oa.prototype.toJSON = function() {
        var t = Yo.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    oa.prototype.fromJSON = function(t) {
        return Yo.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    aa.prototype = Object.create(Yo.prototype),
    aa.prototype.constructor = aa,
    aa.prototype.isLineCurve = !0,
    aa.prototype.getPoint = function(t, e) {
        var n = e || new Ne;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(t).add(this.v1)),
        n
    }
    ,
    aa.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    aa.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }
    ,
    aa.prototype.copy = function(t) {
        return Yo.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    aa.prototype.toJSON = function() {
        var t = Yo.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    aa.prototype.fromJSON = function(t) {
        return Yo.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    sa.prototype = Object.create(Yo.prototype),
    sa.prototype.constructor = sa,
    sa.prototype.isLineCurve3 = !0,
    sa.prototype.getPoint = function(t, e) {
        var n = e || new Fe;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(t).add(this.v1)),
        n
    }
    ,
    sa.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    sa.prototype.copy = function(t) {
        return Yo.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    sa.prototype.toJSON = function() {
        var t = Yo.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    sa.prototype.fromJSON = function(t) {
        return Yo.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    ca.prototype = Object.create(Yo.prototype),
    ca.prototype.constructor = ca,
    ca.prototype.isQuadraticBezierCurve = !0,
    ca.prototype.getPoint = function(t, e) {
        var n = e || new Ne
          , r = this.v0
          , i = this.v1
          , o = this.v2;
        return n.set(na(t, r.x, i.x, o.x), na(t, r.y, i.y, o.y)),
        n
    }
    ,
    ca.prototype.copy = function(t) {
        return Yo.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    ca.prototype.toJSON = function() {
        var t = Yo.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    ca.prototype.fromJSON = function(t) {
        return Yo.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    ha.prototype = Object.create(Yo.prototype),
    ha.prototype.constructor = ha,
    ha.prototype.isQuadraticBezierCurve3 = !0,
    ha.prototype.getPoint = function(t, e) {
        var n = e || new Fe
          , r = this.v0
          , i = this.v1
          , o = this.v2;
        return n.set(na(t, r.x, i.x, o.x), na(t, r.y, i.y, o.y), na(t, r.z, i.z, o.z)),
        n
    }
    ,
    ha.prototype.copy = function(t) {
        return Yo.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    ha.prototype.toJSON = function() {
        var t = Yo.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    ha.prototype.fromJSON = function(t) {
        return Yo.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    la.prototype = Object.create(Yo.prototype),
    la.prototype.constructor = la,
    la.prototype.isSplineCurve = !0,
    la.prototype.getPoint = function(t, e) {
        var n = e || new Ne
          , r = this.points
          , i = (r.length - 1) * t
          , o = Math.floor(i)
          , a = i - o
          , s = r[0 === o ? o : o - 1]
          , c = r[o]
          , h = r[o > r.length - 2 ? r.length - 1 : o + 1]
          , l = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return n.set(ea(a, s.x, c.x, h.x, l.x), ea(a, s.y, c.y, h.y, l.y)),
        n
    }
    ,
    la.prototype.copy = function(t) {
        Yo.prototype.copy.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push(r.clone())
        }
        return this
    }
    ,
    la.prototype.toJSON = function() {
        var t = Yo.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, n = this.points.length; e < n; e++) {
            var r = this.points[e];
            t.points.push(r.toArray())
        }
        return t
    }
    ,
    la.prototype.fromJSON = function(t) {
        Yo.prototype.fromJSON.call(this, t),
        this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push((new Ne).fromArray(r))
        }
        return this
    }
    ;
    var ua = Object.freeze({
        ArcCurve: qo,
        CatmullRomCurve3: ta,
        CubicBezierCurve: ia,
        CubicBezierCurve3: oa,
        EllipseCurve: Xo,
        LineCurve: aa,
        LineCurve3: sa,
        QuadraticBezierCurve: ca,
        QuadraticBezierCurve3: ha,
        SplineCurve: la
    });
    function pa() {
        Yo.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function da(t) {
        pa.call(this),
        this.type = "Path",
        this.currentPoint = new Ne,
        t && this.setFromPoints(t)
    }
    function fa(t) {
        da.call(this, t),
        this.uuid = Ue.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function ma(t, e) {
        $n.call(this),
        this.type = "Light",
        this.color = new Un(t),
        this.intensity = void 0 !== e ? e : 1,
        this.receiveShadow = void 0
    }
    function ga(t, e, n) {
        ma.call(this, t, n),
        this.type = "HemisphereLight",
        this.castShadow = void 0,
        this.position.copy($n.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new Un(e)
    }
    function va(t) {
        this.camera = t,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new Ne(512,512),
        this.map = null,
        this.matrix = new Be
    }
    function ya() {
        va.call(this, new Vr(50,1,.5,500))
    }
    function xa(t, e, n, r, i, o) {
        ma.call(this, t, e),
        this.type = "SpotLight",
        this.position.copy($n.DefaultUp),
        this.updateMatrix(),
        this.target = new $n,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.angle = void 0 !== r ? r : Math.PI / 3,
        this.penumbra = void 0 !== i ? i : 0,
        this.decay = void 0 !== o ? o : 1,
        this.shadow = new ya
    }
    function wa(t, e, n, r) {
        ma.call(this, t, e),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.decay = void 0 !== r ? r : 1,
        this.shadow = new va(new Vr(90,1,.5,500))
    }
    function ba() {
        va.call(this, new er(-5,5,5,-5,.5,500))
    }
    function Ma(t, e) {
        ma.call(this, t, e),
        this.type = "DirectionalLight",
        this.position.copy($n.DefaultUp),
        this.updateMatrix(),
        this.target = new $n,
        this.shadow = new ba
    }
    function _a(t, e) {
        ma.call(this, t, e),
        this.type = "AmbientLight",
        this.castShadow = void 0
    }
    function Ea(t, e, n, r) {
        ma.call(this, t, e),
        this.type = "RectAreaLight",
        this.width = void 0 !== n ? n : 10,
        this.height = void 0 !== r ? r : 10
    }
    function Sa(t, e, n, r) {
        Na.call(this, t, e, n, r)
    }
    function Ta(t, e, n) {
        Na.call(this, t, e, n)
    }
    function Aa(t, e, n, r) {
        this.parameterPositions = t,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== r ? r : new e.constructor(n),
        this.sampleValues = e,
        this.valueSize = n
    }
    function La(t, e, n, r) {
        Aa.call(this, t, e, n, r)
    }
    function Ra(t, e, n, r) {
        Na.call(this, t, e, n, r)
    }
    function Pa(t, e, n, r) {
        Na.call(this, t, e, n, r)
    }
    function Ca(t, e, n, r) {
        Na.call(this, t, e, n, r)
    }
    function Ia(t, e, n, r) {
        Aa.call(this, t, e, n, r),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0
    }
    function Oa(t, e, n, r) {
        Aa.call(this, t, e, n, r)
    }
    function Da(t, e, n, r) {
        Aa.call(this, t, e, n, r)
    }
    pa.prototype = Object.assign(Object.create(Yo.prototype), {
        constructor: pa,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            var t = this.curves[0].getPoint(0)
              , e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new aa(e,t))
        },
        getPoint: function(t) {
            for (var e = t * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length; ) {
                if (n[r] >= e) {
                    var i = n[r] - e
                      , o = this.curves[r]
                      , a = o.getLength()
                      , s = 0 === a ? 0 : 1 - i / a;
                    return o.getPointAt(s)
                }
                r++
            }
            return null
        },
        getLength: function() {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var t = [], e = 0, n = 0, r = this.curves.length; n < r; n++)
                e += this.curves[n].getLength(),
                t.push(e);
            return this.cacheLengths = t,
            t
        },
        getSpacedPoints: function(t) {
            void 0 === t && (t = 40);
            for (var e = [], n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]),
            e
        },
        getPoints: function(t) {
            t = t || 12;
            for (var e, n = [], r = 0, i = this.curves; r < i.length; r++)
                for (var o = i[r], a = o && o.isEllipseCurve ? 2 * t : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), c = 0; c < s.length; c++) {
                    var h = s[c];
                    e && e.equals(h) || (n.push(h),
                    e = h)
                }
            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]),
            n
        },
        copy: function(t) {
            Yo.prototype.copy.call(this, t),
            this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var r = t.curves[e];
                this.curves.push(r.clone())
            }
            return this.autoClose = t.autoClose,
            this
        },
        toJSON: function() {
            var t = Yo.prototype.toJSON.call(this);
            t.autoClose = this.autoClose,
            t.curves = [];
            for (var e = 0, n = this.curves.length; e < n; e++) {
                var r = this.curves[e];
                t.curves.push(r.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            Yo.prototype.fromJSON.call(this, t),
            this.autoClose = t.autoClose,
            this.curves = [];
            for (var e = 0, n = t.curves.length; e < n; e++) {
                var r = t.curves[e];
                this.curves.push((new ua[r.type]).fromJSON(r))
            }
            return this
        }
    }),
    da.prototype = Object.assign(Object.create(pa.prototype), {
        constructor: da,
        setFromPoints: function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, n = t.length; e < n; e++)
                this.lineTo(t[e].x, t[e].y)
        },
        moveTo: function(t, e) {
            this.currentPoint.set(t, e)
        },
        lineTo: function(t, e) {
            var n = new aa(this.currentPoint.clone(),new Ne(t,e));
            this.curves.push(n),
            this.currentPoint.set(t, e)
        },
        quadraticCurveTo: function(t, e, n, r) {
            var i = new ca(this.currentPoint.clone(),new Ne(t,e),new Ne(n,r));
            this.curves.push(i),
            this.currentPoint.set(n, r)
        },
        bezierCurveTo: function(t, e, n, r, i, o) {
            var a = new ia(this.currentPoint.clone(),new Ne(t,e),new Ne(n,r),new Ne(i,o));
            this.curves.push(a),
            this.currentPoint.set(i, o)
        },
        splineThru: function(t) {
            var e = new la([this.currentPoint.clone()].concat(t));
            this.curves.push(e),
            this.currentPoint.copy(t[t.length - 1])
        },
        arc: function(t, e, n, r, i, o) {
            var a = this.currentPoint.x
              , s = this.currentPoint.y;
            this.absarc(t + a, e + s, n, r, i, o)
        },
        absarc: function(t, e, n, r, i, o) {
            this.absellipse(t, e, n, n, r, i, o)
        },
        ellipse: function(t, e, n, r, i, o, a, s) {
            var c = this.currentPoint.x
              , h = this.currentPoint.y;
            this.absellipse(t + c, e + h, n, r, i, o, a, s)
        },
        absellipse: function(t, e, n, r, i, o, a, s) {
            var c = new Xo(t,e,n,r,i,o,a,s);
            if (this.curves.length > 0) {
                var h = c.getPoint(0);
                h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
            }
            this.curves.push(c);
            var l = c.getPoint(1);
            this.currentPoint.copy(l)
        },
        copy: function(t) {
            return pa.prototype.copy.call(this, t),
            this.currentPoint.copy(t.currentPoint),
            this
        },
        toJSON: function() {
            var t = pa.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(),
            t
        },
        fromJSON: function(t) {
            return pa.prototype.fromJSON.call(this, t),
            this.currentPoint.fromArray(t.currentPoint),
            this
        }
    }),
    fa.prototype = Object.assign(Object.create(da.prototype), {
        constructor: fa,
        getPointsHoles: function(t) {
            for (var e = [], n = 0, r = this.holes.length; n < r; n++)
                e[n] = this.holes[n].getPoints(t);
            return e
        },
        extractPoints: function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        copy: function(t) {
            da.prototype.copy.call(this, t),
            this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var r = t.holes[e];
                this.holes.push(r.clone())
            }
            return this
        },
        toJSON: function() {
            var t = da.prototype.toJSON.call(this);
            t.uuid = this.uuid,
            t.holes = [];
            for (var e = 0, n = this.holes.length; e < n; e++) {
                var r = this.holes[e];
                t.holes.push(r.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            da.prototype.fromJSON.call(this, t),
            this.uuid = t.uuid,
            this.holes = [];
            for (var e = 0, n = t.holes.length; e < n; e++) {
                var r = t.holes[e];
                this.holes.push((new da).fromJSON(r))
            }
            return this
        }
    }),
    ma.prototype = Object.assign(Object.create($n.prototype), {
        constructor: ma,
        isLight: !0,
        copy: function(t) {
            return $n.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.intensity = t.intensity,
            this
        },
        toJSON: function(t) {
            var e = $n.prototype.toJSON.call(this, t);
            return e.object.color = this.color.getHex(),
            e.object.intensity = this.intensity,
            void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
        }
    }),
    ga.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: ga,
        isHemisphereLight: !0,
        copy: function(t) {
            return ma.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
        }
    }),
    Object.assign(va.prototype, {
        copy: function(t) {
            return this.camera = t.camera.clone(),
            this.bias = t.bias,
            this.radius = t.radius,
            this.mapSize.copy(t.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var t = {};
            return 0 !== this.bias && (t.bias = this.bias),
            1 !== this.radius && (t.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
            t.camera = this.camera.toJSON(!1).object,
            delete t.camera.matrix,
            t
        }
    }),
    ya.prototype = Object.assign(Object.create(va.prototype), {
        constructor: ya,
        isSpotLightShadow: !0,
        update: function(t) {
            var e = this.camera
              , n = 2 * Ue.RAD2DEG * t.angle
              , r = this.mapSize.width / this.mapSize.height
              , i = t.distance || e.far;
            n === e.fov && r === e.aspect && i === e.far || (e.fov = n,
            e.aspect = r,
            e.far = i,
            e.updateProjectionMatrix())
        }
    }),
    xa.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: xa,
        isSpotLight: !0,
        copy: function(t) {
            return ma.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.angle = t.angle,
            this.penumbra = t.penumbra,
            this.decay = t.decay,
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    wa.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: wa,
        isPointLight: !0,
        copy: function(t) {
            return ma.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.decay = t.decay,
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    ba.prototype = Object.assign(Object.create(va.prototype), {
        constructor: ba
    }),
    Ma.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: Ma,
        isDirectionalLight: !0,
        copy: function(t) {
            return ma.prototype.copy.call(this, t),
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    _a.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: _a,
        isAmbientLight: !0
    }),
    Ea.prototype = Object.assign(Object.create(ma.prototype), {
        constructor: Ea,
        isRectAreaLight: !0,
        copy: function(t) {
            return ma.prototype.copy.call(this, t),
            this.width = t.width,
            this.height = t.height,
            this
        },
        toJSON: function(t) {
            var e = ma.prototype.toJSON.call(this, t);
            return e.object.width = this.width,
            e.object.height = this.height,
            e
        }
    }),
    Sa.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: Sa,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: ge,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    Ta.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: Ta,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: ge,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    Object.assign(Aa.prototype, {
        evaluate: function(t) {
            var e = this.parameterPositions
              , n = this._cachedIndex
              , r = e[n]
              , i = e[n - 1];
            t: {
                e: {
                    var o;
                    n: {
                        r: if (!(t < r)) {
                            for (var a = n + 2; ; ) {
                                if (void 0 === r) {
                                    if (t < i)
                                        break r;
                                    return n = e.length,
                                    this._cachedIndex = n,
                                    this.afterEnd_(n - 1, t, i)
                                }
                                if (n === a)
                                    break;
                                if (i = r,
                                t < (r = e[++n]))
                                    break e
                            }
                            o = e.length;
                            break n
                        }
                        if (t >= i)
                            break t;
                        var s = e[1];
                        for (t < s && (n = 2,
                        i = s),
                        a = n - 2; ; ) {
                            if (void 0 === i)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, t, r);
                            if (n === a)
                                break;
                            if (r = i,
                            t >= (i = e[--n - 1]))
                                break e
                        }
                        o = n,
                        n = 0
                    }
                    for (; n < o; ) {
                        var c = n + o >>> 1;
                        t < e[c] ? o = c : n = c + 1
                    }
                    if (r = e[n],
                    void 0 === (i = e[n - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, t, r);
                    if (void 0 === r)
                        return n = e.length,
                        this._cachedIndex = n,
                        this.afterEnd_(n - 1, i, t)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, i, r)
            }
            return this.interpolate_(n, i, t, r)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(t) {
            for (var e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r, o = 0; o !== r; ++o)
                e[o] = n[i + o];
            return e
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign(Aa.prototype, {
        beforeStart_: Aa.prototype.copySampleValue_,
        afterEnd_: Aa.prototype.copySampleValue_
    }),
    La.prototype = Object.assign(Object.create(Aa.prototype), {
        constructor: La,
        interpolate_: function(t, e, n, r) {
            for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = (n - e) / (r - e), h = s + a; s !== h; s += 4)
                ze.slerpFlat(i, 0, o, s - a, o, s, c);
            return i
        }
    }),
    Ra.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: Ra,
        ValueTypeName: "quaternion",
        DefaultInterpolation: ve,
        InterpolantFactoryMethodLinear: function(t) {
            return new La(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    Pa.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: Pa,
        ValueTypeName: "color"
    }),
    Ca.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: Ca,
        ValueTypeName: "number"
    }),
    Ia.prototype = Object.assign(Object.create(Aa.prototype), {
        constructor: Ia,
        DefaultSettings_: {
            endingStart: xe,
            endingEnd: xe
        },
        intervalChanged_: function(t, e, n) {
            var r = this.parameterPositions
              , i = t - 2
              , o = t + 1
              , a = r[i]
              , s = r[o];
            if (void 0 === a)
                switch (this.getSettings_().endingStart) {
                case we:
                    i = t,
                    a = 2 * e - n;
                    break;
                case be:
                    a = e + r[i = r.length - 2] - r[i + 1];
                    break;
                default:
                    i = t,
                    a = n
                }
            if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                case we:
                    o = t,
                    s = 2 * n - e;
                    break;
                case be:
                    o = 1,
                    s = n + r[1] - r[0];
                    break;
                default:
                    o = t - 1,
                    s = e
                }
            var c = .5 * (n - e)
              , h = this.valueSize;
            this._weightPrev = c / (e - a),
            this._weightNext = c / (s - n),
            this._offsetPrev = i * h,
            this._offsetNext = o * h
        },
        interpolate_: function(t, e, n, r) {
            for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, h = this._offsetPrev, l = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (n - e) / (r - e), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p * m - p * f, w = 0; w !== a; ++w)
                i[w] = g * o[h + w] + v * o[c + w] + y * o[s + w] + x * o[l + w];
            return i
        }
    }),
    Oa.prototype = Object.assign(Object.create(Aa.prototype), {
        constructor: Oa,
        interpolate_: function(t, e, n, r) {
            for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, h = (n - e) / (r - e), l = 1 - h, u = 0; u !== a; ++u)
                i[u] = o[c + u] * l + o[s + u] * h;
            return i
        }
    }),
    Da.prototype = Object.assign(Object.create(Aa.prototype), {
        constructor: Da,
        interpolate_: function(t) {
            return this.copySampleValue_(t - 1)
        }
    });
    var Ua = {
        arraySlice: function(t, e, n) {
            return Ua.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
        },
        convertArray: function(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            for (var e = t.length, n = new Array(e), r = 0; r !== e; ++r)
                n[r] = r;
            return n.sort(function(e, n) {
                return t[e] - t[n]
            }),
            n
        },
        sortedArray: function(t, e, n) {
            for (var r = t.length, i = new t.constructor(r), o = 0, a = 0; a !== r; ++o)
                for (var s = n[o] * e, c = 0; c !== e; ++c)
                    i[a++] = t[s + c];
            return i
        },
        flattenJSON: function(t, e, n, r) {
            for (var i = 1, o = t[0]; void 0 !== o && void 0 === o[r]; )
                o = t[i++];
            if (void 0 !== o) {
                var a = o[r];
                if (void 0 !== a)
                    if (Array.isArray(a))
                        do {
                            void 0 !== (a = o[r]) && (e.push(o.time),
                            n.push.apply(n, a)),
                            o = t[i++]
                        } while (void 0 !== o);
                    else if (void 0 !== a.toArray)
                        do {
                            void 0 !== (a = o[r]) && (e.push(o.time),
                            a.toArray(n, n.length)),
                            o = t[i++]
                        } while (void 0 !== o);
                    else
                        do {
                            void 0 !== (a = o[r]) && (e.push(o.time),
                            n.push(a)),
                            o = t[i++]
                        } while (void 0 !== o)
            }
        }
    };
    function Na(t, e, n, r) {
        if (void 0 === t)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t,
        this.times = Ua.convertArray(e, this.TimeBufferType),
        this.values = Ua.convertArray(n, this.ValueBufferType),
        this.setInterpolation(r || this.DefaultInterpolation),
        this.validate(),
        this.optimize()
    }
    function Ba(t, e, n, r) {
        Na.call(this, t, e, n, r)
    }
    function za(t, e, n) {
        this.name = t,
        this.tracks = n,
        this.duration = void 0 !== e ? e : -1,
        this.uuid = Ue.generateUUID(),
        this.duration < 0 && this.resetDuration(),
        this.optimize()
    }
    function Fa(t) {
        this.manager = void 0 !== t ? t : zo,
        this.textures = {}
    }
    function ka(t) {
        this.manager = void 0 !== t ? t : zo
    }
    Object.assign(Na, {
        parse: function(t) {
            if (void 0 === t.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            var e = Na._getTrackTypeForValueTypeName(t.type);
            if (void 0 === t.times) {
                var n = []
                  , r = [];
                Ua.flattenJSON(t.keys, n, r, "value"),
                t.times = n,
                t.values = r
            }
            return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
        },
        toJSON: function(t) {
            var e, n = t.constructor;
            if (void 0 !== n.toJSON)
                e = n.toJSON(t);
            else {
                e = {
                    name: t.name,
                    times: Ua.convertArray(t.times, Array),
                    values: Ua.convertArray(t.values, Array)
                };
                var r = t.getInterpolation();
                r !== t.DefaultInterpolation && (e.interpolation = r)
            }
            return e.type = t.ValueTypeName,
            e
        },
        _getTrackTypeForValueTypeName: function(t) {
            switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Ca;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return Ba;
            case "color":
                return Pa;
            case "quaternion":
                return Ra;
            case "bool":
            case "boolean":
                return Ta;
            case "string":
                return Sa
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }
    }),
    Object.assign(Na.prototype, {
        constructor: Na,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: ve,
        InterpolantFactoryMethodDiscrete: function(t) {
            return new Da(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodLinear: function(t) {
            return new Oa(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: function(t) {
            return new Ia(this.times,this.values,this.getValueSize(),t)
        },
        setInterpolation: function(t) {
            var e;
            switch (t) {
            case ge:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case ve:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case ye:
                e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 !== e)
                this.createInterpolant = e;
            else {
                var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation)
                        throw new Error(n);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                console.warn("THREE.KeyframeTrack:", n)
            }
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return ge;
            case this.InterpolantFactoryMethodLinear:
                return ve;
            case this.InterpolantFactoryMethodSmooth:
                return ye
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(t) {
            if (0 !== t)
                for (var e = this.times, n = 0, r = e.length; n !== r; ++n)
                    e[n] += t;
            return this
        },
        scale: function(t) {
            if (1 !== t)
                for (var e = this.times, n = 0, r = e.length; n !== r; ++n)
                    e[n] *= t;
            return this
        },
        trim: function(t, e) {
            for (var n = this.times, r = n.length, i = 0, o = r - 1; i !== r && n[i] < t; )
                ++i;
            for (; -1 !== o && n[o] > e; )
                --o;
            if (++o,
            0 !== i || o !== r) {
                i >= o && (i = (o = Math.max(o, 1)) - 1);
                var a = this.getValueSize();
                this.times = Ua.arraySlice(n, i, o),
                this.values = Ua.arraySlice(this.values, i * a, o * a)
            }
            return this
        },
        validate: function() {
            var t = !0
              , e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            t = !1);
            var n = this.times
              , r = this.values
              , i = n.length;
            0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            t = !1);
            for (var o = null, a = 0; a !== i; a++) {
                var s = n[a];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s),
                    t = !1;
                    break
                }
                if (null !== o && o > s) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o),
                    t = !1;
                    break
                }
                o = s
            }
            if (void 0 !== r && Ua.isTypedArray(r)) {
                a = 0;
                for (var c = r.length; a !== c; ++a) {
                    var h = r[a];
                    if (isNaN(h)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, h),
                        t = !1;
                        break
                    }
                }
            }
            return t
        },
        optimize: function() {
            for (var t = this.times, e = this.values, n = this.getValueSize(), r = this.getInterpolation() === ye, i = 1, o = t.length - 1, a = 1; a < o; ++a) {
                var s = !1
                  , c = t[a];
                if (c !== t[a + 1] && (1 !== a || c !== c[0]))
                    if (r)
                        s = !0;
                    else
                        for (var h = a * n, l = h - n, u = h + n, p = 0; p !== n; ++p) {
                            var d = e[h + p];
                            if (d !== e[l + p] || d !== e[u + p]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (a !== i) {
                        t[i] = t[a];
                        var f = a * n
                          , m = i * n;
                        for (p = 0; p !== n; ++p)
                            e[m + p] = e[f + p]
                    }
                    ++i
                }
            }
            if (o > 0) {
                for (t[i] = t[o],
                f = o * n,
                m = i * n,
                p = 0; p !== n; ++p)
                    e[m + p] = e[f + p];
                ++i
            }
            return i !== t.length && (this.times = Ua.arraySlice(t, 0, i),
            this.values = Ua.arraySlice(e, 0, i * n)),
            this
        }
    }),
    Ba.prototype = Object.assign(Object.create(Na.prototype), {
        constructor: Ba,
        ValueTypeName: "vector"
    }),
    Object.assign(za, {
        parse: function(t) {
            for (var e = [], n = t.tracks, r = 1 / (t.fps || 1), i = 0, o = n.length; i !== o; ++i)
                e.push(Na.parse(n[i]).scale(r));
            return new za(t.name,t.duration,e)
        },
        toJSON: function(t) {
            for (var e = [], n = t.tracks, r = {
                name: t.name,
                duration: t.duration,
                tracks: e
            }, i = 0, o = n.length; i !== o; ++i)
                e.push(Na.toJSON(n[i]));
            return r
        },
        CreateFromMorphTargetSequence: function(t, e, n, r) {
            for (var i = e.length, o = [], a = 0; a < i; a++) {
                var s = []
                  , c = [];
                s.push((a + i - 1) % i, a, (a + 1) % i),
                c.push(0, 1, 0);
                var h = Ua.getKeyframeOrder(s);
                s = Ua.sortedArray(s, 1, h),
                c = Ua.sortedArray(c, 1, h),
                r || 0 !== s[0] || (s.push(i),
                c.push(c[0])),
                o.push(new Ca(".morphTargetInfluences[" + e[a].name + "]",s,c).scale(1 / n))
            }
            return new za(t,-1,o)
        },
        findByName: function(t, e) {
            var n = t;
            if (!Array.isArray(t)) {
                var r = t;
                n = r.geometry && r.geometry.animations || r.animations
            }
            for (var i = 0; i < n.length; i++)
                if (n[i].name === e)
                    return n[i];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(t, e, n) {
            for (var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                var s = t[o]
                  , c = s.name.match(i);
                if (c && c.length > 1) {
                    var h = r[u = c[1]];
                    h || (r[u] = h = []),
                    h.push(s)
                }
            }
            var l = [];
            for (var u in r)
                l.push(za.CreateFromMorphTargetSequence(u, r[u], e, n));
            return l
        },
        parseAnimation: function(t, e) {
            if (!t)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            for (var n = function(t, e, n, r, i) {
                if (0 !== n.length) {
                    var o = []
                      , a = [];
                    Ua.flattenJSON(n, o, a, r),
                    0 !== o.length && i.push(new t(e,o,a))
                }
            }, r = [], i = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                var h = s[c].keys;
                if (h && 0 !== h.length)
                    if (h[0].morphTargets) {
                        for (var l = {}, u = 0; u < h.length; u++)
                            if (h[u].morphTargets)
                                for (var p = 0; p < h[u].morphTargets.length; p++)
                                    l[h[u].morphTargets[p]] = -1;
                        for (var d in l) {
                            var f = []
                              , m = [];
                            for (p = 0; p !== h[u].morphTargets.length; ++p) {
                                var g = h[u];
                                f.push(g.time),
                                m.push(g.morphTarget === d ? 1 : 0)
                            }
                            r.push(new Ca(".morphTargetInfluence[" + d + "]",f,m))
                        }
                        o = l.length * (a || 1)
                    } else {
                        var v = ".bones[" + e[c].name + "]";
                        n(Ba, v + ".position", h, "pos", r),
                        n(Ra, v + ".quaternion", h, "rot", r),
                        n(Ba, v + ".scale", h, "scl", r)
                    }
            }
            return 0 === r.length ? null : new za(i,o,r)
        }
    }),
    Object.assign(za.prototype, {
        resetDuration: function() {
            for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
                var r = this.tracks[e];
                t = Math.max(t, r.times[r.times.length - 1])
            }
            this.duration = t
        },
        trim: function() {
            for (var t = 0; t < this.tracks.length; t++)
                this.tracks[t].trim(0, this.duration);
            return this
        },
        optimize: function() {
            for (var t = 0; t < this.tracks.length; t++)
                this.tracks[t].optimize();
            return this
        }
    }),
    Object.assign(Fa.prototype, {
        load: function(t, e, n, r) {
            var i = this;
            new ko(i.manager).load(t, function(t) {
                e(i.parse(JSON.parse(t)))
            }, n, r)
        },
        setTextures: function(t) {
            this.textures = t
        },
        parse: function(t) {
            var e = this.textures;
            function n(t) {
                return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t),
                e[t]
            }
            var r = new Uo[t.type];
            if (void 0 !== t.uuid && (r.uuid = t.uuid),
            void 0 !== t.name && (r.name = t.name),
            void 0 !== t.color && r.color.setHex(t.color),
            void 0 !== t.roughness && (r.roughness = t.roughness),
            void 0 !== t.metalness && (r.metalness = t.metalness),
            void 0 !== t.emissive && r.emissive.setHex(t.emissive),
            void 0 !== t.specular && r.specular.setHex(t.specular),
            void 0 !== t.shininess && (r.shininess = t.shininess),
            void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat),
            void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness),
            void 0 !== t.uniforms && (r.uniforms = t.uniforms),
            void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader),
            void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors),
            void 0 !== t.fog && (r.fog = t.fog),
            void 0 !== t.flatShading && (r.flatShading = t.flatShading),
            void 0 !== t.blending && (r.blending = t.blending),
            void 0 !== t.side && (r.side = t.side),
            void 0 !== t.opacity && (r.opacity = t.opacity),
            void 0 !== t.transparent && (r.transparent = t.transparent),
            void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (r.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite),
            void 0 !== t.wireframe && (r.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (r.rotation = t.rotation),
            1 !== t.linewidth && (r.linewidth = t.linewidth),
            void 0 !== t.dashSize && (r.dashSize = t.dashSize),
            void 0 !== t.gapSize && (r.gapSize = t.gapSize),
            void 0 !== t.scale && (r.scale = t.scale),
            void 0 !== t.skinning && (r.skinning = t.skinning),
            void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets),
            void 0 !== t.dithering && (r.dithering = t.dithering),
            void 0 !== t.visible && (r.visible = t.visible),
            void 0 !== t.userData && (r.userData = t.userData),
            void 0 !== t.shading && (r.flatShading = 1 === t.shading),
            void 0 !== t.size && (r.size = t.size),
            void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (r.map = n(t.map)),
            void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap),
            r.transparent = !0),
            void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)),
            void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)),
            void 0 !== t.normalScale) {
                var i = t.normalScale;
                !1 === Array.isArray(i) && (i = [i, i]),
                r.normalScale = (new Ne).fromArray(i)
            }
            return void 0 !== t.displacementMap && (r.displacementMap = n(t.displacementMap)),
            void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)),
            void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)),
            void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)),
            void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)),
            void 0 !== t.envMap && (r.envMap = n(t.envMap)),
            void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity),
            void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)),
            void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)),
            void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)),
            r
        }
    }),
    Object.assign(ka.prototype, {
        load: function(t, e, n, r) {
            var i = this;
            new ko(i.manager).load(t, function(t) {
                e(i.parse(JSON.parse(t)))
            }, n, r)
        },
        parse: function(t) {
            var e = new yr
              , n = t.data.index;
            if (void 0 !== n) {
                var r = new Ha[n.type](n.array);
                e.setIndex(new or(r,1))
            }
            var i = t.data.attributes;
            for (var o in i) {
                var a = i[o];
                r = new Ha[a.type](a.array),
                e.addAttribute(o, new or(r,a.itemSize,a.normalized))
            }
            var s = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== s)
                for (var c = 0, h = s.length; c !== h; ++c) {
                    var l = s[c];
                    e.addGroup(l.start, l.count, l.materialIndex)
                }
            var u = t.data.boundingSphere;
            if (void 0 !== u) {
                var p = new Fe;
                void 0 !== u.center && p.fromArray(u.center),
                e.boundingSphere = new Yn(p,u.radius)
            }
            return e
        }
    });
    var Ha = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function Ga() {
        this.onLoadStart = function() {}
        ,
        this.onLoadProgress = function() {}
        ,
        this.onLoadComplete = function() {}
    }
    Ga.Handlers = {
        handlers: [],
        add: function(t, e) {
            this.handlers.push(t, e)
        },
        get: function(t) {
            for (var e = this.handlers, n = 0, r = e.length; n < r; n += 2) {
                var i = e[n]
                  , o = e[n + 1];
                if (i.test(t))
                    return o
            }
            return null
        }
    },
    Object.assign(Ga.prototype, {
        crossOrigin: void 0,
        initMaterials: function(t, e, n) {
            for (var r = [], i = 0; i < t.length; ++i)
                r[i] = this.createMaterial(t[i], e, n);
            return r
        },
        createMaterial: function() {
            var t = {
                NoBlending: _,
                NormalBlending: E,
                AdditiveBlending: S,
                SubtractiveBlending: T,
                MultiplyBlending: A,
                CustomBlending: L
            }
              , e = new Un
              , n = new Wo
              , r = new Fa;
            return function(i, o, a) {
                var s = {};
                function c(t, e, r, i, c) {
                    var h, l = o + t, u = Ga.Handlers.get(l);
                    null !== u ? h = u.load(l) : (n.setCrossOrigin(a),
                    h = n.load(l)),
                    void 0 !== e && (h.repeat.fromArray(e),
                    1 !== e[0] && (h.wrapS = mt),
                    1 !== e[1] && (h.wrapT = mt)),
                    void 0 !== r && h.offset.fromArray(r),
                    void 0 !== i && ("repeat" === i[0] && (h.wrapS = mt),
                    "mirror" === i[0] && (h.wrapS = vt),
                    "repeat" === i[1] && (h.wrapT = mt),
                    "mirror" === i[1] && (h.wrapT = vt)),
                    void 0 !== c && (h.anisotropy = c);
                    var p = Ue.generateUUID();
                    return s[p] = h,
                    p
                }
                var h = {
                    uuid: Ue.generateUUID(),
                    type: "MeshLambertMaterial"
                };
                for (var l in i) {
                    var u = i[l];
                    switch (l) {
                    case "DbgColor":
                    case "DbgIndex":
                    case "opticalDensity":
                    case "illumination":
                        break;
                    case "DbgName":
                        h.name = u;
                        break;
                    case "blending":
                        h.blending = t[u];
                        break;
                    case "colorAmbient":
                    case "mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                        break;
                    case "colorDiffuse":
                        h.color = e.fromArray(u).getHex();
                        break;
                    case "colorSpecular":
                        h.specular = e.fromArray(u).getHex();
                        break;
                    case "colorEmissive":
                        h.emissive = e.fromArray(u).getHex();
                        break;
                    case "specularCoef":
                        h.shininess = u;
                        break;
                    case "shading":
                        "basic" === u.toLowerCase() && (h.type = "MeshBasicMaterial"),
                        "phong" === u.toLowerCase() && (h.type = "MeshPhongMaterial"),
                        "standard" === u.toLowerCase() && (h.type = "MeshStandardMaterial");
                        break;
                    case "mapDiffuse":
                        h.map = c(u, i.mapDiffuseRepeat, i.mapDiffuseOffset, i.mapDiffuseWrap, i.mapDiffuseAnisotropy);
                        break;
                    case "mapDiffuseRepeat":
                    case "mapDiffuseOffset":
                    case "mapDiffuseWrap":
                    case "mapDiffuseAnisotropy":
                        break;
                    case "mapEmissive":
                        h.emissiveMap = c(u, i.mapEmissiveRepeat, i.mapEmissiveOffset, i.mapEmissiveWrap, i.mapEmissiveAnisotropy);
                        break;
                    case "mapEmissiveRepeat":
                    case "mapEmissiveOffset":
                    case "mapEmissiveWrap":
                    case "mapEmissiveAnisotropy":
                        break;
                    case "mapLight":
                        h.lightMap = c(u, i.mapLightRepeat, i.mapLightOffset, i.mapLightWrap, i.mapLightAnisotropy);
                        break;
                    case "mapLightRepeat":
                    case "mapLightOffset":
                    case "mapLightWrap":
                    case "mapLightAnisotropy":
                        break;
                    case "mapAO":
                        h.aoMap = c(u, i.mapAORepeat, i.mapAOOffset, i.mapAOWrap, i.mapAOAnisotropy);
                        break;
                    case "mapAORepeat":
                    case "mapAOOffset":
                    case "mapAOWrap":
                    case "mapAOAnisotropy":
                        break;
                    case "mapBump":
                        h.bumpMap = c(u, i.mapBumpRepeat, i.mapBumpOffset, i.mapBumpWrap, i.mapBumpAnisotropy);
                        break;
                    case "mapBumpScale":
                        h.bumpScale = u;
                        break;
                    case "mapBumpRepeat":
                    case "mapBumpOffset":
                    case "mapBumpWrap":
                    case "mapBumpAnisotropy":
                        break;
                    case "mapNormal":
                        h.normalMap = c(u, i.mapNormalRepeat, i.mapNormalOffset, i.mapNormalWrap, i.mapNormalAnisotropy);
                        break;
                    case "mapNormalFactor":
                        h.normalScale = [u, u];
                        break;
                    case "mapNormalRepeat":
                    case "mapNormalOffset":
                    case "mapNormalWrap":
                    case "mapNormalAnisotropy":
                        break;
                    case "mapSpecular":
                        h.specularMap = c(u, i.mapSpecularRepeat, i.mapSpecularOffset, i.mapSpecularWrap, i.mapSpecularAnisotropy);
                        break;
                    case "mapSpecularRepeat":
                    case "mapSpecularOffset":
                    case "mapSpecularWrap":
                    case "mapSpecularAnisotropy":
                        break;
                    case "mapMetalness":
                        h.metalnessMap = c(u, i.mapMetalnessRepeat, i.mapMetalnessOffset, i.mapMetalnessWrap, i.mapMetalnessAnisotropy);
                        break;
                    case "mapMetalnessRepeat":
                    case "mapMetalnessOffset":
                    case "mapMetalnessWrap":
                    case "mapMetalnessAnisotropy":
                        break;
                    case "mapRoughness":
                        h.roughnessMap = c(u, i.mapRoughnessRepeat, i.mapRoughnessOffset, i.mapRoughnessWrap, i.mapRoughnessAnisotropy);
                        break;
                    case "mapRoughnessRepeat":
                    case "mapRoughnessOffset":
                    case "mapRoughnessWrap":
                    case "mapRoughnessAnisotropy":
                        break;
                    case "mapAlpha":
                        h.alphaMap = c(u, i.mapAlphaRepeat, i.mapAlphaOffset, i.mapAlphaWrap, i.mapAlphaAnisotropy);
                        break;
                    case "mapAlphaRepeat":
                    case "mapAlphaOffset":
                    case "mapAlphaWrap":
                    case "mapAlphaAnisotropy":
                        break;
                    case "flipSided":
                        h.side = g;
                        break;
                    case "doubleSided":
                        h.side = v;
                        break;
                    case "transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                        h.opacity = u;
                        break;
                    case "depthTest":
                    case "depthWrite":
                    case "colorWrite":
                    case "opacity":
                    case "reflectivity":
                    case "transparent":
                    case "visible":
                    case "wireframe":
                        h[l] = u;
                        break;
                    case "vertexColors":
                        !0 === u && (h.vertexColors = M),
                        "face" === u && (h.vertexColors = b);
                        break;
                    default:
                        console.error("THREE.Loader.createMaterial: Unsupported", l, u)
                    }
                }
                return "MeshBasicMaterial" === h.type && delete h.emissive,
                "MeshPhongMaterial" !== h.type && delete h.specular,
                h.opacity < 1 && (h.transparent = !0),
                r.setTextures(s),
                r.parse(h)
            }
        }()
    });
    var Va = {
        decodeText: function(t) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(t);
            for (var e = "", n = 0, r = t.length; n < r; n++)
                e += String.fromCharCode(t[n]);
            return decodeURIComponent(escape(e))
        },
        extractUrlBase: function(t) {
            var e = t.split("/");
            return 1 === e.length ? "./" : (e.pop(),
            e.join("/") + "/")
        }
    };
    function ja(t) {
        "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
        t = void 0),
        this.manager = void 0 !== t ? t : zo,
        this.withCredentials = !1
    }
    function Wa(t) {
        this.manager = void 0 !== t ? t : zo,
        this.texturePath = ""
    }
    Object.assign(ja.prototype, {
        load: function(t, e, n, r) {
            var i = this
              , o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Va.extractUrlBase(t)
              , a = new ko(this.manager);
            a.setWithCredentials(this.withCredentials),
            a.load(t, function(n) {
                var r = JSON.parse(n)
                  , a = r.metadata;
                if (void 0 !== a) {
                    var s = a.type;
                    if (void 0 !== s) {
                        if ("object" === s.toLowerCase())
                            return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === s.toLowerCase())
                            return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                    }
                }
                var c = i.parse(r, o);
                e(c.geometry, c.materials)
            }, n, r)
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        parse: function(t, e) {
            void 0 !== t.data && (t = t.data),
            void 0 !== t.scale ? t.scale = 1 / t.scale : t.scale = 1;
            var n = new ir;
            return function(t, e) {
                function n(t, e) {
                    return t & 1 << e
                }
                var r, i, o, a, s, c, h, l, u, p, d, f, m, g, v, y, x, w, b, M, _, E, S, T, A, L = t.faces, R = t.vertices, P = t.normals, C = t.colors, I = t.scale, O = 0;
                if (void 0 !== t.uvs) {
                    for (r = 0; r < t.uvs.length; r++)
                        t.uvs[r].length && O++;
                    for (r = 0; r < O; r++)
                        e.faceVertexUvs[r] = []
                }
                for (a = 0,
                s = R.length; a < s; )
                    (w = new Fe).x = R[a++] * I,
                    w.y = R[a++] * I,
                    w.z = R[a++] * I,
                    e.vertices.push(w);
                for (a = 0,
                s = L.length; a < s; )
                    if (d = n(p = L[a++], 0),
                    f = n(p, 1),
                    m = n(p, 3),
                    g = n(p, 4),
                    v = n(p, 5),
                    y = n(p, 6),
                    x = n(p, 7),
                    d) {
                        if ((M = new nr).a = L[a],
                        M.b = L[a + 1],
                        M.c = L[a + 3],
                        (_ = new nr).a = L[a + 1],
                        _.b = L[a + 2],
                        _.c = L[a + 3],
                        a += 4,
                        f && (u = L[a++],
                        M.materialIndex = u,
                        _.materialIndex = u),
                        o = e.faces.length,
                        m)
                            for (r = 0; r < O; r++)
                                for (T = t.uvs[r],
                                e.faceVertexUvs[r][o] = [],
                                e.faceVertexUvs[r][o + 1] = [],
                                i = 0; i < 4; i++)
                                    A = new Ne(T[2 * (l = L[a++])],T[2 * l + 1]),
                                    2 !== i && e.faceVertexUvs[r][o].push(A),
                                    0 !== i && e.faceVertexUvs[r][o + 1].push(A);
                        if (g && (h = 3 * L[a++],
                        M.normal.set(P[h++], P[h++], P[h]),
                        _.normal.copy(M.normal)),
                        v)
                            for (r = 0; r < 4; r++)
                                h = 3 * L[a++],
                                S = new Fe(P[h++],P[h++],P[h]),
                                2 !== r && M.vertexNormals.push(S),
                                0 !== r && _.vertexNormals.push(S);
                        if (y && (E = C[c = L[a++]],
                        M.color.setHex(E),
                        _.color.setHex(E)),
                        x)
                            for (r = 0; r < 4; r++)
                                E = C[c = L[a++]],
                                2 !== r && M.vertexColors.push(new Un(E)),
                                0 !== r && _.vertexColors.push(new Un(E));
                        e.faces.push(M),
                        e.faces.push(_)
                    } else {
                        if ((b = new nr).a = L[a++],
                        b.b = L[a++],
                        b.c = L[a++],
                        f && (u = L[a++],
                        b.materialIndex = u),
                        o = e.faces.length,
                        m)
                            for (r = 0; r < O; r++)
                                for (T = t.uvs[r],
                                e.faceVertexUvs[r][o] = [],
                                i = 0; i < 3; i++)
                                    A = new Ne(T[2 * (l = L[a++])],T[2 * l + 1]),
                                    e.faceVertexUvs[r][o].push(A);
                        if (g && (h = 3 * L[a++],
                        b.normal.set(P[h++], P[h++], P[h])),
                        v)
                            for (r = 0; r < 3; r++)
                                h = 3 * L[a++],
                                S = new Fe(P[h++],P[h++],P[h]),
                                b.vertexNormals.push(S);
                        if (y && (c = L[a++],
                        b.color.setHex(C[c])),
                        x)
                            for (r = 0; r < 3; r++)
                                c = L[a++],
                                b.vertexColors.push(new Un(C[c]));
                        e.faces.push(b)
                    }
            }(t, n),
            function(t, e) {
                var n = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                if (t.skinWeights)
                    for (var r = 0, i = t.skinWeights.length; r < i; r += n) {
                        var o = t.skinWeights[r]
                          , a = n > 1 ? t.skinWeights[r + 1] : 0
                          , s = n > 2 ? t.skinWeights[r + 2] : 0
                          , c = n > 3 ? t.skinWeights[r + 3] : 0;
                        e.skinWeights.push(new Ve(o,a,s,c))
                    }
                if (t.skinIndices)
                    for (r = 0,
                    i = t.skinIndices.length; r < i; r += n) {
                        var h = t.skinIndices[r]
                          , l = n > 1 ? t.skinIndices[r + 1] : 0
                          , u = n > 2 ? t.skinIndices[r + 2] : 0
                          , p = n > 3 ? t.skinIndices[r + 3] : 0;
                        e.skinIndices.push(new Ve(h,l,u,p))
                    }
                e.bones = t.bones,
                e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
            }(t, n),
            function(t, e) {
                var n = t.scale;
                if (void 0 !== t.morphTargets)
                    for (var r = 0, i = t.morphTargets.length; r < i; r++) {
                        e.morphTargets[r] = {},
                        e.morphTargets[r].name = t.morphTargets[r].name,
                        e.morphTargets[r].vertices = [];
                        for (var o = e.morphTargets[r].vertices, a = t.morphTargets[r].vertices, s = 0, c = a.length; s < c; s += 3) {
                            var h = new Fe;
                            h.x = a[s] * n,
                            h.y = a[s + 1] * n,
                            h.z = a[s + 2] * n,
                            o.push(h)
                        }
                    }
                if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    var l = e.faces
                      , u = t.morphColors[0].colors;
                    for (r = 0,
                    i = l.length; r < i; r++)
                        l[r].color.fromArray(u, 3 * r)
                }
            }(t, n),
            function(t, e) {
                var n = []
                  , r = [];
                void 0 !== t.animation && r.push(t.animation),
                void 0 !== t.animations && (t.animations.length ? r = r.concat(t.animations) : r.push(t.animations));
                for (var i = 0; i < r.length; i++) {
                    var o = za.parseAnimation(r[i], e.bones);
                    o && n.push(o)
                }
                if (e.morphTargets) {
                    var a = za.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                    n = n.concat(a)
                }
                n.length > 0 && (e.animations = n)
            }(t, n),
            n.computeFaceNormals(),
            n.computeBoundingSphere(),
            void 0 === t.materials || 0 === t.materials.length ? {
                geometry: n
            } : {
                geometry: n,
                materials: Ga.prototype.initMaterials(t.materials, e, this.crossOrigin)
            }
        }
    }),
    Object.assign(Wa.prototype, {
        load: function(t, e, n, r) {
            "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
            var i = this;
            new ko(i.manager).load(t, function(n) {
                var o = null;
                try {
                    o = JSON.parse(n)
                } catch (e) {
                    return void 0 !== r && r(e),
                    void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                }
                var a = o.metadata;
                void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? i.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.")
            }, n, r)
        },
        setTexturePath: function(t) {
            this.texturePath = t
        },
        setCrossOrigin: function(t) {
            this.crossOrigin = t
        },
        parse: function(t, e) {
            var n = this.parseShape(t.shapes)
              , r = this.parseGeometries(t.geometries, n)
              , i = this.parseImages(t.images, function() {
                void 0 !== e && e(s)
            })
              , o = this.parseTextures(t.textures, i)
              , a = this.parseMaterials(t.materials, o)
              , s = this.parseObject(t.object, r, a);
            return t.animations && (s.animations = this.parseAnimations(t.animations)),
            void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s),
            s
        },
        parseShape: function(t) {
            var e = {};
            if (void 0 !== t)
                for (var n = 0, r = t.length; n < r; n++) {
                    var i = (new fa).fromJSON(t[n]);
                    e[i.uuid] = i
                }
            return e
        },
        parseGeometries: function(t, e) {
            var n = {};
            if (void 0 !== t)
                for (var r = new ja, i = new ka, o = 0, a = t.length; o < a; o++) {
                    var s, c = t[o];
                    switch (c.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        s = new So[c.type](c.width,c.height,c.widthSegments,c.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        s = new So[c.type](c.width,c.height,c.depth,c.widthSegments,c.heightSegments,c.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        s = new So[c.type](c.radius,c.segments,c.thetaStart,c.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        s = new So[c.type](c.radiusTop,c.radiusBottom,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        s = new So[c.type](c.radius,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        s = new So[c.type](c.radius,c.widthSegments,c.heightSegments,c.phiStart,c.phiLength,c.thetaStart,c.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        s = new So[c.type](c.radius,c.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        s = new So[c.type](c.innerRadius,c.outerRadius,c.thetaSegments,c.phiSegments,c.thetaStart,c.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        s = new So[c.type](c.radius,c.tube,c.radialSegments,c.tubularSegments,c.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        s = new So[c.type](c.radius,c.tube,c.tubularSegments,c.radialSegments,c.p,c.q);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        s = new So[c.type](c.points,c.segments,c.phiStart,c.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        s = new So[c.type](c.vertices,c.indices,c.radius,c.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        var h = [];
                        for (o = 0,
                        a = c.shapes.length; o < a; o++) {
                            var l = e[c.shapes[o]];
                            h.push(l)
                        }
                        s = new So[c.type](h,c.curveSegments);
                        break;
                    case "BufferGeometry":
                        s = i.parse(c);
                        break;
                    case "Geometry":
                        s = r.parse(c, this.texturePath).geometry;
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
                        continue
                    }
                    s.uuid = c.uuid,
                    void 0 !== c.name && (s.name = c.name),
                    n[c.uuid] = s
                }
            return n
        },
        parseMaterials: function(t, e) {
            var n = {};
            if (void 0 !== t) {
                var r = new Fa;
                r.setTextures(e);
                for (var i = 0, o = t.length; i < o; i++) {
                    var a = t[i];
                    if ("MultiMaterial" === a.type) {
                        for (var s = [], c = 0; c < a.materials.length; c++)
                            s.push(r.parse(a.materials[c]));
                        n[a.uuid] = s
                    } else
                        n[a.uuid] = r.parse(a)
                }
            }
            return n
        },
        parseAnimations: function(t) {
            for (var e = [], n = 0; n < t.length; n++) {
                var r = za.parse(t[n]);
                e.push(r)
            }
            return e
        },
        parseImages: function(t, e) {
            var n = this
              , r = {};
            function i(t) {
                return n.manager.itemStart(t),
                o.load(t, function() {
                    n.manager.itemEnd(t)
                }, void 0, function() {
                    n.manager.itemEnd(t),
                    n.manager.itemError(t)
                })
            }
            if (void 0 !== t && t.length > 0) {
                var o = new Vo(new Bo(e));
                o.setCrossOrigin(this.crossOrigin);
                for (var a = 0, s = t.length; a < s; a++) {
                    var c = t[a]
                      , h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.texturePath + c.url;
                    r[c.uuid] = i(h)
                }
            }
            return r
        },
        parseTextures: function(t, e) {
            function n(t, e) {
                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t),
                e[t])
            }
            var r = {};
            if (void 0 !== t)
                for (var i = 0, o = t.length; i < o; i++) {
                    var a = t[i];
                    void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                    void 0 === e[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                    var s = new Ge(e[a.image]);
                    s.needsUpdate = !0,
                    s.uuid = a.uuid,
                    void 0 !== a.name && (s.name = a.name),
                    void 0 !== a.mapping && (s.mapping = n(a.mapping, Xa)),
                    void 0 !== a.offset && s.offset.fromArray(a.offset),
                    void 0 !== a.repeat && s.repeat.fromArray(a.repeat),
                    void 0 !== a.center && s.center.fromArray(a.center),
                    void 0 !== a.rotation && (s.rotation = a.rotation),
                    void 0 !== a.wrap && (s.wrapS = n(a.wrap[0], qa),
                    s.wrapT = n(a.wrap[1], qa)),
                    void 0 !== a.minFilter && (s.minFilter = n(a.minFilter, Za)),
                    void 0 !== a.magFilter && (s.magFilter = n(a.magFilter, Za)),
                    void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy),
                    void 0 !== a.flipY && (s.flipY = a.flipY),
                    r[a.uuid] = s
                }
            return r
        },
        parseObject: function(t, e, n) {
            var r;
            function i(t) {
                return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t),
                e[t]
            }
            function o(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        for (var e = [], r = 0, i = t.length; r < i; r++) {
                            var o = t[r];
                            void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o),
                            e.push(n[o])
                        }
                        return e
                    }
                    return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t),
                    n[t]
                }
            }
            switch (t.type) {
            case "Scene":
                r = new Qr,
                void 0 !== t.background && Number.isInteger(t.background) && (r.background = new Un(t.background)),
                void 0 !== t.fog && ("Fog" === t.fog.type ? r.fog = new Kr(t.fog.color,t.fog.near,t.fog.far) : "FogExp2" === t.fog.type && (r.fog = new Jr(t.fog.color,t.fog.density)));
                break;
            case "PerspectiveCamera":
                r = new Vr(t.fov,t.aspect,t.near,t.far),
                void 0 !== t.focus && (r.focus = t.focus),
                void 0 !== t.zoom && (r.zoom = t.zoom),
                void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge),
                void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset),
                void 0 !== t.view && (r.view = Object.assign({}, t.view));
                break;
            case "OrthographicCamera":
                r = new er(t.left,t.right,t.top,t.bottom,t.near,t.far);
                break;
            case "AmbientLight":
                r = new _a(t.color,t.intensity);
                break;
            case "DirectionalLight":
                r = new Ma(t.color,t.intensity);
                break;
            case "PointLight":
                r = new wa(t.color,t.intensity,t.distance,t.decay);
                break;
            case "RectAreaLight":
                r = new Ea(t.color,t.intensity,t.width,t.height);
                break;
            case "SpotLight":
                r = new xa(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);
                break;
            case "HemisphereLight":
                r = new ga(t.color,t.groundColor,t.intensity);
                break;
            case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
                var a = i(t.geometry)
                  , s = o(t.material);
                r = a.bones && a.bones.length > 0 ? new ii(a,s) : new Lr(a,s);
                break;
            case "LOD":
                r = new ei;
                break;
            case "Line":
                r = new ai(i(t.geometry),o(t.material),t.mode);
                break;
            case "LineLoop":
                r = new ci(i(t.geometry),o(t.material));
                break;
            case "LineSegments":
                r = new si(i(t.geometry),o(t.material));
                break;
            case "PointCloud":
            case "Points":
                r = new li(i(t.geometry),o(t.material));
                break;
            case "Sprite":
                r = new ti(o(t.material));
                break;
            case "Group":
                r = new ui;
                break;
            default:
                r = new $n
            }
            if (r.uuid = t.uuid,
            void 0 !== t.name && (r.name = t.name),
            void 0 !== t.matrix ? (r.matrix.fromArray(t.matrix),
            r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== t.position && r.position.fromArray(t.position),
            void 0 !== t.rotation && r.rotation.fromArray(t.rotation),
            void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion),
            void 0 !== t.scale && r.scale.fromArray(t.scale)),
            void 0 !== t.castShadow && (r.castShadow = t.castShadow),
            void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow),
            t.shadow && (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias),
            void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius),
            void 0 !== t.shadow.mapSize && r.shadow.mapSize.fromArray(t.shadow.mapSize),
            void 0 !== t.shadow.camera && (r.shadow.camera = this.parseObject(t.shadow.camera))),
            void 0 !== t.visible && (r.visible = t.visible),
            void 0 !== t.userData && (r.userData = t.userData),
            void 0 !== t.children)
                for (var c = t.children, h = 0; h < c.length; h++)
                    r.add(this.parseObject(c[h], e, n));
            if ("LOD" === t.type)
                for (var l = t.levels, u = 0; u < l.length; u++) {
                    var p = l[u]
                      , d = r.getObjectByProperty("uuid", p.object);
                    void 0 !== d && r.addLevel(d, p.distance)
                }
            return r
        }
    });
    var Ya, Xa = {
        UVMapping: st,
        CubeReflectionMapping: ct,
        CubeRefractionMapping: ht,
        EquirectangularReflectionMapping: lt,
        EquirectangularRefractionMapping: ut,
        SphericalReflectionMapping: pt,
        CubeUVReflectionMapping: dt,
        CubeUVRefractionMapping: ft
    }, qa = {
        RepeatWrapping: mt,
        ClampToEdgeWrapping: gt,
        MirroredRepeatWrapping: vt
    }, Za = {
        NearestFilter: yt,
        NearestMipMapNearestFilter: xt,
        NearestMipMapLinearFilter: wt,
        LinearFilter: bt,
        LinearMipMapNearestFilter: Mt,
        LinearMipMapLinearFilter: _t
    };
    function Ja(t) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.manager = void 0 !== t ? t : zo,
        this.options = void 0
    }
    function Ka() {
        this.type = "ShapePath",
        this.subPaths = [],
        this.currentPath = null
    }
    function Qa(t) {
        this.type = "Font",
        this.data = t
    }
    function $a(t, e, n, r, i, o) {
        var a = o.glyphs[t] || o.glyphs["?"];
        if (a) {
            var s, c, h, l, u, p, d, f, m = new Ka;
            if (a.o)
                for (var g = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, y = g.length; v < y; )
                    switch (g[v++]) {
                    case "m":
                        s = g[v++] * n + r,
                        c = g[v++] * n + i,
                        m.moveTo(s, c);
                        break;
                    case "l":
                        s = g[v++] * n + r,
                        c = g[v++] * n + i,
                        m.lineTo(s, c);
                        break;
                    case "q":
                        h = g[v++] * n + r,
                        l = g[v++] * n + i,
                        u = g[v++] * n + r,
                        p = g[v++] * n + i,
                        m.quadraticCurveTo(u, p, h, l);
                        break;
                    case "b":
                        h = g[v++] * n + r,
                        l = g[v++] * n + i,
                        u = g[v++] * n + r,
                        p = g[v++] * n + i,
                        d = g[v++] * n + r,
                        f = g[v++] * n + i,
                        m.bezierCurveTo(u, p, d, f, h, l)
                    }
            return {
                offsetX: a.ha * n,
                path: m
            }
        }
    }
    function ts(t) {
        this.manager = void 0 !== t ? t : zo
    }
    Ja.prototype = {
        constructor: Ja,
        setOptions: function(t) {
            return this.options = t,
            this
        },
        load: function(t, e, n, r) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t);
            var i = this
              , o = No.get(t);
            if (void 0 !== o)
                return i.manager.itemStart(t),
                setTimeout(function() {
                    e && e(o),
                    i.manager.itemEnd(t)
                }, 0),
                o;
            fetch(t).then(function(t) {
                return t.blob()
            }).then(function(t) {
                return createImageBitmap(t, i.options)
            }).then(function(n) {
                No.add(t, n),
                e && e(n),
                i.manager.itemEnd(t)
            }).catch(function(e) {
                r && r(e),
                i.manager.itemEnd(t),
                i.manager.itemError(t)
            })
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    },
    Object.assign(Ka.prototype, {
        moveTo: function(t, e) {
            this.currentPath = new da,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e)
        },
        lineTo: function(t, e) {
            this.currentPath.lineTo(t, e)
        },
        quadraticCurveTo: function(t, e, n, r) {
            this.currentPath.quadraticCurveTo(t, e, n, r)
        },
        bezierCurveTo: function(t, e, n, r, i, o) {
            this.currentPath.bezierCurveTo(t, e, n, r, i, o)
        },
        splineThru: function(t) {
            this.currentPath.splineThru(t)
        },
        toShapes: function(t, e) {
            function n(t) {
                for (var e = [], n = 0, r = t.length; n < r; n++) {
                    var i = t[n]
                      , o = new fa;
                    o.curves = i.curves,
                    e.push(o)
                }
                return e
            }
            function r(t, e) {
                for (var n = e.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                    var a = e[i]
                      , s = e[o]
                      , c = s.x - a.x
                      , h = s.y - a.y;
                    if (Math.abs(h) > Number.EPSILON) {
                        if (h < 0 && (a = e[o],
                        c = -c,
                        s = e[i],
                        h = -h),
                        t.y < a.y || t.y > s.y)
                            continue;
                        if (t.y === a.y) {
                            if (t.x === a.x)
                                return !0
                        } else {
                            var l = h * (t.x - a.x) - c * (t.y - a.y);
                            if (0 === l)
                                return !0;
                            if (l < 0)
                                continue;
                            r = !r
                        }
                    } else {
                        if (t.y !== a.y)
                            continue;
                        if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x)
                            return !0
                    }
                }
                return r
            }
            var i = eo.isClockWise
              , o = this.subPaths;
            if (0 === o.length)
                return [];
            if (!0 === e)
                return n(o);
            var a, s, c, h = [];
            if (1 === o.length)
                return s = o[0],
                (c = new fa).curves = s.curves,
                h.push(c),
                h;
            var l = !i(o[0].getPoints());
            l = t ? !l : l;
            var u, p, d = [], f = [], m = [], g = 0;
            f[g] = void 0,
            m[g] = [];
            for (var v = 0, y = o.length; v < y; v++)
                a = i(u = (s = o[v]).getPoints()),
                (a = t ? !a : a) ? (!l && f[g] && g++,
                f[g] = {
                    s: new fa,
                    p: u
                },
                f[g].s.curves = s.curves,
                l && g++,
                m[g] = []) : m[g].push({
                    h: s,
                    p: u[0]
                });
            if (!f[0])
                return n(o);
            if (f.length > 1) {
                for (var x = !1, w = [], b = 0, M = f.length; b < M; b++)
                    d[b] = [];
                for (b = 0,
                M = f.length; b < M; b++)
                    for (var _ = m[b], E = 0; E < _.length; E++) {
                        for (var S = _[E], T = !0, A = 0; A < f.length; A++)
                            r(S.p, f[A].p) && (b !== A && w.push({
                                froms: b,
                                tos: A,
                                hole: E
                            }),
                            T ? (T = !1,
                            d[A].push(S)) : x = !0);
                        T && d[b].push(S)
                    }
                w.length > 0 && (x || (m = d))
            }
            v = 0;
            for (var L = f.length; v < L; v++) {
                c = f[v].s,
                h.push(c);
                for (var R = 0, P = (p = m[v]).length; R < P; R++)
                    c.holes.push(p[R].h)
            }
            return h
        }
    }),
    Object.assign(Qa.prototype, {
        isFont: !0,
        generateShapes: function(t, e, n) {
            void 0 === e && (e = 100),
            void 0 === n && (n = 4);
            for (var r = [], i = function(t, e, n, r) {
                for (var i = String(t).split(""), o = e / r.resolution, a = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * o, s = [], c = 0, h = 0, l = 0; l < i.length; l++) {
                    var u = i[l];
                    if ("\n" === u)
                        c = 0,
                        h -= a;
                    else {
                        var p = $a(u, 0, o, c, h, r);
                        c += p.offsetX,
                        s.push(p.path)
                    }
                }
                return s
            }(t, e, 0, this.data), o = 0, a = i.length; o < a; o++)
                Array.prototype.push.apply(r, i[o].toShapes());
            return r
        }
    }),
    Object.assign(ts.prototype, {
        load: function(t, e, n, r) {
            var i = this
              , o = new ko(this.manager);
            o.setPath(this.path),
            o.load(t, function(t) {
                var n;
                try {
                    n = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                    n = JSON.parse(t.substring(65, t.length - 2))
                }
                var r = i.parse(n);
                e && e(r)
            }, n, r)
        },
        parse: function(t) {
            return new Qa(t)
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    });
    var es, ns, rs = {
        getContext: function() {
            return void 0 === Ya && (Ya = new (window.AudioContext || window.webkitAudioContext)),
            Ya
        },
        setContext: function(t) {
            Ya = t
        }
    };
    function is(t) {
        this.manager = void 0 !== t ? t : zo
    }
    function os() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Vr,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Vr,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1
    }
    function as(t, e, n) {
        $n.call(this),
        this.type = "CubeCamera";
        var r = new Vr(90,1,t,e);
        r.up.set(0, -1, 0),
        r.lookAt(new Fe(1,0,0)),
        this.add(r);
        var i = new Vr(90,1,t,e);
        i.up.set(0, -1, 0),
        i.lookAt(new Fe(-1,0,0)),
        this.add(i);
        var o = new Vr(90,1,t,e);
        o.up.set(0, 0, 1),
        o.lookAt(new Fe(0,1,0)),
        this.add(o);
        var a = new Vr(90,1,t,e);
        a.up.set(0, 0, -1),
        a.lookAt(new Fe(0,-1,0)),
        this.add(a);
        var s = new Vr(90,1,t,e);
        s.up.set(0, -1, 0),
        s.lookAt(new Fe(0,0,1)),
        this.add(s);
        var c = new Vr(90,1,t,e);
        c.up.set(0, -1, 0),
        c.lookAt(new Fe(0,0,-1)),
        this.add(c);
        var h = {
            format: Bt,
            magFilter: bt,
            minFilter: bt
        };
        this.renderTarget = new We(n,n,h),
        this.renderTarget.texture.name = "CubeCamera",
        this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var n = this.renderTarget
              , h = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            n.activeCubeFace = 0,
            t.render(e, r, n),
            n.activeCubeFace = 1,
            t.render(e, i, n),
            n.activeCubeFace = 2,
            t.render(e, o, n),
            n.activeCubeFace = 3,
            t.render(e, a, n),
            n.activeCubeFace = 4,
            t.render(e, s, n),
            n.texture.generateMipmaps = h,
            n.activeCubeFace = 5,
            t.render(e, c, n),
            t.setRenderTarget(null)
        }
        ,
        this.clear = function(t, e, n, r) {
            for (var i = this.renderTarget, o = 0; o < 6; o++)
                i.activeCubeFace = o,
                t.setRenderTarget(i),
                t.clear(e, n, r);
            t.setRenderTarget(null)
        }
    }
    function ss() {
        $n.call(this),
        this.type = "AudioListener",
        this.context = rs.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null
    }
    function cs(t) {
        $n.call(this),
        this.type = "Audio",
        this.context = t.context,
        this.gain = this.context.createGain(),
        this.gain.connect(t.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.loop = !1,
        this.startTime = 0,
        this.offset = 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = "empty",
        this.filters = []
    }
    function hs(t) {
        cs.call(this, t),
        this.panner = this.context.createPanner(),
        this.panner.connect(this.gain)
    }
    function ls(t, e) {
        this.analyser = t.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== e ? e : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        t.getOutput().connect(this.analyser)
    }
    function us(t, e, n) {
        this.binding = t,
        this.valueSize = n;
        var r, i = Float64Array;
        switch (e) {
        case "quaternion":
            r = this._slerp;
            break;
        case "string":
        case "bool":
            i = Array,
            r = this._select;
            break;
        default:
            r = this._lerp
        }
        this.buffer = new i(4 * n),
        this._mixBufferRegion = r,
        this.cumulativeWeight = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    function ps(t, e, n) {
        var r = n || ds.parseTrackName(e);
        this._targetGroup = t,
        this._bindings = t.subscribe_(e, r)
    }
    function ds(t, e, n) {
        this.path = e,
        this.parsedPath = n || ds.parseTrackName(e),
        this.node = ds.findNode(t, this.parsedPath.nodeName) || t,
        this.rootNode = t
    }
    function fs() {
        this.uuid = Ue.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, n = arguments.length; e !== n; ++e)
            t[arguments[e].uuid] = e;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var r = this;
        this.stats = {
            objects: {
                get total() {
                    return r._objects.length
                },
                get inUse() {
                    return this.total - r.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return r._bindings.length
            }
        }
    }
    function ms(t, e, n) {
        this._mixer = t,
        this._clip = e,
        this._localRoot = n || null;
        for (var r = e.tracks, i = r.length, o = new Array(i), a = {
            endingStart: xe,
            endingEnd: xe
        }, s = 0; s !== i; ++s) {
            var c = r[s].createInterpolant(null);
            o[s] = c,
            c.settings = a
        }
        this._interpolantSettings = a,
        this._interpolants = o,
        this._propertyBindings = new Array(i),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = fe,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    function gs(t) {
        this._root = t,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    function vs(t) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        t = arguments[1]),
        this.value = t
    }
    function ys() {
        yr.call(this),
        this.type = "InstancedBufferGeometry",
        this.maxInstancedCount = void 0
    }
    function xs(t, e, n, r) {
        this.uuid = Ue.generateUUID(),
        this.data = t,
        this.itemSize = e,
        this.offset = n,
        this.normalized = !0 === r
    }
    function ws(t, e) {
        this.uuid = Ue.generateUUID(),
        this.array = t,
        this.stride = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.onUploadCallback = function() {}
        ,
        this.version = 0
    }
    function bs(t, e, n) {
        ws.call(this, t, e),
        this.meshPerAttribute = n || 1
    }
    function Ms(t, e, n) {
        or.call(this, t, e),
        this.meshPerAttribute = n || 1
    }
    function _s(t, e, n, r) {
        this.ray = new Sr(t,e),
        this.near = n || 0,
        this.far = r || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function Es(t, e) {
        return t.distance - e.distance
    }
    function Ss(t, e, n, r) {
        if (!1 !== t.visible && (t.raycast(e, n),
        !0 === r))
            for (var i = t.children, o = 0, a = i.length; o < a; o++)
                Ss(i[o], e, n, !0)
    }
    function Ts(t) {
        this.autoStart = void 0 === t || t,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    function As(t, e, n) {
        return this.radius = void 0 !== t ? t : 1,
        this.phi = void 0 !== e ? e : 0,
        this.theta = void 0 !== n ? n : 0,
        this
    }
    function Ls(t, e, n) {
        return this.radius = void 0 !== t ? t : 1,
        this.theta = void 0 !== e ? e : 0,
        this.y = void 0 !== n ? n : 0,
        this
    }
    function Rs(t, e) {
        this.min = void 0 !== t ? t : new Ne(1 / 0,1 / 0),
        this.max = void 0 !== e ? e : new Ne(-1 / 0,-1 / 0)
    }
    function Ps(t) {
        $n.call(this),
        this.material = t,
        this.render = function() {}
    }
    function Cs(t, e, n, r) {
        this.object = t,
        this.size = void 0 !== e ? e : 1;
        var i = void 0 !== n ? n : 16711680
          , o = void 0 !== r ? r : 1
          , a = 0
          , s = this.object.geometry;
        s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
        var c = new yr
          , h = new dr(2 * a * 3,3);
        c.addAttribute("position", h),
        si.call(this, c, new oi({
            color: i,
            linewidth: o
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Is(t, e) {
        $n.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = e;
        for (var n = new yr, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, o = 1; i < 32; i++,
        o++) {
            var a = i / 32 * Math.PI * 2
              , s = o / 32 * Math.PI * 2;
            r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
        }
        n.addAttribute("position", new dr(r,3));
        var c = new oi({
            fog: !1
        });
        this.cone = new si(n,c),
        this.add(this.cone),
        this.update()
    }
    function Os(t) {
        for (var e = function t(e) {
            var n = [];
            e && e.isBone && n.push(e);
            for (var r = 0; r < e.children.length; r++)
                n.push.apply(n, t(e.children[r]));
            return n
        }(t), n = new yr, r = [], i = [], o = new Un(0,0,1), a = new Un(0,1,0), s = 0; s < e.length; s++) {
            var c = e[s];
            c.parent && c.parent.isBone && (r.push(0, 0, 0),
            r.push(0, 0, 0),
            i.push(o.r, o.g, o.b),
            i.push(a.r, a.g, a.b))
        }
        n.addAttribute("position", new dr(r,3)),
        n.addAttribute("color", new dr(i,3));
        var h = new oi({
            vertexColors: M,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        });
        si.call(this, n, h),
        this.root = t,
        this.bones = e,
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function Ds(t, e, n) {
        this.light = t,
        this.light.updateMatrixWorld(),
        this.color = n;
        var r = new ho(e,4,2)
          , i = new _r({
            wireframe: !0,
            fog: !1
        });
        Lr.call(this, r, i),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Us(t, e) {
        $n.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = e;
        var n = new oi({
            fog: !1
        })
          , r = new yr;
        r.addAttribute("position", new or(new Float32Array(15),3)),
        this.line = new ai(r,n),
        this.add(this.line),
        this.update()
    }
    function Ns(t, e, n) {
        $n.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n;
        var r = new _i(e);
        r.rotateY(.5 * Math.PI),
        this.material = new _r({
            wireframe: !0,
            fog: !1
        }),
        void 0 === this.color && (this.material.vertexColors = M);
        var i = r.getAttribute("position")
          , o = new Float32Array(3 * i.count);
        r.addAttribute("color", new or(o,3)),
        this.add(new Lr(r,this.material)),
        this.update()
    }
    function Bs(t, e, n, r) {
        t = t || 10,
        e = e || 10,
        n = new Un(void 0 !== n ? n : 4473924),
        r = new Un(void 0 !== r ? r : 8947848);
        for (var i = e / 2, o = t / e, a = t / 2, s = [], c = [], h = 0, l = 0, u = -a; h <= e; h++,
        u += o) {
            s.push(-a, 0, u, a, 0, u),
            s.push(u, 0, -a, u, 0, a);
            var p = h === i ? n : r;
            p.toArray(c, l),
            l += 3,
            p.toArray(c, l),
            l += 3,
            p.toArray(c, l),
            l += 3,
            p.toArray(c, l),
            l += 3
        }
        var d = new yr;
        d.addAttribute("position", new dr(s,3)),
        d.addAttribute("color", new dr(c,3));
        var f = new oi({
            vertexColors: M
        });
        si.call(this, d, f)
    }
    function zs(t, e, n, r, i, o) {
        t = t || 10,
        e = e || 16,
        n = n || 8,
        r = r || 64,
        i = new Un(void 0 !== i ? i : 4473924),
        o = new Un(void 0 !== o ? o : 8947848);
        var a, s, c, h, l, u, p, d = [], f = [];
        for (h = 0; h <= e; h++)
            c = h / e * (2 * Math.PI),
            a = Math.sin(c) * t,
            s = Math.cos(c) * t,
            d.push(0, 0, 0),
            d.push(a, 0, s),
            p = 1 & h ? i : o,
            f.push(p.r, p.g, p.b),
            f.push(p.r, p.g, p.b);
        for (h = 0; h <= n; h++)
            for (p = 1 & h ? i : o,
            u = t - t / n * h,
            l = 0; l < r; l++)
                c = l / r * (2 * Math.PI),
                a = Math.sin(c) * u,
                s = Math.cos(c) * u,
                d.push(a, 0, s),
                f.push(p.r, p.g, p.b),
                c = (l + 1) / r * (2 * Math.PI),
                a = Math.sin(c) * u,
                s = Math.cos(c) * u,
                d.push(a, 0, s),
                f.push(p.r, p.g, p.b);
        var m = new yr;
        m.addAttribute("position", new dr(d,3)),
        m.addAttribute("color", new dr(f,3));
        var g = new oi({
            vertexColors: M
        });
        si.call(this, m, g)
    }
    function Fs(t, e, n, r) {
        this.object = t,
        this.size = void 0 !== e ? e : 1;
        var i = void 0 !== n ? n : 16776960
          , o = void 0 !== r ? r : 1
          , a = 0
          , s = this.object.geometry;
        s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var c = new yr
          , h = new dr(2 * a * 3,3);
        c.addAttribute("position", h),
        si.call(this, c, new oi({
            color: i,
            linewidth: o
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function ks(t, e, n) {
        $n.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = n,
        void 0 === e && (e = 1);
        var r = new yr;
        r.addAttribute("position", new dr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0],3));
        var i = new oi({
            fog: !1
        });
        this.lightPlane = new ai(r,i),
        this.add(this.lightPlane),
        (r = new yr).addAttribute("position", new dr([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new ai(r,i),
        this.add(this.targetLine),
        this.update()
    }
    function Hs(t) {
        var e = new yr
          , n = new oi({
            color: 16777215,
            vertexColors: b
        })
          , r = []
          , i = []
          , o = {}
          , a = new Un(16755200)
          , s = new Un(16711680)
          , c = new Un(43775)
          , h = new Un(16777215)
          , l = new Un(3355443);
        function u(t, e, n) {
            p(t, n),
            p(e, n)
        }
        function p(t, e) {
            r.push(0, 0, 0),
            i.push(e.r, e.g, e.b),
            void 0 === o[t] && (o[t] = []),
            o[t].push(r.length / 3 - 1)
        }
        u("n1", "n2", a),
        u("n2", "n4", a),
        u("n4", "n3", a),
        u("n3", "n1", a),
        u("f1", "f2", a),
        u("f2", "f4", a),
        u("f4", "f3", a),
        u("f3", "f1", a),
        u("n1", "f1", a),
        u("n2", "f2", a),
        u("n3", "f3", a),
        u("n4", "f4", a),
        u("p", "n1", s),
        u("p", "n2", s),
        u("p", "n3", s),
        u("p", "n4", s),
        u("u1", "u2", c),
        u("u2", "u3", c),
        u("u3", "u1", c),
        u("c", "t", h),
        u("p", "c", l),
        u("cn1", "cn2", l),
        u("cn3", "cn4", l),
        u("cf1", "cf2", l),
        u("cf3", "cf4", l),
        e.addAttribute("position", new dr(r,3)),
        e.addAttribute("color", new dr(i,3)),
        si.call(this, e, n),
        this.camera = t,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update()
    }
    function Gs(t, e) {
        this.object = t,
        void 0 === e && (e = 16776960);
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = new Float32Array(24)
          , i = new yr;
        i.setIndex(new or(n,1)),
        i.addAttribute("position", new or(r,3)),
        si.call(this, i, new oi({
            color: e
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Vs(t, e) {
        this.type = "Box3Helper",
        this.box = t;
        var n = void 0 !== e ? e : 16776960
          , r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , i = new yr;
        i.setIndex(new or(r,1)),
        i.addAttribute("position", new dr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        si.call(this, i, new oi({
            color: n
        })),
        this.geometry.computeBoundingSphere()
    }
    function js(t, e, n) {
        this.type = "PlaneHelper",
        this.plane = t,
        this.size = void 0 === e ? 1 : e;
        var r = void 0 !== n ? n : 16776960
          , i = new yr;
        i.addAttribute("position", new dr([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        i.computeBoundingSphere(),
        ai.call(this, i, new oi({
            color: r
        }));
        var o = new yr;
        o.addAttribute("position", new dr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        o.computeBoundingSphere(),
        this.add(new Lr(o,new _r({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    function Ws(t, e, n, r, i, o) {
        $n.call(this),
        void 0 === r && (r = 16776960),
        void 0 === n && (n = 1),
        void 0 === i && (i = .2 * n),
        void 0 === o && (o = .2 * i),
        void 0 === es && ((es = new yr).addAttribute("position", new dr([0, 0, 0, 0, 1, 0],3)),
        (ns = new wo(0,.5,1,5,1)).translate(0, -.5, 0)),
        this.position.copy(e),
        this.line = new ai(es,new oi({
            color: r
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Lr(ns,new _r({
            color: r
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(t),
        this.setLength(n, i, o)
    }
    function Ys(t) {
        var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]
          , n = new yr;
        n.addAttribute("position", new dr(e,3)),
        n.addAttribute("color", new dr([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3));
        var r = new oi({
            vertexColors: M
        });
        si.call(this, n, r)
    }
    function Xs(t, e, n, r, i, o, a) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
        new nr(t,e,n,i,o,a)
    }
    Object.assign(is.prototype, {
        load: function(t, e, n, r) {
            var i = new ko(this.manager);
            i.setResponseType("arraybuffer"),
            i.load(t, function(t) {
                rs.getContext().decodeAudioData(t, function(t) {
                    e(t)
                })
            }, n, r)
        }
    }),
    Object.assign(os.prototype, {
        update: function() {
            var t, e, n, r, i, o, a, s, c = new Be, h = new Be;
            return function(l) {
                if (t !== this || e !== l.focus || n !== l.fov || r !== l.aspect * this.aspect || i !== l.near || o !== l.far || a !== l.zoom || s !== this.eyeSep) {
                    t = this,
                    e = l.focus,
                    n = l.fov,
                    r = l.aspect * this.aspect,
                    i = l.near,
                    o = l.far,
                    a = l.zoom;
                    var u, p, d = l.projectionMatrix.clone(), f = (s = this.eyeSep / 2) * i / e, m = i * Math.tan(Ue.DEG2RAD * n * .5) / a;
                    h.elements[12] = -s,
                    c.elements[12] = s,
                    u = -m * r + f,
                    p = m * r + f,
                    d.elements[0] = 2 * i / (p - u),
                    d.elements[8] = (p + u) / (p - u),
                    this.cameraL.projectionMatrix.copy(d),
                    u = -m * r - f,
                    p = m * r - f,
                    d.elements[0] = 2 * i / (p - u),
                    d.elements[8] = (p + u) / (p - u),
                    this.cameraR.projectionMatrix.copy(d)
                }
                this.cameraL.matrixWorld.copy(l.matrixWorld).multiply(h),
                this.cameraR.matrixWorld.copy(l.matrixWorld).multiply(c)
            }
        }()
    }),
    as.prototype = Object.create($n.prototype),
    as.prototype.constructor = as,
    ss.prototype = Object.assign(Object.create($n.prototype), {
        constructor: ss,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null)
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(t) {
            null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = t,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination)
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(t) {
            this.gain.gain.value = t
        },
        updateMatrixWorld: function() {
            var t = new Fe
              , e = new ze
              , n = new Fe
              , r = new Fe;
            return function(i) {
                $n.prototype.updateMatrixWorld.call(this, i);
                var o = this.context.listener
                  , a = this.up;
                this.matrixWorld.decompose(t, e, n),
                r.set(0, 0, -1).applyQuaternion(e),
                o.positionX ? (o.positionX.setValueAtTime(t.x, this.context.currentTime),
                o.positionY.setValueAtTime(t.y, this.context.currentTime),
                o.positionZ.setValueAtTime(t.z, this.context.currentTime),
                o.forwardX.setValueAtTime(r.x, this.context.currentTime),
                o.forwardY.setValueAtTime(r.y, this.context.currentTime),
                o.forwardZ.setValueAtTime(r.z, this.context.currentTime),
                o.upX.setValueAtTime(a.x, this.context.currentTime),
                o.upY.setValueAtTime(a.y, this.context.currentTime),
                o.upZ.setValueAtTime(a.z, this.context.currentTime)) : (o.setPosition(t.x, t.y, t.z),
                o.setOrientation(r.x, r.y, r.z, a.x, a.y, a.z))
            }
        }()
    }),
    cs.prototype = Object.assign(Object.create($n.prototype), {
        constructor: cs,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = t,
            this.connect(),
            this
        },
        setBuffer: function(t) {
            return this.buffer = t,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        },
        play: function() {
            if (!0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    var t = this.context.createBufferSource();
                    return t.buffer = this.buffer,
                    t.loop = this.loop,
                    t.onended = this.onEnded.bind(this),
                    t.playbackRate.setValueAtTime(this.playbackRate, this.startTime),
                    this.startTime = this.context.currentTime,
                    t.start(this.startTime, this.offset),
                    this.isPlaying = !0,
                    this.source = t,
                    this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else
                console.warn("THREE.Audio: Audio is already playing.")
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this.source.stop(),
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl)
                return this.source.stop(),
                this.offset = 0,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(t) {
            return t || (t = []),
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = t,
            this.connect()) : this.filters = t,
            this
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(t) {
            return this.setFilters(t ? [t] : [])
        },
        setPlaybackRate: function(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = t,
                !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        },
        setLoop: function(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = t,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(t) {
            return this.gain.gain.value = t,
            this
        }
    }),
    hs.prototype = Object.assign(Object.create(cs.prototype), {
        constructor: hs,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(t) {
            this.panner.refDistance = t
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(t) {
            this.panner.rolloffFactor = t
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(t) {
            this.panner.distanceModel = t
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(t) {
            this.panner.maxDistance = t
        },
        updateMatrixWorld: function() {
            var t = new Fe;
            return function(e) {
                $n.prototype.updateMatrixWorld.call(this, e),
                t.setFromMatrixPosition(this.matrixWorld),
                this.panner.setPosition(t.x, t.y, t.z)
            }
        }()
    }),
    Object.assign(ls.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)
                t += e[n];
            return t / e.length
        }
    }),
    Object.assign(us.prototype, {
        accumulate: function(t, e) {
            var n = this.buffer
              , r = this.valueSize
              , i = t * r + r
              , o = this.cumulativeWeight;
            if (0 === o) {
                for (var a = 0; a !== r; ++a)
                    n[i + a] = n[a];
                o = e
            } else {
                var s = e / (o += e);
                this._mixBufferRegion(n, i, 0, s, r)
            }
            this.cumulativeWeight = o
        },
        apply: function(t) {
            var e = this.valueSize
              , n = this.buffer
              , r = t * e + e
              , i = this.cumulativeWeight
              , o = this.binding;
            if (this.cumulativeWeight = 0,
            i < 1) {
                var a = 3 * e;
                this._mixBufferRegion(n, r, a, 1 - i, e)
            }
            for (var s = e, c = e + e; s !== c; ++s)
                if (n[s] !== n[s + e]) {
                    o.setValue(n, r);
                    break
                }
        },
        saveOriginalState: function() {
            var t = this.binding
              , e = this.buffer
              , n = this.valueSize
              , r = 3 * n;
            t.getValue(e, r);
            for (var i = n, o = r; i !== o; ++i)
                e[i] = e[r + i % n];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            var t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        },
        _select: function(t, e, n, r, i) {
            if (r >= .5)
                for (var o = 0; o !== i; ++o)
                    t[e + o] = t[n + o]
        },
        _slerp: function(t, e, n, r) {
            ze.slerpFlat(t, e, t, e, t, n, r)
        },
        _lerp: function(t, e, n, r, i) {
            for (var o = 1 - r, a = 0; a !== i; ++a) {
                var s = e + a;
                t[s] = t[s] * o + t[n + a] * r
            }
        }
    }),
    Object.assign(ps.prototype, {
        getValue: function(t, e) {
            this.bind();
            var n = this._targetGroup.nCachedObjects_
              , r = this._bindings[n];
            void 0 !== r && r.getValue(t, e)
        },
        setValue: function(t, e) {
            for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)
                n[r].setValue(t, e)
        },
        bind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].bind()
        },
        unbind: function() {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].unbind()
        }
    }),
    Object.assign(ds, {
        Composite: ps,
        create: function(t, e, n) {
            return t && t.isAnimationObjectGroup ? new ds.Composite(t,e,n) : new ds(t,e,n)
        },
        sanitizeNodeName: function() {
            var t = new RegExp("[\\[\\]\\.:\\/]","g");
            return function(e) {
                return e.replace(/\s/g, "_").replace(t, "")
            }
        }(),
        parseTrackName: function() {
            var t = "[^\\[\\]\\.:\\/]"
              , e = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]"
              , n = /((?:WC+[\/:])*)/.source.replace("WC", t)
              , r = /(WCOD+)?/.source.replace("WCOD", e)
              , i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t)
              , o = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t)
              , a = new RegExp("^" + n + r + i + o + "$")
              , s = ["material", "materials", "bones"];
            return function(t) {
                var e = a.exec(t);
                if (!e)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                var n = {
                    nodeName: e[2],
                    objectName: e[3],
                    objectIndex: e[4],
                    propertyName: e[5],
                    propertyIndex: e[6]
                }
                  , r = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== r && -1 !== r) {
                    var i = n.nodeName.substring(r + 1);
                    -1 !== s.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r),
                    n.objectName = i)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return n
            }
        }(),
        findNode: function(t, e) {
            if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                return t;
            if (t.skeleton) {
                var n = t.skeleton.getBoneByName(e);
                if (void 0 !== n)
                    return n
            }
            if (t.children) {
                var r = function(t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        if (i.name === e || i.uuid === e)
                            return i;
                        var o = r(i.children);
                        if (o)
                            return o
                    }
                    return null
                }
                  , i = r(t.children);
                if (i)
                    return i
            }
            return null
        }
    }),
    Object.assign(ds.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(t, e) {
            t[e] = this.node[this.propertyName]
        }
        , function(t, e) {
            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r)
                t[e++] = n[r]
        }
        , function(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }
        , function(t, e) {
            this.resolvedProperty.toArray(t, e)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(t, e) {
            this.targetObject[this.propertyName] = t[e]
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r)
                n[r] = t[e++]
        }
        , function(t, e) {
            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r)
                n[r] = t[e++];
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r)
                n[r] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e]
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty.fromArray(t, e)
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(t, e) {
            this.bind(),
            this.getValue(t, e)
        },
        setValue: function(t, e) {
            this.bind(),
            this.setValue(t, e)
        },
        bind: function() {
            var t = this.node
              , e = this.parsedPath
              , n = e.objectName
              , r = e.propertyName
              , i = e.propertyIndex;
            if (t || (t = ds.findNode(this.rootNode, e.nodeName) || this.rootNode,
            this.node = t),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            t) {
                if (n) {
                    var o = e.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!t.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (var a = 0; a < t.length; a++)
                            if (t[a].name === o) {
                                o = a;
                                break
                            }
                        break;
                    default:
                        if (void 0 === t[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                    }
                    if (void 0 !== o) {
                        if (void 0 === t[o])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[o]
                    }
                }
                var s = t[r];
                if (void 0 !== s) {
                    var c = this.Versioning.None;
                    void 0 !== t.needsUpdate ? (c = this.Versioning.NeedsUpdate,
                    this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate,
                    this.targetObject = t);
                    var h = this.BindingType.Direct;
                    if (void 0 !== i) {
                        if ("morphTargetInfluences" === r) {
                            if (!t.geometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (t.geometry.isBufferGeometry) {
                                if (!t.geometry.morphAttributes)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                    if (t.geometry.morphAttributes.position[a].name === i) {
                                        i = a;
                                        break
                                    }
                            } else {
                                if (!t.geometry.morphTargets)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                    if (t.geometry.morphTargets[a].name === i) {
                                        i = a;
                                        break
                                    }
                            }
                        }
                        h = this.BindingType.ArrayElement,
                        this.resolvedProperty = s,
                        this.propertyIndex = i
                    } else
                        void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this.BindingType.HasFromToArray,
                        this.resolvedProperty = s) : Array.isArray(s) ? (h = this.BindingType.EntireArray,
                        this.resolvedProperty = s) : this.propertyName = r;
                    this.getValue = this.GetterByBindingType[h],
                    this.setValue = this.SetterByBindingTypeAndVersioning[h][c]
                } else {
                    var l = e.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + r + " but it wasn't found.", t)
                }
            } else
                console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign(ds.prototype, {
        _getValue_unbound: ds.prototype.getValue,
        _setValue_unbound: ds.prototype.setValue
    }),
    Object.assign(fs.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var t = this._objects, e = t.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, h = 0, l = arguments.length; h !== l; ++h) {
                var u = arguments[h]
                  , p = u.uuid
                  , d = r[p];
                if (void 0 === d) {
                    d = e++,
                    r[p] = d,
                    t.push(u);
                    for (var f = 0, m = s; f !== m; ++f)
                        a[f].push(new ds(u,i[f],o[f]))
                } else if (d < n) {
                    c = t[d];
                    var g = --n
                      , v = t[g];
                    for (r[v.uuid] = d,
                    t[d] = v,
                    r[p] = g,
                    t[g] = u,
                    f = 0,
                    m = s; f !== m; ++f) {
                        var y = a[f]
                          , x = y[g]
                          , w = y[d];
                        y[d] = x,
                        void 0 === w && (w = new ds(u,i[f],o[f])),
                        y[g] = w
                    }
                } else
                    t[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = n
        },
        remove: function() {
            for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, i = r.length, o = 0, a = arguments.length; o !== a; ++o) {
                var s = arguments[o]
                  , c = s.uuid
                  , h = n[c];
                if (void 0 !== h && h >= e) {
                    var l = e++
                      , u = t[l];
                    n[u.uuid] = h,
                    t[h] = u,
                    n[c] = l,
                    t[l] = s;
                    for (var p = 0, d = i; p !== d; ++p) {
                        var f = r[p]
                          , m = f[l]
                          , g = f[h];
                        f[h] = m,
                        f[l] = g
                    }
                }
            }
            this.nCachedObjects_ = e
        },
        uncache: function() {
            for (var t = this._objects, e = t.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) {
                var c = arguments[a].uuid
                  , h = r[c];
                if (void 0 !== h)
                    if (delete r[c],
                    h < n) {
                        var l = --n
                          , u = t[l]
                          , p = t[v = --e];
                        r[u.uuid] = h,
                        t[h] = u,
                        r[p.uuid] = l,
                        t[l] = p,
                        t.pop();
                        for (var d = 0, f = o; d !== f; ++d) {
                            var m = (y = i[d])[l]
                              , g = y[v];
                            y[h] = m,
                            y[l] = g,
                            y.pop()
                        }
                    } else {
                        var v;
                        for (r[(p = t[v = --e]).uuid] = h,
                        t[h] = p,
                        t.pop(),
                        d = 0,
                        f = o; d !== f; ++d) {
                            var y;
                            (y = i[d])[h] = y[v],
                            y.pop()
                        }
                    }
            }
            this.nCachedObjects_ = n
        },
        subscribe_: function(t, e) {
            var n = this._bindingsIndicesByPath
              , r = n[t]
              , i = this._bindings;
            if (void 0 !== r)
                return i[r];
            var o = this._paths
              , a = this._parsedPaths
              , s = this._objects
              , c = s.length
              , h = this.nCachedObjects_
              , l = new Array(c);
            r = i.length,
            n[t] = r,
            o.push(t),
            a.push(e),
            i.push(l);
            for (var u = h, p = s.length; u !== p; ++u) {
                var d = s[u];
                l[u] = new ds(d,t,e)
            }
            return l
        },
        unsubscribe_: function(t) {
            var e = this._bindingsIndicesByPath
              , n = e[t];
            if (void 0 !== n) {
                var r = this._paths
                  , i = this._parsedPaths
                  , o = this._bindings
                  , a = o.length - 1
                  , s = o[a];
                e[t[a]] = n,
                o[n] = s,
                o.pop(),
                i[n] = i[a],
                i.pop(),
                r[n] = r[a],
                r.pop()
            }
        }
    }),
    Object.assign(ms.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(t) {
            return this._startTime = t,
            this
        },
        setLoop: function(t, e) {
            return this.loop = t,
            this.repetitions = e,
            this
        },
        setEffectiveWeight: function(t) {
            return this.weight = t,
            this._effectiveWeight = this.enabled ? t : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(t) {
            return this._scheduleFading(t, 0, 1)
        },
        fadeOut: function(t) {
            return this._scheduleFading(t, 1, 0)
        },
        crossFadeFrom: function(t, e, n) {
            if (t.fadeOut(e),
            this.fadeIn(e),
            n) {
                var r = this._clip.duration
                  , i = t._clip.duration
                  , o = i / r
                  , a = r / i;
                t.warp(1, o, e),
                this.warp(a, 1, e)
            }
            return this
        },
        crossFadeTo: function(t, e, n) {
            return t.crossFadeFrom(this, e, n)
        },
        stopFading: function() {
            var t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        },
        setEffectiveTimeScale: function(t) {
            return this.timeScale = t,
            this._effectiveTimeScale = this.paused ? 0 : t,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(t) {
            return this.timeScale = this._clip.duration / t,
            this.stopWarping()
        },
        syncWith: function(t) {
            return this.time = t.time,
            this.timeScale = t.timeScale,
            this.stopWarping()
        },
        halt: function(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        },
        warp: function(t, e, n) {
            var r = this._mixer
              , i = r.time
              , o = this._timeScaleInterpolant
              , a = this.timeScale;
            null === o && (o = r._lendControlInterpolant(),
            this._timeScaleInterpolant = o);
            var s = o.parameterPositions
              , c = o.sampleValues;
            return s[0] = i,
            s[1] = i + n,
            c[0] = t / a,
            c[1] = e / a,
            this
        },
        stopWarping: function() {
            var t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(t, e, n, r) {
            if (this.enabled) {
                var i = this._startTime;
                if (null !== i) {
                    var o = (t - i) * n;
                    if (o < 0 || 0 === n)
                        return;
                    this._startTime = null,
                    e = n * o
                }
                e *= this._updateTimeScale(t);
                var a = this._updateTime(e)
                  , s = this._updateWeight(t);
                if (s > 0)
                    for (var c = this._interpolants, h = this._propertyBindings, l = 0, u = c.length; l !== u; ++l)
                        c[l].evaluate(a),
                        h[l].accumulate(r, s)
            } else
                this._updateWeight(t)
        },
        _updateWeight: function(t) {
            var e = 0;
            if (this.enabled) {
                e = this.weight;
                var n = this._weightInterpolant;
                if (null !== n) {
                    var r = n.evaluate(t)[0];
                    e *= r,
                    t > n.parameterPositions[1] && (this.stopFading(),
                    0 === r && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e,
            e
        },
        _updateTimeScale: function(t) {
            var e = 0;
            if (!this.paused) {
                e = this.timeScale;
                var n = this._timeScaleInterpolant;
                null !== n && (e *= n.evaluate(t)[0],
                t > n.parameterPositions[1] && (this.stopWarping(),
                0 === e ? this.paused = !0 : this.timeScale = e))
            }
            return this._effectiveTimeScale = e,
            e
        },
        _updateTime: function(t) {
            var e = this.time + t;
            if (0 === t)
                return e;
            var n = this._clip.duration
              , r = this.loop
              , i = this._loopCount;
            if (r === de) {
                -1 === i && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                t: {
                    if (e >= n)
                        e = n;
                    else {
                        if (!(e < 0))
                            break t;
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            } else {
                var o = r === me;
                if (-1 === i && (t >= 0 ? (i = 0,
                this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)),
                e >= n || e < 0) {
                    var a = Math.floor(e / n);
                    e -= n * a,
                    i += Math.abs(a);
                    var s = this.repetitions - i;
                    if (s < 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        e = t > 0 ? n : 0,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                    else {
                        if (0 === s) {
                            var c = t < 0;
                            this._setEndings(c, !c, o)
                        } else
                            this._setEndings(!1, !1, o);
                        this._loopCount = i,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: a
                        })
                    }
                }
                if (o && 1 == (1 & i))
                    return this.time = e,
                    n - e
            }
            return this.time = e,
            e
        },
        _setEndings: function(t, e, n) {
            var r = this._interpolantSettings;
            n ? (r.endingStart = we,
            r.endingEnd = we) : (r.endingStart = t ? this.zeroSlopeAtStart ? we : xe : be,
            r.endingEnd = e ? this.zeroSlopeAtEnd ? we : xe : be)
        },
        _scheduleFading: function(t, e, n) {
            var r = this._mixer
              , i = r.time
              , o = this._weightInterpolant;
            null === o && (o = r._lendControlInterpolant(),
            this._weightInterpolant = o);
            var a = o.parameterPositions
              , s = o.sampleValues;
            return a[0] = i,
            s[0] = e,
            a[1] = i + t,
            s[1] = n,
            this
        }
    }),
    gs.prototype = Object.assign(Object.create(r.prototype), {
        constructor: gs,
        _bindAction: function(t, e) {
            var n = t._localRoot || this._root
              , r = t._clip.tracks
              , i = r.length
              , o = t._propertyBindings
              , a = t._interpolants
              , s = n.uuid
              , c = this._bindingsByRootAndName
              , h = c[s];
            void 0 === h && (h = {},
            c[s] = h);
            for (var l = 0; l !== i; ++l) {
                var u = r[l]
                  , p = u.name
                  , d = h[p];
                if (void 0 !== d)
                    o[l] = d;
                else {
                    if (void 0 !== (d = o[l])) {
                        null === d._cacheIndex && (++d.referenceCount,
                        this._addInactiveBinding(d, s, p));
                        continue
                    }
                    var f = e && e._propertyBindings[l].binding.parsedPath;
                    ++(d = new us(ds.create(n, p, f),u.ValueTypeName,u.getValueSize())).referenceCount,
                    this._addInactiveBinding(d, s, p),
                    o[l] = d
                }
                a[l].resultBuffer = d.buffer
            }
        },
        _activateAction: function(t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    var e = (t._localRoot || this._root).uuid
                      , n = t._clip.uuid
                      , r = this._actionsByClip[n];
                    this._bindAction(t, r && r.knownActions[0]),
                    this._addInactiveAction(t, n, e)
                }
                for (var i = t._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                    var s = i[o];
                    0 == s.useCount++ && (this._lendBinding(s),
                    s.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function(t) {
            if (this._isActiveAction(t)) {
                for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
                    var i = e[n];
                    0 == --i.useCount && (i.restoreOriginalState(),
                    this._takeBackBinding(i))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(t) {
            var e = t._cacheIndex;
            return null !== e && e < this._nActiveActions
        },
        _addInactiveAction: function(t, e, n) {
            var r = this._actions
              , i = this._actionsByClip
              , o = i[e];
            if (void 0 === o)
                o = {
                    knownActions: [t],
                    actionByRoot: {}
                },
                t._byClipCacheIndex = 0,
                i[e] = o;
            else {
                var a = o.knownActions;
                t._byClipCacheIndex = a.length,
                a.push(t)
            }
            t._cacheIndex = r.length,
            r.push(t),
            o.actionByRoot[n] = t
        },
        _removeInactiveAction: function(t) {
            var e = this._actions
              , n = e[e.length - 1]
              , r = t._cacheIndex;
            n._cacheIndex = r,
            e[r] = n,
            e.pop(),
            t._cacheIndex = null;
            var i = t._clip.uuid
              , o = this._actionsByClip
              , a = o[i]
              , s = a.knownActions
              , c = s[s.length - 1]
              , h = t._byClipCacheIndex;
            c._byClipCacheIndex = h,
            s[h] = c,
            s.pop(),
            t._byClipCacheIndex = null,
            delete a.actionByRoot[(t._localRoot || this._root).uuid],
            0 === s.length && delete o[i],
            this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function(t) {
            for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
                var i = e[n];
                0 == --i.referenceCount && this._removeInactiveBinding(i)
            }
        },
        _lendAction: function(t) {
            var e = this._actions
              , n = t._cacheIndex
              , r = this._nActiveActions++
              , i = e[r];
            t._cacheIndex = r,
            e[r] = t,
            i._cacheIndex = n,
            e[n] = i
        },
        _takeBackAction: function(t) {
            var e = this._actions
              , n = t._cacheIndex
              , r = --this._nActiveActions
              , i = e[r];
            t._cacheIndex = r,
            e[r] = t,
            i._cacheIndex = n,
            e[n] = i
        },
        _addInactiveBinding: function(t, e, n) {
            var r = this._bindingsByRootAndName
              , i = r[e]
              , o = this._bindings;
            void 0 === i && (i = {},
            r[e] = i),
            i[n] = t,
            t._cacheIndex = o.length,
            o.push(t)
        },
        _removeInactiveBinding: function(t) {
            var e = this._bindings
              , n = t.binding
              , r = n.rootNode.uuid
              , i = n.path
              , o = this._bindingsByRootAndName
              , a = o[r]
              , s = e[e.length - 1]
              , c = t._cacheIndex;
            s._cacheIndex = c,
            e[c] = s,
            e.pop(),
            delete a[i];
            t: {
                for (var h in a)
                    break t;
                delete o[r]
            }
        },
        _lendBinding: function(t) {
            var e = this._bindings
              , n = t._cacheIndex
              , r = this._nActiveBindings++
              , i = e[r];
            t._cacheIndex = r,
            e[r] = t,
            i._cacheIndex = n,
            e[n] = i
        },
        _takeBackBinding: function(t) {
            var e = this._bindings
              , n = t._cacheIndex
              , r = --this._nActiveBindings
              , i = e[r];
            t._cacheIndex = r,
            e[r] = t,
            i._cacheIndex = n,
            e[n] = i
        },
        _lendControlInterpolant: function() {
            var t = this._controlInterpolants
              , e = this._nActiveControlInterpolants++
              , n = t[e];
            return void 0 === n && ((n = new Oa(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = e,
            t[e] = n),
            n
        },
        _takeBackControlInterpolant: function(t) {
            var e = this._controlInterpolants
              , n = t.__cacheIndex
              , r = --this._nActiveControlInterpolants
              , i = e[r];
            t.__cacheIndex = r,
            e[r] = t,
            i.__cacheIndex = n,
            e[n] = i
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(t, e) {
            var n = e || this._root
              , r = n.uuid
              , i = "string" == typeof t ? za.findByName(n, t) : t
              , o = null !== i ? i.uuid : t
              , a = this._actionsByClip[o]
              , s = null;
            if (void 0 !== a) {
                var c = a.actionByRoot[r];
                if (void 0 !== c)
                    return c;
                s = a.knownActions[0],
                null === i && (i = s._clip)
            }
            if (null === i)
                return null;
            var h = new ms(this,i,e);
            return this._bindAction(h, s),
            this._addInactiveAction(h, o, r),
            h
        },
        existingAction: function(t, e) {
            var n = e || this._root
              , r = n.uuid
              , i = "string" == typeof t ? za.findByName(n, t) : t
              , o = i ? i.uuid : t
              , a = this._actionsByClip[o];
            return void 0 !== a && a.actionByRoot[r] || null
        },
        stopAllAction: function() {
            var t = this._actions
              , e = this._nActiveActions
              , n = this._bindings
              , r = this._nActiveBindings;
            this._nActiveActions = 0,
            this._nActiveBindings = 0;
            for (var i = 0; i !== e; ++i)
                t[i].reset();
            for (i = 0; i !== r; ++i)
                n[i].useCount = 0;
            return this
        },
        update: function(t) {
            t *= this.timeScale;
            for (var e = this._actions, n = this._nActiveActions, r = this.time += t, i = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a)
                e[a]._update(r, t, i, o);
            var s = this._bindings
              , c = this._nActiveBindings;
            for (a = 0; a !== c; ++a)
                s[a].apply(o);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(t) {
            var e = this._actions
              , n = t.uuid
              , r = this._actionsByClip
              , i = r[n];
            if (void 0 !== i) {
                for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
                    var c = o[a];
                    this._deactivateAction(c);
                    var h = c._cacheIndex
                      , l = e[e.length - 1];
                    c._cacheIndex = null,
                    c._byClipCacheIndex = null,
                    l._cacheIndex = h,
                    e[h] = l,
                    e.pop(),
                    this._removeInactiveBindingsForAction(c)
                }
                delete r[n]
            }
        },
        uncacheRoot: function(t) {
            var e = t.uuid
              , n = this._actionsByClip;
            for (var r in n) {
                var i = n[r].actionByRoot[e];
                void 0 !== i && (this._deactivateAction(i),
                this._removeInactiveAction(i))
            }
            var o = this._bindingsByRootAndName[e];
            if (void 0 !== o)
                for (var a in o) {
                    var s = o[a];
                    s.restoreOriginalState(),
                    this._removeInactiveBinding(s)
                }
        },
        uncacheAction: function(t, e) {
            var n = this.existingAction(t, e);
            null !== n && (this._deactivateAction(n),
            this._removeInactiveAction(n))
        }
    }),
    vs.prototype.clone = function() {
        return new vs(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    ys.prototype = Object.assign(Object.create(yr.prototype), {
        constructor: ys,
        isInstancedBufferGeometry: !0,
        copy: function(t) {
            return yr.prototype.copy.call(this, t),
            this.maxInstancedCount = t.maxInstancedCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Object.defineProperties(xs.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(xs.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e,
            this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e,
            this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e,
            this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e,
            this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, n) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, r) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = r,
            this
        },
        setXYZW: function(t, e, n, r, i) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = r,
            this.data.array[t + 3] = i,
            this
        }
    }),
    Object.defineProperty(ws.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(ws.prototype, {
        isInterleavedBuffer: !0,
        setArray: function(t) {
            if (Array.isArray(t))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = void 0 !== t ? t.length / this.stride : 0,
            this.array = t
        },
        setDynamic: function(t) {
            return this.dynamic = t,
            this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array),
            this.count = t.count,
            this.stride = t.stride,
            this.dynamic = t.dynamic,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.stride,
            n *= e.stride;
            for (var r = 0, i = this.stride; r < i; r++)
                this.array[t + r] = e.array[n + r];
            return this
        },
        set: function(t, e) {
            return void 0 === e && (e = 0),
            this.array.set(t, e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        }
    }),
    bs.prototype = Object.assign(Object.create(ws.prototype), {
        constructor: bs,
        isInstancedInterleavedBuffer: !0,
        copy: function(t) {
            return ws.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
    }),
    Ms.prototype = Object.assign(Object.create(or.prototype), {
        constructor: Ms,
        isInstancedBufferAttribute: !0,
        copy: function(t) {
            return or.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
    }),
    Object.assign(_s.prototype, {
        linePrecision: 1,
        set: function(t, e) {
            this.ray.set(t, e)
        },
        setFromCamera: function(t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
            this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(t, e) {
            var n = [];
            return Ss(t, this, n, e),
            n.sort(Es),
            n
        },
        intersectObjects: function(t, e) {
            var n = [];
            if (!1 === Array.isArray(t))
                return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                n;
            for (var r = 0, i = t.length; r < i; r++)
                Ss(t[r], this, n, e);
            return n.sort(Es),
            n
        }
    }),
    Object.assign(Ts.prototype, {
        start: function() {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var t = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                var e = ("undefined" == typeof performance ? Date : performance).now();
                t = (e - this.oldTime) / 1e3,
                this.oldTime = e,
                this.elapsedTime += t
            }
            return t
        }
    }),
    Object.assign(As.prototype, {
        set: function(t, e, n) {
            return this.radius = t,
            this.phi = e,
            this.theta = n,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius,
            this.phi = t.phi,
            this.theta = t.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(t) {
            return this.radius = t.length(),
            0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(t.x, t.z),
            this.phi = Math.acos(Ue.clamp(t.y / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(Ls.prototype, {
        set: function(t, e, n) {
            return this.radius = t,
            this.theta = e,
            this.y = n,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius,
            this.theta = t.theta,
            this.y = t.y,
            this
        },
        setFromVector3: function(t) {
            return this.radius = Math.sqrt(t.x * t.x + t.z * t.z),
            this.theta = Math.atan2(t.x, t.z),
            this.y = t.y,
            this
        }
    }),
    Object.assign(Rs.prototype, {
        set: function(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        },
        setFromPoints: function(t) {
            this.makeEmpty();
            for (var e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        },
        setFromCenterAndSize: function() {
            var t = new Ne;
            return function(e, n) {
                var r = t.copy(n).multiplyScalar(.5);
                return this.min.copy(e).sub(r),
                this.max.copy(e).add(r),
                this
            }
        }(),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(t) {
            var e = t || new Ne;
            return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(t) {
            var e = t || new Ne;
            return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        },
        expandByVector: function(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        },
        expandByScalar: function(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        },
        containsPoint: function(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        },
        containsBox: function(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        },
        getParameter: function(t, e) {
            return (e || new Ne).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        },
        clampPoint: function(t, e) {
            return (e || new Ne).copy(t).clamp(this.min, this.max)
        },
        distanceToPoint: function() {
            var t = new Ne;
            return function(e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(),
        intersect: function(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this
        },
        union: function(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        },
        translate: function(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        },
        equals: function(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }),
    Ps.prototype = Object.create($n.prototype),
    Ps.prototype.constructor = Ps,
    Ps.prototype.isImmediateRenderObject = !0,
    Cs.prototype = Object.create(si.prototype),
    Cs.prototype.constructor = Cs,
    Cs.prototype.update = function() {
        var t = new Fe
          , e = new Fe
          , n = new ke;
        return function() {
            var r = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0),
            n.getNormalMatrix(this.object.matrixWorld);
            var i = this.object.matrixWorld
              , o = this.geometry.attributes.position
              , a = this.object.geometry;
            if (a && a.isGeometry)
                for (var s = a.vertices, c = a.faces, h = 0, l = 0, u = c.length; l < u; l++)
                    for (var p = c[l], d = 0, f = p.vertexNormals.length; d < f; d++) {
                        var m = s[p[r[d]]]
                          , g = p.vertexNormals[d];
                        t.copy(m).applyMatrix4(i),
                        e.copy(g).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
                        o.setXYZ(h, t.x, t.y, t.z),
                        h += 1,
                        o.setXYZ(h, e.x, e.y, e.z),
                        h += 1
                    }
            else if (a && a.isBufferGeometry) {
                var v = a.attributes.position
                  , y = a.attributes.normal;
                for (h = 0,
                d = 0,
                f = v.count; d < f; d++)
                    t.set(v.getX(d), v.getY(d), v.getZ(d)).applyMatrix4(i),
                    e.set(y.getX(d), y.getY(d), y.getZ(d)),
                    e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
                    o.setXYZ(h, t.x, t.y, t.z),
                    h += 1,
                    o.setXYZ(h, e.x, e.y, e.z),
                    h += 1
            }
            o.needsUpdate = !0
        }
    }(),
    Is.prototype = Object.create($n.prototype),
    Is.prototype.constructor = Is,
    Is.prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    Is.prototype.update = function() {
        var t = new Fe
          , e = new Fe;
        return function() {
            this.light.updateMatrixWorld();
            var n = this.light.distance ? this.light.distance : 1e3
              , r = n * Math.tan(this.light.angle);
            this.cone.scale.set(r, r, n),
            t.setFromMatrixPosition(this.light.matrixWorld),
            e.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(e.sub(t)),
            void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(),
    Os.prototype = Object.create(si.prototype),
    Os.prototype.constructor = Os,
    Os.prototype.updateMatrixWorld = function() {
        var t = new Fe
          , e = new Be
          , n = new Be;
        return function(r) {
            var i = this.bones
              , o = this.geometry
              , a = o.getAttribute("position");
            n.getInverse(this.root.matrixWorld);
            for (var s = 0, c = 0; s < i.length; s++) {
                var h = i[s];
                h.parent && h.parent.isBone && (e.multiplyMatrices(n, h.matrixWorld),
                t.setFromMatrixPosition(e),
                a.setXYZ(c, t.x, t.y, t.z),
                e.multiplyMatrices(n, h.parent.matrixWorld),
                t.setFromMatrixPosition(e),
                a.setXYZ(c + 1, t.x, t.y, t.z),
                c += 2)
            }
            o.getAttribute("position").needsUpdate = !0,
            $n.prototype.updateMatrixWorld.call(this, r)
        }
    }(),
    Ds.prototype = Object.create(Lr.prototype),
    Ds.prototype.constructor = Ds,
    Ds.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    Ds.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ,
    Us.prototype = Object.create($n.prototype),
    Us.prototype.constructor = Us,
    Us.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Us.prototype.update = function() {
        var t = .5 * this.light.width
          , e = .5 * this.light.height
          , n = this.line.geometry.attributes.position
          , r = n.array;
        r[0] = t,
        r[1] = -e,
        r[2] = 0,
        r[3] = t,
        r[4] = e,
        r[5] = 0,
        r[6] = -t,
        r[7] = e,
        r[8] = 0,
        r[9] = -t,
        r[10] = -e,
        r[11] = 0,
        r[12] = t,
        r[13] = -e,
        r[14] = 0,
        n.needsUpdate = !0,
        void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
    }
    ,
    Ns.prototype = Object.create($n.prototype),
    Ns.prototype.constructor = Ns,
    Ns.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Ns.prototype.update = function() {
        var t = new Fe
          , e = new Un
          , n = new Un;
        return function() {
            var r = this.children[0];
            if (void 0 !== this.color)
                this.material.color.set(this.color);
            else {
                var i = r.geometry.getAttribute("color");
                e.copy(this.light.color),
                n.copy(this.light.groundColor);
                for (var o = 0, a = i.count; o < a; o++) {
                    var s = o < a / 2 ? e : n;
                    i.setXYZ(o, s.r, s.g, s.b)
                }
                i.needsUpdate = !0
            }
            r.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(),
    Bs.prototype = Object.create(si.prototype),
    Bs.prototype.constructor = Bs,
    zs.prototype = Object.create(si.prototype),
    zs.prototype.constructor = zs,
    Fs.prototype = Object.create(si.prototype),
    Fs.prototype.constructor = Fs,
    Fs.prototype.update = function() {
        var t = new Fe
          , e = new Fe
          , n = new ke;
        return function() {
            this.object.updateMatrixWorld(!0),
            n.getNormalMatrix(this.object.matrixWorld);
            for (var r = this.object.matrixWorld, i = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, c = 0, h = 0, l = s.length; h < l; h++) {
                var u = s[h]
                  , p = u.normal;
                t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(r),
                e.copy(p).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
                i.setXYZ(c, t.x, t.y, t.z),
                c += 1,
                i.setXYZ(c, e.x, e.y, e.z),
                c += 1
            }
            i.needsUpdate = !0
        }
    }(),
    ks.prototype = Object.create($n.prototype),
    ks.prototype.constructor = ks,
    ks.prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    ks.prototype.update = function() {
        var t = new Fe
          , e = new Fe
          , n = new Fe;
        return function() {
            t.setFromMatrixPosition(this.light.matrixWorld),
            e.setFromMatrixPosition(this.light.target.matrixWorld),
            n.subVectors(e, t),
            this.lightPlane.lookAt(n),
            void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(n),
            this.targetLine.scale.z = n.length()
        }
    }(),
    Hs.prototype = Object.create(si.prototype),
    Hs.prototype.constructor = Hs,
    Hs.prototype.update = function() {
        var t, e, n = new Fe, r = new tr;
        function i(i, o, a, s) {
            n.set(o, a, s).unproject(r);
            var c = e[i];
            if (void 0 !== c)
                for (var h = t.getAttribute("position"), l = 0, u = c.length; l < u; l++)
                    h.setXYZ(c[l], n.x, n.y, n.z)
        }
        return function() {
            t = this.geometry,
            e = this.pointMap,
            r.projectionMatrix.copy(this.camera.projectionMatrix),
            i("c", 0, 0, -1),
            i("t", 0, 0, 1),
            i("n1", -1, -1, -1),
            i("n2", 1, -1, -1),
            i("n3", -1, 1, -1),
            i("n4", 1, 1, -1),
            i("f1", -1, -1, 1),
            i("f2", 1, -1, 1),
            i("f3", -1, 1, 1),
            i("f4", 1, 1, 1),
            i("u1", .7, 1.1, -1),
            i("u2", -.7, 1.1, -1),
            i("u3", 0, 2, -1),
            i("cf1", -1, 0, 1),
            i("cf2", 1, 0, 1),
            i("cf3", 0, -1, 1),
            i("cf4", 0, 1, 1),
            i("cn1", -1, 0, -1),
            i("cn2", 1, 0, -1),
            i("cn3", 0, -1, -1),
            i("cn4", 0, 1, -1),
            t.getAttribute("position").needsUpdate = !0
        }
    }(),
    Gs.prototype = Object.create(si.prototype),
    Gs.prototype.constructor = Gs,
    Gs.prototype.update = function() {
        var t = new Wn;
        return function(e) {
            if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
            void 0 !== this.object && t.setFromObject(this.object),
            !t.isEmpty()) {
                var n = t.min
                  , r = t.max
                  , i = this.geometry.attributes.position
                  , o = i.array;
                o[0] = r.x,
                o[1] = r.y,
                o[2] = r.z,
                o[3] = n.x,
                o[4] = r.y,
                o[5] = r.z,
                o[6] = n.x,
                o[7] = n.y,
                o[8] = r.z,
                o[9] = r.x,
                o[10] = n.y,
                o[11] = r.z,
                o[12] = r.x,
                o[13] = r.y,
                o[14] = n.z,
                o[15] = n.x,
                o[16] = r.y,
                o[17] = n.z,
                o[18] = n.x,
                o[19] = n.y,
                o[20] = n.z,
                o[21] = r.x,
                o[22] = n.y,
                o[23] = n.z,
                i.needsUpdate = !0,
                this.geometry.computeBoundingSphere()
            }
        }
    }(),
    Gs.prototype.setFromObject = function(t) {
        return this.object = t,
        this.update(),
        this
    }
    ,
    Vs.prototype = Object.create(si.prototype),
    Vs.prototype.constructor = Vs,
    Vs.prototype.updateMatrixWorld = function(t) {
        var e = this.box;
        e.isEmpty() || (e.getCenter(this.position),
        e.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        $n.prototype.updateMatrixWorld.call(this, t))
    }
    ,
    js.prototype = Object.create(ai.prototype),
    js.prototype.constructor = js,
    js.prototype.updateMatrixWorld = function(t) {
        var e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, e),
        this.lookAt(this.plane.normal),
        $n.prototype.updateMatrixWorld.call(this, t)
    }
    ,
    Ws.prototype = Object.create($n.prototype),
    Ws.prototype.constructor = Ws,
    Ws.prototype.setDirection = function() {
        var t, e = new Fe;
        return function(n) {
            n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(),
            t = Math.acos(n.y),
            this.quaternion.setFromAxisAngle(e, t))
        }
    }(),
    Ws.prototype.setLength = function(t, e, n) {
        void 0 === e && (e = .2 * t),
        void 0 === n && (n = .2 * e),
        this.line.scale.set(1, Math.max(0, t - e), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(n, e, n),
        this.cone.position.y = t,
        this.cone.updateMatrix()
    }
    ,
    Ws.prototype.setColor = function(t) {
        this.line.material.color.copy(t),
        this.cone.material.color.copy(t)
    }
    ,
    Ys.prototype = Object.create(si.prototype),
    Ys.prototype.constructor = Ys;
    var qs = 0
      , Zs = 1;
    function Js(t) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),
        t
    }
    function Ks(t) {
        return void 0 === t && (t = []),
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
        t.isMultiMaterial = !0,
        t.materials = t,
        t.clone = function() {
            return t.slice()
        }
        ,
        t
    }
    function Qs(t, e) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
        new li(t,e)
    }
    function $s(t) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."),
        new ti(t)
    }
    function tc(t, e) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
        new li(t,e)
    }
    function ec(t) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
        new hi(t)
    }
    function nc(t) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
        new hi(t)
    }
    function rc(t) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
        new hi(t)
    }
    function ic(t, e, n) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
        new Fe(t,e,n)
    }
    function oc(t, e) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
        new or(t,e).setDynamic(!0)
    }
    function ac(t, e) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
        new ar(t,e)
    }
    function sc(t, e) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),
        new sr(t,e)
    }
    function cc(t, e) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
        new cr(t,e)
    }
    function hc(t, e) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),
        new hr(t,e)
    }
    function lc(t, e) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),
        new lr(t,e)
    }
    function uc(t, e) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
        new ur(t,e)
    }
    function pc(t, e) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),
        new pr(t,e)
    }
    function dc(t, e) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),
        new dr(t,e)
    }
    function fc(t, e) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),
        new fr(t,e)
    }
    function mc(t) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        ta.call(this, t),
        this.type = "catmullrom",
        this.closed = !0
    }
    function gc(t) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        ta.call(this, t),
        this.type = "catmullrom"
    }
    function vc(t) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
        ta.call(this, t),
        this.type = "catmullrom"
    }
    function yc(t) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
        new Ys(t)
    }
    function xc(t, e) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
        new Gs(t,e)
    }
    function wc(t, e) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
        new si(new yo(t.geometry),new oi({
            color: void 0 !== e ? e : 16777215
        }))
    }
    function bc(t, e) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
        new si(new mi(t.geometry),new oi({
            color: void 0 !== e ? e : 16777215
        }))
    }
    function Mc(t) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
        new ko(t)
    }
    function _c(t) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
        new Go(t)
    }
    Yo.create = function(t, e) {
        return console.log("THREE.Curve.create() has been deprecated"),
        t.prototype = Object.create(Yo.prototype),
        t.prototype.constructor = t,
        t.prototype.getPoint = e,
        t
    }
    ,
    Object.assign(pa.prototype, {
        createPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var e = this.getPoints(t);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        },
        createGeometry: function(t) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var e = new ir, n = 0, r = t.length; n < r; n++) {
                var i = t[n];
                e.vertices.push(new Fe(i.x,i.y,i.z || 0))
            }
            return e
        }
    }),
    Object.assign(da.prototype, {
        fromPoints: function(t) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(t)
        }
    }),
    mc.prototype = Object.create(ta.prototype),
    gc.prototype = Object.create(ta.prototype),
    vc.prototype = Object.create(ta.prototype),
    Object.assign(vc.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }),
    Bs.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    Os.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    Object.assign(Ga.prototype, {
        extractUrlBase: function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            Va.extractUrlBase(t)
        }
    }),
    Object.assign(Rs.prototype, {
        center: function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        },
        size: function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
    }),
    Object.assign(Wn.prototype, {
        center: function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        },
        size: function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
    }),
    Tr.prototype.center = function(t) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
        this.getCenter(t)
    }
    ,
    Object.assign(Ue, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random()
        },
        nearestPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            Ue.floorPowerOfTwo(t)
        },
        nextPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            Ue.ceilPowerOfTwo(t)
        }
    }),
    Object.assign(ke.prototype, {
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(t) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }),
    Object.assign(Be.prototype, {
        extractPosition: function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(t)
        },
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        },
        getPosition: function() {
            var t;
            return function() {
                return void 0 === t && (t = new Fe),
                console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
                t.setFromMatrixColumn(this, 3)
            }
        }(),
        setRotationFromQuaternion: function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        multiplyVector4: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            t.transformDirection(this)
        },
        crossVector: function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(t) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(t)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(t, e, n, r, i, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(t, e, r, n, i, o)
        }
    }),
    Xn.prototype.isIntersectionLine = function(t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(t)
    }
    ,
    ze.prototype.multiplyVector3 = function(t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        t.applyQuaternion(this)
    }
    ,
    Object.assign(Sr.prototype, {
        isIntersectionBox: function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        },
        isIntersectionPlane: function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        }
    }),
    Object.assign(fa.prototype, {
        extractAllPoints: function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(t)
        },
        extrude: function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new io(this,t)
        },
        makeGeometry: function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new mo(this,t)
        }
    }),
    Object.assign(Ne.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Fe.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(e, t)
        },
        applyProjection: function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(t)
        },
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Ve.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(ir.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }),
    Object.assign($n.prototype, {
        getChildByName: function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(t)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(e, t)
        }
    }),
    Object.defineProperties($n.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Object.defineProperties(ei.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                this.levels
            }
        }
    }),
    Object.defineProperty(ni.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }),
    Object.defineProperty(Yo.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions
        },
        set: function(t) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = t
        }
    }),
    Vr.prototype.setLens = function(t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t)
    }
    ,
    Object.defineProperties(ma.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = t
            }
        }
    }),
    Object.defineProperties(or.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        }
    }),
    Object.assign(yr.prototype, {
        addIndex: function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(t)
        },
        addDrawCall: function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }),
    Object.defineProperties(yr.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Object.defineProperties(vs.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this
            }
        }
    }),
    Object.defineProperties(Gn.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new Un
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = t === y
            }
        }
    }),
    Object.defineProperties(Po.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }),
    Object.defineProperties(Er.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = t
            }
        }
    }),
    Object.assign(Zr.prototype, {
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(t)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
    }),
    Object.defineProperties(Zr.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(Zn.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(je.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = t
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = t
            }
        }
    }),
    Object.defineProperties(Wr.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        }
    }),
    cs.prototype.load = function(t) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var e = this;
        return (new is).load(t, function(t) {
            e.setBuffer(t)
        }),
        this
    }
    ,
    ls.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
        this.getFrequencyData()
    }
    ,
    as.prototype.updateCubeMap = function(t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(t, e)
    }
    ;
    var Ec = {
        merge: function(t, e, n) {
            var r;
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),
            e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(),
            r = e.matrix,
            e = e.geometry),
            t.merge(e, r, n)
        },
        center: function(t) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
            t.center()
        }
    }
      , Sc = {
        crossOrigin: void 0,
        loadTexture: function(t, e, n, r) {
            console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
            var i = new Wo;
            i.setCrossOrigin(this.crossOrigin);
            var o = i.load(t, n, void 0, r);
            return e && (o.mapping = e),
            o
        },
        loadTextureCube: function(t, e, n, r) {
            console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
            var i = new jo;
            i.setCrossOrigin(this.crossOrigin);
            var o = i.load(t, n, void 0, r);
            return e && (o.mapping = e),
            o
        },
        loadCompressedTexture: function() {
            console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
        },
        loadCompressedTextureCube: function() {
            console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
        }
    };
    function Tc() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
        this.projectVector = function(t, e) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."),
            t.project(e)
        }
        ,
        this.unprojectVector = function(t, e) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
            t.unproject(e)
        }
        ,
        this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }
    function Ac() {
        console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),
        this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
        this.clear = function() {}
        ,
        this.render = function() {}
        ,
        this.setClearColor = function() {}
        ,
        this.setSize = function() {}
    }
    var Lc = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    };
    function Rc() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }
}
, function(t, e, n) {
    var r = n(4);
    e.createCodec = s,
    e.install = function(t) {
        for (var e in t)
            o.prototype[e] = a(o.prototype[e], t[e])
    }
    ,
    e.filter = function(t) {
        return r(t) ? function(t) {
            return t = t.slice(),
            function(n) {
                return t.reduce(e, n)
            }
            ;
            function e(t, e) {
                return e(t)
            }
        }(t) : t
    }
    ;
    var i = n(0);
    function o(t) {
        if (!(this instanceof o))
            return new o(t);
        this.options = t,
        this.init()
    }
    function a(t, e) {
        return t && e ? function() {
            return t.apply(this, arguments),
            e.apply(this, arguments)
        }
        : t || e
    }
    function s(t) {
        return new o(t)
    }
    o.prototype.init = function() {
        var t = this.options;
        return t && t.uint8array && (this.bufferish = i.Uint8Array),
        this
    }
    ,
    e.preset = s({
        preset: !0
    })
}
, function(t, e) {
    var n = {}.toString;
    t.exports = Array.isArray || function(t) {
        return "[object Array]" == n.call(t)
    }
}
, function(t, e, n) {
    var r = n(9).ExtBuffer
      , i = n(32)
      , o = n(16).readUint8
      , a = n(31)
      , s = n(3);
    function c() {
        var t = this.options;
        return this.decode = function(t) {
            var e = a.getReadToken(t);
            return function(t) {
                var n = o(t)
                  , r = e[n];
                if (!r)
                    throw new Error("Invalid type: " + (n ? "0x" + n.toString(16) : n));
                return r(t)
            }
        }(t),
        t && t.preset && i.setExtUnpackers(this),
        this
    }
    s.install({
        addExtUnpacker: function(t, e) {
            (this.extUnpackers || (this.extUnpackers = []))[t] = s.filter(e)
        },
        getExtUnpacker: function(t) {
            return (this.extUnpackers || (this.extUnpackers = []))[t] || function(e) {
                return new r(e,t)
            }
        },
        init: c
    }),
    e.preset = c.call(s.preset)
}
, function(t, e, n) {
    (function(t) {
        !function(e) {
            var n, r = "undefined", i = r !== typeof t && t, o = r !== typeof Uint8Array && Uint8Array, a = r !== typeof ArrayBuffer && ArrayBuffer, s = [0, 0, 0, 0, 0, 0, 0, 0], c = Array.isArray || function(t) {
                return !!t && "[object Array]" == Object.prototype.toString.call(t)
            }
            , h = 4294967296, l = 16777216;
            function u(t, c, u) {
                var M = c ? 0 : 4
                  , _ = c ? 4 : 0
                  , E = c ? 0 : 3
                  , S = c ? 1 : 2
                  , T = c ? 2 : 1
                  , A = c ? 3 : 0
                  , L = c ? y : w
                  , R = c ? x : b
                  , P = O.prototype
                  , C = "is" + t
                  , I = "_" + C;
                return P.buffer = void 0,
                P.offset = 0,
                P[I] = !0,
                P.toNumber = D,
                P.toString = function(t) {
                    var e = this.buffer
                      , n = this.offset
                      , r = N(e, n + M)
                      , i = N(e, n + _)
                      , o = ""
                      , a = !u && 2147483648 & r;
                    for (a && (r = ~r,
                    i = h - i),
                    t = t || 10; ; ) {
                        var s = r % t * h + i;
                        if (r = Math.floor(r / t),
                        i = Math.floor(s / t),
                        o = (s % t).toString(t) + o,
                        !r && !i)
                            break
                    }
                    return a && (o = "-" + o),
                    o
                }
                ,
                P.toJSON = D,
                P.toArray = p,
                i && (P.toBuffer = d),
                o && (P.toArrayBuffer = f),
                O[C] = function(t) {
                    return !(!t || !t[I])
                }
                ,
                e[t] = O,
                O;
                function O(t, e, i, c) {
                    return this instanceof O ? function(t, e, i, c, l) {
                        if (o && a && (e instanceof a && (e = new o(e)),
                        c instanceof a && (c = new o(c))),
                        e || i || c || n) {
                            if (!m(e, i))
                                l = i,
                                c = e,
                                i = 0,
                                e = new (n || Array)(8);
                            t.buffer = e,
                            t.offset = i |= 0,
                            r !== typeof c && ("string" == typeof c ? function(t, e, n, r) {
                                var i = 0
                                  , o = n.length
                                  , a = 0
                                  , s = 0;
                                "-" === n[0] && i++;
                                for (var c = i; i < o; ) {
                                    var l = parseInt(n[i++], r);
                                    if (!(l >= 0))
                                        break;
                                    s = s * r + l,
                                    a = a * r + Math.floor(s / h),
                                    s %= h
                                }
                                c && (a = ~a,
                                s ? s = h - s : a++),
                                U(t, e + M, a),
                                U(t, e + _, s)
                            }(e, i, c, l || 10) : m(c, l) ? g(e, i, c, l) : "number" == typeof l ? (U(e, i + M, c),
                            U(e, i + _, l)) : c > 0 ? L(e, i, c) : c < 0 ? R(e, i, c) : g(e, i, s, 0))
                        } else
                            t.buffer = v(s, 0)
                    }(this, t, e, i, c) : new O(t,e,i,c)
                }
                function D() {
                    var t = this.buffer
                      , e = this.offset
                      , n = N(t, e + M)
                      , r = N(t, e + _);
                    return u || (n |= 0),
                    n ? n * h + r : r
                }
                function U(t, e, n) {
                    t[e + A] = 255 & n,
                    n >>= 8,
                    t[e + T] = 255 & n,
                    n >>= 8,
                    t[e + S] = 255 & n,
                    n >>= 8,
                    t[e + E] = 255 & n
                }
                function N(t, e) {
                    return t[e + E] * l + (t[e + S] << 16) + (t[e + T] << 8) + t[e + A]
                }
            }
            function p(t) {
                var e = this.buffer
                  , r = this.offset;
                return n = null,
                !1 !== t && 0 === r && 8 === e.length && c(e) ? e : v(e, r)
            }
            function d(e) {
                var r = this.buffer
                  , o = this.offset;
                if (n = i,
                !1 !== e && 0 === o && 8 === r.length && t.isBuffer(r))
                    return r;
                var a = new i(8);
                return g(a, 0, r, o),
                a
            }
            function f(t) {
                var e = this.buffer
                  , r = this.offset
                  , i = e.buffer;
                if (n = o,
                !1 !== t && 0 === r && i instanceof a && 8 === i.byteLength)
                    return i;
                var s = new o(8);
                return g(s, 0, e, r),
                s.buffer
            }
            function m(t, e) {
                var n = t && t.length;
                return e |= 0,
                n && e + 8 <= n && "string" != typeof t[e]
            }
            function g(t, e, n, r) {
                e |= 0,
                r |= 0;
                for (var i = 0; i < 8; i++)
                    t[e++] = 255 & n[r++]
            }
            function v(t, e) {
                return Array.prototype.slice.call(t, e, e + 8)
            }
            function y(t, e, n) {
                for (var r = e + 8; r > e; )
                    t[--r] = 255 & n,
                    n /= 256
            }
            function x(t, e, n) {
                var r = e + 8;
                for (n++; r > e; )
                    t[--r] = 255 & -n ^ 255,
                    n /= 256
            }
            function w(t, e, n) {
                for (var r = e + 8; e < r; )
                    t[e++] = 255 & n,
                    n /= 256
            }
            function b(t, e, n) {
                var r = e + 8;
                for (n++; e < r; )
                    t[e++] = 255 & -n ^ 255,
                    n /= 256
            }
            u("Uint64BE", !0, !0),
            u("Int64BE", !0, !1),
            u("Uint64LE", !1, !0),
            u("Int64LE", !1, !1)
        }("object" == typeof e && "string" != typeof e.nodeName ? e : this || {})
    }
    ).call(this, n(21).Buffer)
}
, function(t, e, n) {
    var r = n(36);
    e.copy = c,
    e.slice = h,
    e.toString = function(t, e, n) {
        return (!a && i.isBuffer(this) ? this.toString : r.toString).apply(this, arguments)
    }
    ,
    e.write = function(t) {
        return function() {
            return (this[t] || r[t]).apply(this, arguments)
        }
    }("write");
    var i = n(0)
      , o = i.global
      , a = i.hasBuffer && "TYPED_ARRAY_SUPPORT"in o
      , s = a && !o.TYPED_ARRAY_SUPPORT;
    function c(t, e, n, o) {
        var a = i.isBuffer(this)
          , c = i.isBuffer(t);
        if (a && c)
            return this.copy(t, e, n, o);
        if (s || a || c || !i.isView(this) || !i.isView(t))
            return r.copy.call(this, t, e, n, o);
        var l = n || null != o ? h.call(this, n, o) : this;
        return t.set(l, e),
        l.length
    }
    function h(t, e) {
        var n = this.slice || !s && this.subarray;
        if (n)
            return n.call(this, t, e);
        var r = i.alloc.call(this, e - t);
        return c.call(this, r, 0, t, e),
        r
    }
}
, function(t, e) {
    e.read = function(t, e, n, r, i) {
        var o, a, s = 8 * i - r - 1, c = (1 << s) - 1, h = c >> 1, l = -7, u = n ? i - 1 : 0, p = n ? -1 : 1, d = t[e + u];
        for (u += p,
        o = d & (1 << -l) - 1,
        d >>= -l,
        l += s; l > 0; o = 256 * o + t[e + u],
        u += p,
        l -= 8)
            ;
        for (a = o & (1 << -l) - 1,
        o >>= -l,
        l += r; l > 0; a = 256 * a + t[e + u],
        u += p,
        l -= 8)
            ;
        if (0 === o)
            o = 1 - h;
        else {
            if (o === c)
                return a ? NaN : 1 / 0 * (d ? -1 : 1);
            a += Math.pow(2, r),
            o -= h
        }
        return (d ? -1 : 1) * a * Math.pow(2, o - r)
    }
    ,
    e.write = function(t, e, n, r, i, o) {
        var a, s, c, h = 8 * o - i - 1, l = (1 << h) - 1, u = l >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : o - 1, f = r ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e),
        isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0,
        a = l) : (a = Math.floor(Math.log(e) / Math.LN2),
        e * (c = Math.pow(2, -a)) < 1 && (a--,
        c *= 2),
        (e += a + u >= 1 ? p / c : p * Math.pow(2, 1 - u)) * c >= 2 && (a++,
        c /= 2),
        a + u >= l ? (s = 0,
        a = l) : a + u >= 1 ? (s = (e * c - 1) * Math.pow(2, i),
        a += u) : (s = e * Math.pow(2, u - 1) * Math.pow(2, i),
        a = 0)); i >= 8; t[n + d] = 255 & s,
        d += f,
        s /= 256,
        i -= 8)
            ;
        for (a = a << i | s,
        h += i; h > 0; t[n + d] = 255 & a,
        d += f,
        a /= 256,
        h -= 8)
            ;
        t[n + d - f] |= 128 * m
    }
}
, function(t, e, n) {
    e.ExtBuffer = function t(e, n) {
        if (!(this instanceof t))
            return new t(e,n);
        this.buffer = r.from(e),
        this.type = n
    }
    ;
    var r = n(0)
}
, function(t, e, n) {
    var r = n(9).ExtBuffer
      , i = n(35)
      , o = n(34)
      , a = n(3);
    function s() {
        var t = this.options;
        return this.encode = function(t) {
            var e = o.getWriteType(t);
            return function(t, n) {
                var r = e[typeof n];
                if (!r)
                    throw new Error('Unsupported type "' + typeof n + '": ' + n);
                r(t, n)
            }
        }(t),
        t && t.preset && i.setExtPackers(this),
        this
    }
    a.install({
        addExtPacker: function(t, e, n) {
            n = a.filter(n);
            var i = e.name;
            i && "Object" !== i ? (this.extPackers || (this.extPackers = {}))[i] = o : (this.extEncoderList || (this.extEncoderList = [])).unshift([e, o]);
            function o(e) {
                return n && (e = n(e)),
                new r(e,t)
            }
        },
        getExtPacker: function(t) {
            var e = this.extPackers || (this.extPackers = {})
              , n = t.constructor
              , r = n && n.name && e[n.name];
            if (r)
                return r;
            for (var i = this.extEncoderList || (this.extEncoderList = []), o = i.length, a = 0; a < o; a++) {
                var s = i[a];
                if (n === s[0])
                    return s[1]
            }
        },
        init: s
    }),
    e.preset = s.call(a.preset)
}
, function(t, e, n) {
    const r = n(1);
    function i(t, e, n, r, i, o, a) {
        t.area(e, n, r, i, o, a, {
            src: "fog_0",
            count: Math.round(i / 6),
            spd: .005,
            scl: [50, 60],
            dir: 0
        })
    }
    var o = [{
        id: "ffa",
        name: "Free for All",
        alias: "ffa"
    }, {
        id: "tdm",
        name: "Team Deathmatch",
        alias: "tdm",
        teams: !0
    }];
    t.exports.modes = o;
    for (var a = [{
        name: "burg",
        modes: [0, 1],
        shadScale: 450,
        ambient: 8553090,
        light: 14612479,
        sky: 14477549,
        fog: 13092807,
        fogD: 931.1278286963643,
        camPos: [-234, 19, -400],
        spawns: [[-80, 18, 35], [187, 0, -188], [215, 14, -494], [-215, 0, -509], [-328, 0, -255], [-127, 0, -137], [-125, -28, -341], [56, -28, -497], [332, 0, -227], [114, 0, -365]],
        objects: [{
            p: [-96, 0, 36],
            s: [288, 18, 52],
            t: 1
        }, {
            p: [73, 0, 33],
            s: [50, 18, 46],
            id: 9,
            t: 1,
            d: 2
        }, {
            p: [28, 0, 8],
            s: [152, 24, 4],
            a: .32
        }, {
            p: [0, -4, -45],
            s: [516, 4, 304],
            t: 1
        }, {
            p: [-76, 0, -48],
            s: [56, 74, 122],
            a: .24,
            da: 1.4
        }, {
            p: [37, 0, -68],
            s: [110, 54, 80],
            a: .22
        }, {
            p: [-112, 0, 74],
            s: [126, 64, 38],
            a: .21
        }, {
            p: [-18, 0, 72],
            s: [126, 58, 24],
            a: .33
        }, {
            p: [100, 0, 76],
            s: [116, 76, 44],
            a: .5
        }, {
            p: [-136, 0, -16],
            s: [64, 18, 52],
            t: 1
        }, {
            p: [-136, 0, -44],
            s: [64, 24, 4],
            a: .64,
            da: 1.4
        }, {
            p: [-170, 0, -18],
            s: [4, 24, 56],
            a: .64,
            da: 1.4
        }, {
            p: [-234, 0, -27],
            s: [32, 64, 96],
            a: .4
        }, {
            p: [-240, 0, 41],
            s: [20, 50, 44],
            a: .5
        }, {
            p: [-218, 13, 74],
            s: [88, 38, 54],
            a: .6,
            da: 1.5
        }, {
            p: [185, 0, -9],
            s: [16, 58, 84],
            a: .66
        }, {
            p: [180, 0, 45],
            s: [60, 92, 44],
            a: .55,
            da: 1.5
        }, {
            p: [213, 0, -61],
            s: [94, 88, 60],
            a: .55,
            da: 1.5
        }, {
            p: [96, 0, -175],
            s: [110, 44, 44],
            a: .43
        }, {
            p: [-85, 0, -140],
            s: [56, 84, 112],
            a: .36
        }, {
            p: [126, -4, -303],
            s: [228, 4, 212],
            t: 1
        }, {
            p: [-82, -28, -252],
            s: [60, 94, 138],
            a: .52
        }, {
            p: [9, -28, -274],
            s: [6, 34, 168],
            a: .48
        }, {
            p: [49, -28, -385],
            s: [96, 104, 66],
            a: .61
        }, {
            p: [-23, -28, -252],
            s: [58, 28, 110],
            id: 9,
            t: 1,
            d: 1
        }, {
            p: [-8, -32, -365],
            s: [314, 4, 378],
            t: 1
        }, {
            p: [-116, -28, -377],
            s: [146, 88, 42],
            a: .57
        }, {
            p: [-21, 6, -377],
            s: [44, 38, 20]
        }, {
            p: [-243, 0, -105],
            s: [20, 50, 96],
            a: .48,
            da: 1.4
        }, {
            p: [190, -28, -351],
            s: [116, 86, 128],
            a: .12,
            da: 1.2
        }, {
            p: [-195, 0, -17],
            s: [46, 18, 54],
            id: 9,
            t: 1,
            d: 1
        }, {
            p: [-134, 0, -191],
            s: [90, 72, 76],
            a: .36
        }, {
            p: [-278, 0, -191],
            s: [130, 72, 76],
            a: .48
        }, {
            p: [-230, -22, -238],
            s: [272, 22, 82],
            t: 1
        }, {
            p: [-210, -28, -323],
            s: [132, 90, 66],
            a: .44
        }, {
            p: [-128, -28, -300],
            s: [32, 28, 42],
            id: 9,
            t: 1,
            d: 1
        }, {
            p: [-254, -22, -419],
            s: [214, 22, 280],
            t: 1
        }, {
            p: [-326, -22, -321],
            s: [34, 84, 88],
            a: .44
        }, {
            p: [-341, -2, -253],
            s: [4, 64, 48],
            a: .44
        }, {
            p: [-158, -28, -274],
            s: [28, 90, 32],
            a: .44
        }, {
            p: [-263, -20, -322],
            s: [30, 94, 94],
            a: .44
        }, {
            p: [-330, -23, -394],
            s: [22, 72, 210],
            a: .25
        }, {
            p: [-88, -28, -429],
            s: [78, 28, 62],
            id: 9,
            t: 1,
            d: 2
        }, {
            p: [-103, -22, -497],
            s: [48, 84, 86],
            a: .4,
            da: 1.2
        }, {
            p: [-173, 0, -456],
            s: [20, 50, 16],
            a: .58
        }, {
            p: [-173, 0, -406],
            s: [20, 50, 16],
            a: .64
        }, {
            p: [-173, 30, -431],
            s: [20, 20, 34],
            a: .84
        }, {
            p: [-173, 0, -479],
            s: [26, 58, 40],
            a: .57
        }, {
            p: [-137, -22, -489],
            s: [20, 22, 182],
            t: 1
        }, {
            p: [-164, 0, -547],
            s: [98, 86, 40],
            a: .24,
            da: 1.2
        }, {
            p: [-173, 0, -513],
            s: [16, 22, 28],
            a: .64,
            da: .8
        }, {
            p: [-283, 0, -506],
            s: [72, 10, 86],
            t: 1
        }, {
            p: [-262, 0, -452],
            s: [30, 10, 22],
            t: 1
        }, {
            p: [-300, 0, -450],
            s: [38, 10, 26],
            id: 9,
            t: 1,
            d: 3
        }, {
            p: [-245, 0, -493],
            s: [4, 16, 112],
            a: .83
        }, {
            p: [-262, 0, -439],
            s: [30, 16, 4],
            a: .83
        }, {
            p: [-347, 0, -535],
            s: [72, 78, 76],
            a: .3,
            da: 1.7
        }, {
            p: [-262, 0, -567],
            s: [98, 48, 40],
            a: .29
        }, {
            p: [-319, 0, -587],
            s: [48, 120, 54],
            a: .31,
            da: 1.9
        }, {
            p: [-2, -28, -377],
            s: [6, 34, 20],
            a: .48
        }, {
            p: [-40, -28, -377],
            s: [6, 34, 20],
            a: .48
        }, {
            p: [-63, -28, -482],
            s: [52, 118, 44],
            a: .52
        }, {
            p: [-16, -28, -482],
            s: [46, 44, 16],
            a: .6
        }, {
            p: [85, -28, -498],
            s: [32, 112, 88],
            a: .47
        }, {
            p: [173, -24, -525],
            s: [148, 38, 128],
            t: 1
        }, {
            p: [94, -23, -544],
            s: [144, 88, 46],
            a: .41,
            da: .9
        }, {
            p: [182, -23, -540],
            s: [72, 120, 60],
            a: .29
        }, {
            p: [298, -4, -329],
            s: [116, 4, 264],
            t: 1
        }, {
            p: [279, 0, -485],
            s: [64, 14, 48],
            id: 9,
            t: 1,
            d: 3
        }, {
            p: [278, -24, -541],
            s: [62, 38, 64],
            t: 1
        }, {
            p: [264, -23, -557],
            s: [94, 82, 24],
            a: .29
        }, {
            p: [331, -23, -552],
            s: [54, 98, 110],
            a: .33,
            da: 1.6
        }, {
            p: [332, -23, -499],
            s: [42, 78, 110],
            a: .46
        }, {
            p: [342, -4, -411],
            s: [20, 36, 110],
            a: .61,
            da: 1.3
        }, {
            p: [332, -23, -303],
            s: [54, 96, 110],
            a: .33,
            da: 1.3
        }, {
            p: [114, -28, -426],
            s: [36, 42, 4],
            a: .17
        }, {
            p: [171, -28, -461],
            s: [152, 48, 4],
            a: .25,
            da: 1.3
        }, {
            p: [249, -24, -484],
            s: [4, 44, 50],
            a: .25,
            da: 1.3
        }, {
            p: [194, -28, -437],
            s: [92, 28, 44],
            id: 9,
            t: 1,
            d: 0
        }, {
            p: [228, 0, -120],
            s: [10, 48, 60],
            a: .51
        }, {
            p: [156, 0, -188],
            s: [32, 70, 82],
            a: .34
        }, {
            p: [228, 0, -188],
            s: [32, 86, 82],
            a: .34
        }, {
            p: [324, -37, -144],
            s: [4, 44, 106],
            a: .29
        }, {
            p: [260, -37, -144],
            s: [4, 44, 106],
            a: .29
        }, {
            p: [293, -28, -153],
            s: [64, 28, 88],
            id: 9,
            t: 1,
            d: 3
        }, {
            p: [367, 0, -146],
            s: [58, 50, 118],
            a: .37,
            da: 1.3
        }, {
            p: [347, -28, -63],
            s: [194, 86, 80],
            a: .21,
            da: .9
        }, {
            p: [335, 51, -64],
            s: [60, 88, 56],
            a: .79,
            da: 1.4
        }, {
            p: [348, -4, -227],
            s: [8, 48, 52],
            a: .57
        }, {
            p: [393, 0, -404],
            s: [88, 64, 110],
            a: .26,
            da: 1.1
        }, {
            p: [397, 0, -195],
            s: [58, 76, 80],
            a: .52,
            da: 1.4
        }, {
            p: [-356, 0, -369],
            s: [42, 82, 50],
            a: .09
        }, {
            p: [-264, 0, -84],
            s: [42, 106, 50],
            a: .13,
            da: 1.4
        }, {
            p: [292, -30, -106],
            s: [116, 2, 6],
            da: .8,
            t: 1
        }, {
            p: [1, 0, 0],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-42, 0, -79],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-42, 12, -79],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-42, 0, -67],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [0, -28, -325],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [0, -28, -337],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [0, -16, -333],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-76, -28, -327],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-76, -16, -327],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [237, 14, -469],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [224, 14, -520],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [155, 14, -504],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [167, 14, -504],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [163, 26, -504],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [214, 14, -467],
            s: [7, 8, 7],
            id: 2
        }, {
            p: [125, 8, -417],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [311, 0, -402],
            s: [4, 8, 50],
            a: .61,
            da: 1.2
        }, {
            p: [313, 0, -242],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [210, 0, -281],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [198, 0, -281],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [204, 12, -281],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-59, 18, 19],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-110, 18, -36],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-110, 0, -52],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-122, 0, -52],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-164, 18, -38],
            s: [7, 8, 7],
            id: 2
        }, {
            p: [-214, 18, 15],
            s: [7, 8, 7],
            id: 2
        }, {
            p: [-146, 0, -147],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-154, 0, -252],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-313, 0, -235],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-253, 10, -447],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-253, 10, -541],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-305, 10, -521],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-251, 10, -457],
            s: [7, 8, 7],
            id: 2
        }, {
            p: [-187, 0, -521],
            s: [12, 12, 12],
            id: 8
        }, {
            p: [-220, 0, -481],
            s: [12, 12, 12],
            id: 8
        }, {
            p: [-208, 0, -481],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-208, 12, -481],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [303, 0, -421],
            s: [12, 12, 12],
            id: 8
        }, {
            p: [206, 0, -207],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [206, 0, -195],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [98, 0, -61],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [98, 0, -73],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [96, 0, -51],
            s: [7, 8, 7],
            id: 2
        }, {
            p: [136, 0, -149],
            s: [7, 8, 7],
            id: 2
        }, {
            p: [192, 34, -188],
            s: [40, 24, 82],
            a: .62
        }, {
            p: [114, -4, -416],
            s: [36, 12, 14],
            t: 1
        }, {
            p: [134, -28, -421],
            s: [4, 42, 14],
            a: .17
        }, {
            p: [94, -28, -423],
            s: [4, 42, 10],
            a: .17
        }, {
            p: [-162, 0, -513],
            s: [2, 24, 10],
            id: 3,
            d: 0
        }, {
            p: [337, -4, -150],
            s: [22, 4, 94],
            t: 1
        }, {
            p: [20, -28, -501],
            s: [28, 76, 90],
            a: .52,
            da: 1.1
        }, {
            p: [50, -28, -520],
            s: [38, 64, 16],
            a: .47,
            da: 1.1
        }, {
            p: [63, -28, -464],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [63, -16, -464],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [40, -28, -506],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [63, -28, -476],
            s: [12, 12, 12],
            id: 8
        }, {
            p: [-261, 0, -375],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-261, 12, -375],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-142, 0, -404],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-12, -28, -384],
            s: [14, 34, 2],
            t: 2
        }, {
            p: [-30, -28, -370],
            s: [14, 34, 2],
            t: 2
        }, {
            p: [-165, 0, -440],
            s: [2, 30, 16],
            t: 2
        }, {
            p: [-181, 0, -422],
            s: [2, 30, 16],
            t: 2
        }, {
            p: [173, 0, -233],
            s: [2, 34, 24],
            t: 2
        }, {
            p: [202, 0, -226],
            s: [20, 34, 2],
            t: 2
        }, {
            p: [182, 0, -150],
            s: [20, 34, 2],
            t: 2
        }, {
            p: [211, 0, -162],
            s: [2, 34, 24],
            t: 2
        }, {
            p: [20, 0, -439],
            s: [28, 48, 34],
            a: .69,
            da: 1.1
        }, {
            p: [20, -28, -420],
            s: [28, 76, 4],
            a: .47,
            da: 1.1
        }, {
            p: [-207, 0, -264],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [-195, 0, -264],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [115, 0, -390],
            s: [36, 8, 38],
            id: 9,
            t: 1,
            d: 3
        }, {
            p: [-279, 0, -451],
            s: [4, 16, 28],
            a: .83
        }, {
            p: [-337, 120, -563],
            s: [12, 4, 6],
            col: 1,
            da: 1.9
        }, {
            p: [-299, 120, -566],
            s: [8, 4, 12],
            col: 1,
            da: 1.9
        }, {
            p: [-297, 120, -586],
            s: [4, 4, 12],
            col: 1,
            da: 1.9
        }, {
            p: [-300, 120, -608],
            s: [10, 6, 12],
            col: 1,
            da: 1.9
        }, {
            p: [-316, 120, -563],
            s: [12, 2, 6],
            col: 1,
            da: 1.9
        }, {
            p: [-206, 86, -535],
            s: [14, 4, 16],
            col: 1,
            da: 1.2
        }, {
            p: [-126, 86, -535],
            s: [22, 6, 16],
            col: 1,
            da: 1.2
        }, {
            p: [-165, 86, -530],
            s: [22, 4, 6],
            col: 1,
            da: 1.2
        }, {
            p: [-209, 86, -560],
            s: [8, 4, 14],
            col: 1,
            da: 1.2
        }, {
            p: [-228, 48, -550],
            s: [30, 6, 6],
            col: 1
        }, {
            p: [-267, 48, -550],
            s: [22, 4, 6],
            col: 1
        }, {
            p: [-295, 48, -550],
            s: [20, 4, 6],
            col: 1
        }, {
            p: [-316, 78, -502],
            s: [6, 12, 6],
            col: 1,
            a: .56,
            da: 1.2,
            t: 2
        }, {
            p: [-378, 78, -502],
            s: [6, 8, 6],
            col: 1,
            a: .56,
            da: 1.2,
            t: 2
        }, {
            p: [-318, 78, -504],
            s: [14, 4, 14],
            col: 1,
            da: 1.7
        }, {
            p: [-378, 78, -504],
            s: [10, 2, 14],
            col: 1,
            da: 1.7
        }, {
            p: [-358, 78, -499],
            s: [14, 2, 4],
            col: 1,
            da: 1.7
        }, {
            p: [-314, 78, -536],
            s: [6, 4, 16],
            col: 1,
            da: 1.7
        }, {
            p: [-321, 49, -480],
            s: [4, 6, 24],
            col: 1
        }, {
            p: [-321, 49, -384],
            s: [4, 6, 16],
            col: 1
        }, {
            p: [-321, 49, -413],
            s: [4, 4, 16],
            col: 1
        }, {
            p: [-321, 49, -446],
            s: [4, 4, 12],
            col: 1
        }, {
            p: [-173, 50, -447],
            s: [20, 4, 12],
            col: 1
        }, {
            p: [-173, 50, -415],
            s: [20, 2, 20],
            col: 1
        }, {
            p: [-173, 22, -513],
            s: [22, 2, 28],
            t: 2
        }, {
            p: [-164, 0, -513],
            s: [4, 24, 28],
            v: 1,
            a: .44
        }, {
            p: [-173, 58, -465],
            s: [26, 6, 12],
            col: 1
        }, {
            p: [-173, 58, -493],
            s: [26, 6, 12],
            col: 1
        }, {
            p: [-53, 60, -392],
            s: [20, 6, 12],
            col: 1
        }, {
            p: [-182, 60, -362],
            s: [14, 6, 12],
            col: 1
        }, {
            p: [234, 59, -548],
            s: [20, 4, 6],
            col: 1
        }, {
            p: [262, 59, -548],
            s: [14, 4, 6],
            col: 1
        }, {
            p: [288, 59, -548],
            s: [20, 4, 6],
            col: 1
        }, {
            p: [-82, 90, -466],
            s: [14, 6, 12],
            col: 1
        }, {
            p: [-41, 90, -467],
            s: [8, 6, 14],
            col: 1
        }, {
            p: [-44, 90, -499],
            s: [14, 6, 10],
            col: 1
        }, {
            p: [-60, 90, -463],
            s: [14, 4, 6],
            col: 1
        }, {
            p: [-39, 90, -483],
            s: [4, 2, 8],
            col: 1
        }, {
            p: [-84, 90, -498],
            s: [10, 6, 12],
            col: 1
        }, {
            p: [-87, 90, -482],
            s: [4, 2, 10],
            col: 1
        }, {
            p: [-63, 71, -450],
            s: [4, 4, 20],
            t: 2
        }, {
            p: [-122, 62, -459],
            s: [6, 10, 6],
            col: 1,
            a: .56,
            t: 2
        }, {
            p: [-124, 62, -507],
            s: [6, 4, 22],
            col: 1,
            da: 1.2
        }, {
            p: [-124, 62, -476],
            s: [6, 4, 14],
            col: 1,
            da: 1.2
        }, {
            p: [-88, 62, -457],
            s: [18, 4, 6],
            col: 1,
            da: 1.2
        }, {
            p: [-27, 16, -477],
            s: [12, 4, 6],
            col: 1
        }, {
            p: [-6, 16, -477],
            s: [16, 2, 6],
            col: 1
        }, {
            p: [-35, -28, -486],
            s: [4, 72, 4],
            a: .52,
            da: 1.1,
            t: 2
        }, {
            p: [4, -28, -486],
            s: [4, 72, 4],
            a: .55,
            da: 1.1,
            t: 2
        }, {
            p: [4, -28, -520],
            s: [4, 74, 4],
            a: .52,
            da: 1.1,
            t: 2
        }, {
            p: [-35, -28, -520],
            s: [4, 74, 4],
            a: .52,
            da: 1.1,
            t: 2
        }, {
            p: [-16, 37, -503],
            s: [44, 2, 44],
            t: 2
        }, {
            p: [-132, 60, -396],
            s: [26, 4, 4],
            col: 1
        }, {
            p: [-179, 60, -392],
            s: [20, 6, 12],
            col: 1
        }, {
            p: [-89, 60, -396],
            s: [14, 4, 4],
            col: 1
        }, {
            p: [20, 48, -435],
            s: [28, 4, 14],
            col: 1,
            da: 1.1
        }, {
            p: [20, 48, -467],
            s: [28, 4, 16],
            col: 1,
            da: 1.1
        }, {
            p: [20, 48, -497],
            s: [28, 4, 20],
            col: 1,
            da: 1.1
        }, {
            p: [85, 66, -451],
            s: [4, 4, 6],
            t: 2
        }, {
            p: [-35, 45, -97],
            s: [40, 4, 4],
            t: 2
        }, {
            p: [-35, 46, -68],
            s: [40, 4, 4],
            t: 2
        }, {
            p: [-35, 47, -41],
            s: [40, 4, 4],
            t: 2
        }, {
            p: [-34, 44, -377],
            s: [12, 4, 20],
            col: 1
        }, {
            p: [-14, 44, -377],
            s: [10, 2, 20],
            col: 1
        }, {
            p: [-341, 82, -387],
            s: [12, 4, 14],
            col: 1
        }, {
            p: [-341, 82, -350],
            s: [12, 6, 12],
            col: 1
        }, {
            p: [-338, 82, -369],
            s: [6, 2, 12],
            col: 1
        }, {
            p: [-371, 82, -389],
            s: [12, 4, 10],
            col: 1
        }, {
            p: [-356, 82, -392],
            s: [8, 2, 4],
            col: 1
        }, {
            p: [25, 65, -561],
            s: [6, 4, 12],
            col: 1
        }, {
            p: [29, 65, -530],
            s: [14, 6, 18],
            col: 1
        }, {
            p: [53, 65, -523],
            s: [18, 4, 4],
            col: 1
        }, {
            p: [135, 65, -523],
            s: [12, 4, 4],
            col: 1
        }, {
            p: [114, 65, -523],
            s: [12, 4, 4],
            col: 1,
            da: .9
        }, {
            p: [211, 97, -517],
            s: [14, 6, 14],
            col: 1
        }, {
            p: [153, 97, -518],
            s: [14, 4, 16],
            col: 1
        }, {
            p: [184, 97, -514],
            s: [22, 2, 8],
            col: 1
        }, {
            p: [215, 97, -539],
            s: [6, 2, 18],
            col: 1
        }, {
            p: [211, 97, -564],
            s: [14, 6, 12],
            col: 1
        }, {
            p: [153, 97, -562],
            s: [14, 6, 16],
            col: 1
        }, {
            p: [149, 97, -539],
            s: [6, 2, 12],
            col: 1
        }, {
            p: [119, 20, -461],
            s: [16, 4, 4],
            da: 1.3
        }, {
            p: [176, 20, -461],
            s: [38, 2, 4],
            da: 1.3
        }, {
            p: [242, 20, -461],
            s: [18, 2, 4],
            da: 1.4
        }, {
            p: [249, 20, -497],
            s: [4, 2, 10]
        }, {
            p: [96, 84, -459],
            s: [6, 12, 6],
            col: 1,
            a: .93,
            t: 2
        }, {
            p: [74, 84, -459],
            s: [6, 10, 6],
            col: 1,
            a: .93,
            t: 2
        }, {
            p: [74, 84, -537],
            s: [6, 18, 6],
            col: 1,
            a: .93,
            t: 2
        }, {
            p: [96, 84, -537],
            s: [6, 14, 6],
            col: 1,
            a: .93,
            t: 2
        }, {
            p: [94, 84, -463],
            s: [14, 4, 18],
            col: 1
        }, {
            p: [74, 84, -463],
            s: [10, 4, 18],
            col: 1
        }, {
            p: [76, 84, -533],
            s: [14, 4, 18],
            col: 1
        }, {
            p: [96, 84, -533],
            s: [10, 4, 18],
            col: 1
        }, {
            p: [98, 84, -498],
            s: [6, 4, 20],
            col: 1
        }, {
            p: [72, 84, -498],
            s: [6, 4, 26],
            col: 1
        }, {
            p: [91, 76, -413],
            s: [6, 16, 6],
            col: 1,
            a: .93,
            t: 2
        }, {
            p: [85, 76, -409],
            s: [24, 6, 18],
            col: 1
        }, {
            p: [13, 76, -409],
            s: [24, 6, 18],
            col: 1
        }, {
            p: [48, 76, -415],
            s: [20, 4, 6],
            col: 1
        }, {
            p: [12, 76, -359],
            s: [22, 6, 14],
            col: 1
        }, {
            p: [5, 76, -382],
            s: [8, 4, 14],
            col: 1
        }, {
            p: [53, 76, -355],
            s: [22, 4, 6],
            col: 1
        }, {
            p: [85, 76, -361],
            s: [24, 6, 18],
            col: 1
        }, {
            p: [93, 76, -387],
            s: [8, 4, 14],
            col: 1
        }, {
            p: [6, 76, -413],
            s: [6, 20, 6],
            col: 1,
            a: .93,
            t: 2
        }, {
            p: [6, 76, -357],
            s: [6, 20, 6],
            col: 1,
            a: .93,
            t: 2
        }, {
            p: [334, 32, -435],
            s: [4, 4, 18],
            col: 1,
            da: 1.3
        }, {
            p: [334, 32, -376],
            s: [4, 4, 18],
            col: 1,
            da: 1.2
        }, {
            p: [334, 32, -406],
            s: [4, 2, 22],
            col: 1,
            da: 1.4
        }, {
            p: [311, 8, -419],
            s: [4, 2, 16],
            da: 1.2
        }, {
            p: [311, 8, -385],
            s: [4, 2, 16],
            da: 1.2
        }, {
            p: [153, 58, -412],
            s: [42, 12, 6],
            col: 1,
            da: 1.2
        }, {
            p: [136, 58, -388],
            s: [8, 18, 42],
            col: 1,
            da: 1.2
        }, {
            p: [186, 58, -412],
            s: [24, 6, 6],
            col: 1,
            da: 1.2
        }, {
            p: [245, 58, -370],
            s: [6, 4, 26],
            col: 1,
            da: 1.2
        }, {
            p: [234, 58, -406],
            s: [28, 8, 18],
            col: 1,
            da: 1.2
        }, {
            p: [236, 58, -299],
            s: [24, 8, 24],
            col: 1,
            da: 1.2
        }, {
            p: [245, 58, -334],
            s: [6, 4, 18],
            col: 1,
            da: 1.2
        }, {
            p: [243, 61, -410],
            s: [6, 16, 6],
            col: 1,
            a: .93,
            t: 2
        }, {
            p: [311, 73, -349],
            s: [12, 6, 18],
            col: 1,
            da: 1.3
        }, {
            p: [331, 73, -356],
            s: [12, 4, 4],
            col: 1,
            da: 1.3
        }, {
            p: [353, 73, -349],
            s: [12, 6, 18],
            col: 1,
            da: 1.3
        }, {
            p: [308, 73, -306],
            s: [6, 4, 38],
            col: 1,
            da: 1.3
        }, {
            p: [312, 73, -259],
            s: [14, 6, 22],
            col: 1,
            da: 1.3
        }, {
            p: [332, 73, -250],
            s: [12, 4, 4],
            col: 1,
            da: 1.3
        }, {
            p: [353, 73, -257],
            s: [12, 6, 18],
            col: 1,
            da: 1.3
        }, {
            p: [285, 58, -84],
            s: [2, 40, 2],
            col: 1,
            a: .58,
            t: 2
        }, {
            p: [285, 58, -48],
            s: [2, 40, 2],
            col: 1,
            a: .58,
            t: 2
        }, {
            p: [294, 93, -66],
            s: [22, 2, 40],
            a: .58,
            t: 2
        }, {
            p: [193, 58, -290],
            s: [24, 4, 6],
            col: 1,
            da: 1.2
        }, {
            p: [136, 58, -336],
            s: [8, 6, 24],
            col: 1,
            da: 1.2
        }, {
            p: [367, 50, -146],
            s: [66, 2, 124],
            da: 1.2,
            t: 2
        }, {
            p: [397, 76, -195],
            s: [64, 2, 86],
            da: 1.3,
            t: 2
        }, {
            p: [348, 44, -236],
            s: [8, 4, 16],
            col: 1
        }, {
            p: [348, 44, -216],
            s: [8, 2, 8],
            col: 1
        }, {
            p: [352, 64, -379],
            s: [6, 4, 24],
            col: 1,
            da: 1.1
        }, {
            p: [352, 64, -415],
            s: [6, 2, 20],
            col: 1,
            da: 1.1
        }, {
            p: [355, 64, -448],
            s: [12, 4, 22],
            col: 1,
            da: 1.1
        }, {
            p: [313, 55, -490],
            s: [4, 4, 14],
            col: 1
        }, {
            p: [318, 55, -451],
            s: [14, 4, 14],
            col: 1
        }, {
            p: [313, 55, -473],
            s: [4, 2, 10],
            col: 1
        }, {
            p: [342, 55, -446],
            s: [14, 4, 4],
            col: 1
        }, {
            p: [315, 75, -509],
            s: [22, 6, 24],
            col: 1,
            da: 1.6
        }, {
            p: [307, 75, -544],
            s: [6, 4, 20],
            col: 1,
            da: 1.6
        }, {
            p: [307, 75, -576],
            s: [6, 4, 22],
            col: 1,
            da: 1.6
        }, {
            p: [350, 75, -500],
            s: [16, 6, 6],
            col: 1,
            da: 1.6
        }, {
            p: [385, 58, -100],
            s: [34, 6, 6],
            col: 1,
            da: .9
        }, {
            p: [333, 58, -100],
            s: [26, 4, 6],
            col: 1,
            da: .9
        }, {
            p: [289, 58, -100],
            s: [22, 6, 6],
            col: 1,
            da: .9
        }, {
            p: [257, 58, -95],
            s: [14, 6, 16],
            col: 1,
            da: .9
        }, {
            p: [335, 139, -89],
            s: [16, 4, 6],
            col: 1,
            da: 1.4
        }, {
            p: [313, 139, -84],
            s: [16, 6, 16],
            col: 1,
            da: 1.4
        }, {
            p: [359, 139, -84],
            s: [12, 6, 16],
            col: 1,
            da: 1.4
        }, {
            p: [313, 139, -44],
            s: [16, 6, 16],
            col: 1,
            da: 1.4
        }, {
            p: [308, 139, -64],
            s: [6, 4, 12],
            col: 1,
            da: 1.4
        }, {
            p: [228, 48, -132],
            s: [10, 2, 16],
            col: 1
        }, {
            p: [228, 48, -106],
            s: [10, 4, 20],
            col: 1
        }, {
            p: [-196, 44, -191],
            s: [34, 28, 76],
            a: .78
        }, {
            p: [-293, 40, -321],
            s: [32, 22, 88],
            a: .88
        }, {
            p: [-192, 62, -323],
            s: [20, 4, 66],
            col: 1
        }, {
            p: [-328, 62, -361],
            s: [20, 4, 8],
            col: 1
        }, {
            p: [-296, 62, -361],
            s: [20, 4, 8],
            col: 1
        }, {
            p: [-253, 73, -364],
            s: [6, 10, 6],
            col: 1,
            a: .56,
            da: 1.2,
            t: 2
        }, {
            p: [-274, 73, -364],
            s: [6, 14, 6],
            col: 1,
            a: .56,
            da: 1.2,
            t: 2
        }, {
            p: [-274, 74, -322],
            s: [8, 4, 94],
            col: 1
        }, {
            p: [-252, 74, -283],
            s: [8, 4, 16],
            col: 1
        }, {
            p: [9, 6, -313],
            s: [6, 2, 18]
        }, {
            p: [9, 6, -199],
            s: [6, 4, 18]
        }, {
            p: [9, 6, -252],
            s: [6, 2, 10]
        }, {
            p: [-341, 62, -237],
            s: [4, 4, 12],
            col: 1
        }, {
            p: [-341, 62, -263],
            s: [4, 2, 16],
            col: 1
        }, {
            p: [164, 0, -61],
            s: [4, 62, 4],
            a: .55,
            t: 2
        }, {
            p: [154, 54, -61],
            s: [16, 4, 4],
            t: 2
        }, {
            p: [158, 51, -61],
            s: [16, 2, 2],
            col: 1,
            r: [0, 0, -.7],
            t: 2
        }, {
            p: [-263, 0, -273],
            s: [4, 54, 4],
            a: .73,
            t: 2
        }, {
            p: [-263, 47, -263],
            s: [4, 4, 16],
            t: 2
        }, {
            p: [-263, 43, -268],
            s: [2, 2, 16],
            col: 1,
            r: [-.7, 0, 0],
            t: 2
        }, {
            p: [238, 86, -224],
            s: [12, 4, 10],
            col: 1
        }, {
            p: [240, 86, -152],
            s: [8, 4, 10],
            col: 1
        }, {
            p: [217, 86, -222],
            s: [10, 4, 14],
            col: 1
        }, {
            p: [242, 86, -189],
            s: [4, 4, 28],
            col: 1
        }, {
            p: [251, 88, -82],
            s: [18, 6, 18],
            col: 1,
            da: 1.5
        }, {
            p: [176, 88, -82],
            s: [20, 6, 18],
            col: 1,
            da: 1.5
        }, {
            p: [176, 88, -40],
            s: [20, 6, 18],
            col: 1,
            da: 1.5
        }, {
            p: [207, 88, -88],
            s: [20, 4, 6],
            col: 1,
            da: 1.5
        }, {
            p: [168, 88, -61],
            s: [4, 2, 12],
            col: 1,
            da: 1.5
        }, {
            p: [254, 88, -41],
            s: [12, 6, 20],
            col: 1,
            da: 1.5
        }, {
            p: [214, 88, -34],
            s: [30, 4, 6],
            col: 1,
            da: 1.5
        }, {
            p: [433, 58, -92],
            s: [22, 6, 22],
            col: 1,
            da: .9
        }, {
            p: [145, 70, -158],
            s: [10, 4, 22],
            col: 1
        }, {
            p: [168, 70, -154],
            s: [8, 4, 14],
            col: 1
        }, {
            p: [145, 70, -218],
            s: [10, 4, 22],
            col: 1
        }, {
            p: [168, 70, -222],
            s: [8, 4, 14],
            col: 1
        }, {
            p: [214, 86, -184],
            s: [4, 2, 24],
            col: 1
        }, {
            p: [216, 86, -152],
            s: [8, 4, 10],
            col: 1
        }, {
            p: [179, 58, -22],
            s: [4, 4, 18],
            col: 1
        }, {
            p: [179, 58, 0],
            s: [4, 2, 14],
            col: 1
        }, {
            p: [179, 58, 18],
            s: [4, 4, 12],
            col: 1
        }, {
            p: [136, 44, -157],
            s: [4, 20, 4],
            a: .73,
            t: 2
        }, {
            p: [45, 44, -157],
            s: [4, 20, 4],
            a: .73,
            t: 2
        }, {
            p: [45, 44, -193],
            s: [4, 22, 4],
            a: .73,
            t: 2
        }, {
            p: [136, 44, -193],
            s: [4, 22, 4],
            a: .73,
            t: 2
        }, {
            p: [91, 58, -175],
            s: [100, 2, 44],
            a: .73,
            t: 2
        }, {
            p: [127, 44, -155],
            s: [26, 4, 4],
            col: 1
        }, {
            p: [48, 44, -159],
            s: [14, 4, 12],
            col: 1
        }, {
            p: [44, 44, -191],
            s: [6, 4, 12],
            col: 1
        }, {
            p: [90, 44, -155],
            s: [18, 2, 4],
            col: 1
        }, {
            p: [195, 58, -226],
            s: [18, 4, 6],
            col: 1
        }, {
            p: [186, 58, -150],
            s: [18, 4, 6],
            col: 1
        }, {
            p: [-3, 54, -100],
            s: [30, 6, 16],
            col: 1
        }, {
            p: [77, 54, -98],
            s: [30, 6, 20],
            col: 1
        }, {
            p: [79, 54, -35],
            s: [26, 6, 14],
            col: 1
        }, {
            p: [-5, 54, -35],
            s: [26, 6, 14],
            col: 1
        }, {
            p: [89, 54, -66],
            s: [6, 4, 20],
            col: 1
        }, {
            p: [37, 54, -105],
            s: [30, 4, 6],
            col: 1
        }, {
            p: [-15, 54, -66],
            s: [6, 4, 20],
            col: 1
        }, {
            p: [38, 54, -31],
            s: [18, 4, 6],
            col: 1
        }, {
            p: [-53, 60, -364],
            s: [20, 6, 16],
            col: 1
        }, {
            p: [100, 76, 76],
            s: [124, 2, 52],
            t: 2
        }, {
            p: [-18, 58, 72],
            s: [126, 2, 30],
            da: .9,
            t: 2
        }, {
            p: [-112, 64, 74],
            s: [130, 2, 44],
            t: 2
        }, {
            p: [-237, 50, 35],
            s: [14, 2, 10],
            col: 1
        }, {
            p: [164, 92, 31],
            s: [28, 6, 16],
            col: 1,
            da: 1.5
        }, {
            p: [203, 92, 31],
            s: [14, 6, 16],
            col: 1,
            da: 1.5
        }, {
            p: [156, 92, 60],
            s: [12, 6, 14],
            col: 1,
            da: 1.5
        }, {
            p: [-260, 47, 19],
            s: [4, 36, 158],
            a: .6,
            da: 1.5
        }, {
            p: [-216, 47, 99],
            s: [108, 36, 4],
            a: .6,
            da: 1.5
        }, {
            p: [-178, 13, 51],
            s: [4, 64, 4],
            a: .6,
            da: 1.1,
            t: 2
        }, {
            p: [-254, 13, 51],
            s: [4, 64, 4],
            a: .6,
            da: 1.1,
            t: 2
        }, {
            p: [-216, 72, 72],
            s: [84, 2, 50],
            da: 1.1,
            t: 2
        }, {
            p: [-260, 83, 73],
            s: [4, 4, 20],
            col: 1,
            da: 1.5
        }, {
            p: [-189, 83, 99],
            s: [26, 4, 4],
            col: 1,
            da: 1.5
        }, {
            p: [-239, 83, 99],
            s: [24, 6, 4],
            col: 1,
            da: 1.5
        }, {
            p: [-55, 74, 2],
            s: [14, 6, 22],
            col: 1,
            da: 1.4
        }, {
            p: [-97, 74, 1],
            s: [14, 6, 24],
            col: 1,
            da: 1.4
        }, {
            p: [-102, 74, -42],
            s: [4, 4, 24],
            col: 1,
            da: 1.4
        }, {
            p: [-102, 74, -75],
            s: [4, 4, 14],
            col: 1,
            da: 1.4
        }, {
            p: [-77, 74, 11],
            s: [14, 4, 4],
            col: 1,
            da: 1.4
        }, {
            p: [-50, 74, -45],
            s: [4, 4, 24],
            col: 1,
            da: 1.4
        }, {
            p: [-54, 74, -97],
            s: [12, 4, 24],
            col: 1,
            da: 1.4
        }, {
            p: [-236, 50, -131],
            s: [6, 4, 24],
            col: 1,
            da: 1.4
        }, {
            p: [-236, 50, -96],
            s: [6, 4, 22],
            col: 1,
            da: 1.4
        }, {
            p: [-221, 64, 12],
            s: [6, 4, 18],
            col: 1
        }, {
            p: [-244, 64, 14],
            s: [12, 4, 14],
            col: 1
        }, {
            p: [-224, 64, -61],
            s: [12, 4, 28],
            col: 1
        }, {
            p: [-220, 64, -25],
            s: [4, 4, 22],
            col: 1
        }, {
            p: [-246, 106, -84],
            s: [6, 4, 14],
            col: 1,
            da: 1.4
        }, {
            p: [-251, 106, -64],
            s: [16, 6, 10],
            col: 1,
            da: 1.4
        }, {
            p: [-251, 106, -104],
            s: [16, 6, 10],
            col: 1,
            da: 1.4
        }, {
            p: [-278, 106, -66],
            s: [14, 4, 14],
            col: 1,
            da: 1.4
        }, {
            p: [-278, 106, -105],
            s: [14, 4, 8],
            col: 1,
            da: 1.4
        }, {
            p: [-109, 60, -359],
            s: [34, 4, 6],
            col: 1
        }, {
            p: [-141, 72, -191],
            s: [30, 4, 76],
            col: 1
        }, {
            p: [-189, 72, -191],
            s: [26, 6, 76],
            col: 1
        }, {
            p: [-240, 72, -191],
            s: [26, 4, 76],
            col: 1
        }, {
            p: [-297, 72, -191],
            s: [36, 6, 76],
            col: 1
        }, {
            p: [-260, 83, 35],
            s: [4, 4, 16],
            col: 1,
            da: 1.5
        }, {
            p: [-260, 83, -35],
            s: [4, 4, 16],
            col: 1,
            da: 1.5
        }, {
            p: [-260, 83, -1],
            s: [4, 4, 14],
            col: 1,
            da: 1.5
        }, {
            p: [336, 139, -39],
            s: [16, 4, 6],
            col: 1,
            da: 1.4
        }, {
            p: [361, 139, -44],
            s: [8, 6, 16],
            col: 1,
            da: 1.4
        }, {
            p: [-296, 62, -281],
            s: [20, 4, 8],
            col: 1
        }, {
            p: [-323, 62, -281],
            s: [14, 4, 8],
            col: 1
        }, {
            p: [9, -2, -180],
            s: [4, 56, 4],
            a: .73,
            t: 2
        }, {
            p: [9, 44, -175],
            s: [2, 2, 12],
            col: 1,
            r: [-.7, 0, 0],
            t: 2
        }, {
            p: [-106, 84, -96],
            s: [14, 6, 24],
            col: 1
        }, {
            p: [-110, 84, -137],
            s: [6, 4, 24],
            col: 1
        }, {
            p: [-108, 84, -184],
            s: [10, 4, 24],
            col: 1
        }, {
            p: [-64, 84, -96],
            s: [14, 6, 24],
            col: 1
        }, {
            p: [-64, 84, -184],
            s: [14, 6, 24],
            col: 1
        }, {
            p: [-60, 84, -137],
            s: [6, 4, 16],
            col: 1
        }, {
            p: [-182, 51, 55],
            s: [16, 4, 16],
            col: 1,
            da: 1.5
        }, {
            p: [-250, 51, 50],
            s: [16, 4, 6],
            col: 1,
            da: 1.5
        }, {
            p: [-212, 51, 50],
            s: [16, 2, 6],
            col: 1,
            da: 1.5
        }, {
            p: [-252, 51, 60],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [50, 36, -520],
            s: [18, 4, 16],
            col: 1,
            da: 1.1
        }, {
            p: [343, 30, -394],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [260, 7, -178],
            s: [4, 2, 22]
        }, {
            p: [260, 7, -129],
            s: [4, 4, 22]
        }, {
            p: [324, 7, -129],
            s: [4, 4, 22]
        }, {
            p: [324, 7, -182],
            s: [4, 2, 16]
        }, {
            p: [243, 61, -292],
            s: [6, 14, 6],
            col: 1,
            a: .93,
            t: 2
        }, {
            p: [10, 24, 8],
            s: [18, 2, 4]
        }, {
            p: [82, 24, 8],
            s: [20, 2, 4]
        }, {
            p: [-42, 24, 8],
            s: [10, 2, 4]
        }, {
            p: [-129, 24, -44],
            s: [16, 2, 4],
            da: 1.4
        }, {
            p: [-164, 24, -44],
            s: [16, 2, 4],
            da: 1.4
        }, {
            p: [-170, 24, -31],
            s: [4, 2, 22],
            da: 1.4
        }, {
            p: [-170, 24, 4],
            s: [4, 2, 12],
            da: 1.4
        }, {
            p: [-259, 16, -439],
            s: [14, 2, 4]
        }, {
            p: [-245, 16, -522],
            s: [4, 2, 12]
        }, {
            p: [-245, 16, -479],
            s: [4, 2, 12]
        }, {
            p: [-227, 62, -323],
            s: [20, 4, 66],
            col: 1
        }, {
            p: [-108, 88, -89],
            s: [6, 12, 6],
            col: 1,
            a: .73,
            t: 2
        }, {
            p: [-250, 44, -124],
            s: [4, 36, 4],
            a: .73,
            t: 2
        }, {
            p: [-280, 44, -124],
            s: [4, 40, 4],
            a: .73,
            t: 2
        }, {
            p: [-265, 74, -117],
            s: [38, 2, 22],
            a: .73,
            t: 2
        }, {
            p: [-175, 0, -269],
            s: [4, 56, 4],
            a: .73,
            t: 2
        }, {
            p: [-223, 0, -269],
            s: [4, 52, 4],
            a: .73,
            t: 2
        }, {
            p: [-199, 46, -278],
            s: [56, 2, 26],
            t: 2
        }, {
            p: [-57, 66, -201],
            s: [10, 6, 36],
            col: 1
        }, {
            p: [-57, 66, -260],
            s: [10, 4, 26],
            col: 1
        }, {
            p: [-61, 66, -308],
            s: [18, 4, 26],
            col: 1
        }, {
            p: [-103, 66, -308],
            s: [18, 4, 26],
            col: 1
        }, {
            p: [-107, 66, -260],
            s: [10, 4, 26],
            col: 1
        }, {
            p: [-168, 62, -268],
            s: [8, 4, 20],
            col: 1
        }, {
            p: [-150, 62, -268],
            s: [12, 4, 20],
            col: 1
        }, {
            p: [-148, 62, -304],
            s: [8, 4, 20],
            col: 1
        }, {
            p: [-148, 62, -342],
            s: [8, 4, 28],
            col: 1
        }, {
            p: [128, 14, -426],
            s: [16, 2, 4]
        }, {
            p: [98, 14, -426],
            s: [12, 2, 4]
        }, {
            p: [335, 100, -64],
            s: [6, 20, 58],
            col: 1,
            da: .1
        }, {
            p: [196, 51, -91],
            s: [6, 20, 2],
            col: 1,
            da: .1
        }, {
            p: [-243, 79, -84],
            s: [2, 16, 6],
            col: 1,
            da: .1
        }, {
            p: [-295, 84, -587],
            s: [2, 18, 6],
            col: 1,
            da: .1
        }, {
            p: [-319, 91, -560],
            s: [4, 16, 2],
            col: 1,
            da: .1
        }, {
            p: [305, 105, -64],
            s: [2, 20, 6],
            col: 1,
            da: .1
        }, {
            p: [304, 46, -518],
            s: [2, 14, 6],
            col: 1,
            da: .1
        }, {
            p: [203, 70, -510],
            s: [6, 14, 2],
            col: 1,
            da: .1
        }, {
            p: [183, 70, -510],
            s: [6, 14, 2],
            col: 1,
            da: .1
        }, {
            p: [162, 70, -510],
            s: [6, 14, 2],
            col: 1,
            da: .1
        }, {
            p: [-102, 18, 19],
            s: [2, 38, 2],
            a: .53,
            t: 2
        }, {
            p: [-68, 18, 19],
            s: [2, 40, 2],
            a: .53,
            t: 2
        }, {
            p: [-85, 52, 17],
            s: [38, 2, 8],
            t: 2
        }, {
            p: [134, 0, 45],
            s: [2, 56, 2],
            a: .53,
            t: 2
        }, {
            p: [84, 0, 45],
            s: [2, 56, 2],
            a: .53,
            t: 2
        }, {
            p: [109, 48, 49],
            s: [54, 2, 12],
            t: 2
        }, {
            p: [38, 18, 56],
            s: [7, 8, 7],
            id: 2
        }, {
            p: [4, -28, -462],
            s: [2, 36, 2],
            t: 2
        }, {
            p: [-35, -28, -462],
            s: [2, 36, 2],
            t: 2
        }, {
            p: [-15, 3, -467],
            s: [44, 2, 14],
            t: 2
        }, {
            p: [301, 60, -301],
            s: [8, 4, 4],
            t: 2
        }, {
            p: [301, 60, -339],
            s: [8, 4, 4],
            t: 2
        }, {
            p: [301, 60, -263],
            s: [8, 4, 4],
            t: 2
        }, {
            p: [318, 60, -304],
            s: [4, 4, 126],
            t: 2
        }, {
            p: [341, 60, -304],
            s: [4, 4, 126],
            t: 2
        }, {
            p: [-180, 0, -147],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [-225, 0, -145],
            s: [8, 2, 6],
            col: 1,
            a: .62
        }, {
            p: [-208, 0, -158],
            s: [4, 2, 6],
            col: 1,
            a: .62
        }, {
            p: [-177, 0, -259],
            s: [4, 2, 6],
            col: 1,
            a: .62
        }, {
            p: [-273, 0, -270],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [-242, 0, -431],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [-285, 0, -434],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [-190, 0, -404],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [-155, 0, -405],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [-249, 0, -375],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [-5, -28, -393],
            s: [6, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [54, -28, -475],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [87, -28, -424],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [304, 0, -408],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [334, 0, -200],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [301, 0, -255],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [300, 0, -354],
            s: [6, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [253, 0, -190],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [223, 0, -232],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [183, 0, -284],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [178, 14, -503],
            s: [4, 2, 6],
            col: 1,
            a: .65
        }, {
            p: [106, 14, -473],
            s: [6, 2, 10],
            col: 1
        }, {
            p: [101, 0, -355],
            s: [4, 2, 8],
            col: 1
        }, {
            p: [15, 0, -345],
            s: [4, 2, 8],
            col: 1,
            a: .67
        }, {
            p: [15, 0, -197],
            s: [4, 2, 8],
            col: 1,
            a: .86
        }, {
            p: [-50, 0, -175],
            s: [6, 2, 8],
            col: 1
        }, {
            p: [97, 0, -87],
            s: [6, 2, 8],
            col: 1
        }, {
            p: [217, 0, -140],
            s: [6, 2, 8],
            col: 1
        }, {
            p: [94, 0, 0],
            s: [10, 2, 4],
            col: 1
        }, {
            p: [-43, 0, -1],
            s: [6, 2, 8],
            col: 1
        }, {
            p: [-11, 18, 15],
            s: [10, 2, 4],
            col: 1
        }, {
            p: [-147, 18, -37],
            s: [10, 2, 4],
            col: 1
        }, {
            p: [-108, 18, 4],
            s: [4, 2, 10],
            col: 1
        }, {
            p: [-136, 0, -52],
            s: [8, 2, 6],
            col: 1,
            a: .62
        }, {
            p: [161, 0, -52],
            s: [6, 2, 8],
            col: 1
        }, {
            p: [42, 0, -147],
            s: [8, 2, 6],
            col: 1
        }, {
            p: [-305, 0, -349],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [-332, 0, -270],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [-66, -28, -327],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [-140, -28, -350],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [-7, 0, -112],
            s: [8, 2, 4],
            col: 1
        }, {
            p: [-182, 0, -218],
            s: [4, 2, 8],
            col: 1,
            a: .62
        }, {
            p: [-210, 18, 43],
            s: [8, 2, 4],
            col: 1
        }, {
            p: [-43, 18, 53],
            s: [6, 2, 8],
            col: 1
        }, {
            p: [118, 0, -147],
            s: [6, 2, 8],
            col: 1,
            a: .84
        }, {
            p: [-218, 0, -470],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [-199, 0, -523],
            s: [8, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [299, 14, -535],
            s: [4, 2, 6],
            col: 1
        }, {
            p: [300, 0, -347],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [305, 0, -384],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [324, 0, -203],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [221, 0, -278],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [194, 0, -270],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [160, 0, -70],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [-52, 0, -163],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [15, 0, -329],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [93, -28, -431],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [251, 0, -407],
            s: [4, 2, 6],
            col: 1
        }, {
            p: [-5, -28, -411],
            s: [12, 12, 12],
            id: 1
        }, {
            p: [252, 0, -301],
            s: [4, 2, 8],
            col: 1
        }, {
            p: [301, 0, -270],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [321, 0, -364],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [270, -28, -113],
            s: [2, 70, 2],
            a: .58,
            t: 2
        }, {
            p: [314, -28, -113],
            s: [2, 70, 2],
            a: .58,
            t: 2
        }, {
            p: [292, 37, -109],
            s: [48, 2, 12],
            t: 2
        }, {
            p: [132, 0, -209],
            s: [4, 2, 8],
            col: 1,
            a: .86
        }, {
            p: [125, 0, -294],
            s: [4, 2, 8],
            col: 1,
            a: .86
        }, {
            p: [185, 0, -96],
            s: [4, 2, 4],
            col: 1,
            a: .62
        }, {
            p: [36, 0, -195],
            s: [4, 2, 8],
            col: 1,
            a: .86
        }, {
            p: [41, 0, -307],
            s: [4, 10, 38],
            a: .82
        }, {
            p: [77, 0, -231],
            s: [58, 8, 4],
            a: .82
        }, {
            p: [94, 0, -325],
            s: [22, 12, 4],
            a: .82
        }, {
            p: [107, 0, -314],
            s: [4, 12, 26],
            a: .82
        }, {
            p: [41, 10, -316],
            s: [4, 2, 10]
        }, {
            p: [86, 8, -231],
            s: [14, 2, 4]
        }, {
            p: [107, 12, -321],
            s: [4, 2, 12]
        }, {
            p: [99, 12, -325],
            s: [12, 4, 4]
        }, {
            p: [76, 0, -325],
            s: [14, 2, 4],
            a: .82
        }, {
            p: [101, -2, -239],
            s: [4, 56, 4],
            a: .73,
            t: 2
        }, {
            p: [9, 47, -171],
            s: [4, 4, 14],
            t: 2
        }, {
            p: [101, 47, -248],
            s: [4, 4, 14],
            t: 2
        }, {
            p: [101, 44, -244],
            s: [2, 2, 12],
            col: 1,
            r: [.7, 0, 0],
            t: 2
        }, {
            p: [48, 0, -326],
            s: [4, 2, 8],
            col: 1,
            a: .86
        }, {
            p: [92, 0, -237],
            s: [6, 2, 4],
            col: 1,
            a: .86
        }, {
            p: [79, 0, -316],
            s: [6, 2, 4],
            col: 1,
            a: .86
        }, {
            p: [75, 0, -225],
            s: [6, 2, 4],
            col: 1,
            a: .86
        }, {
            p: [49, 41, -351],
            s: [52, 0, 56],
            id: 4,
            col: 1,
            r: [1.57, 0, 0],
            t: 7
        }, {
            p: [11, 3, -253],
            s: [722, 0, 683],
            id: 4,
            col: 1,
            v: 1,
            pa: 1
        }, {
            p: [-125, 40, -114],
            s: [52, 0, 56],
            id: 4,
            col: 1,
            r: [1.57, 0, 0],
            t: 7
        }, {
            p: [-124, 61, -114],
            s: [22, 4, 4],
            t: 2
        }, {
            p: [-63, 50, -450],
            s: [52, 0, 56],
            id: 4,
            col: 1,
            r: [1.57, 0, 1.57],
            t: 7
        }]
    }], s = 0; s < a.length; ++s)
        for (var c = 0; c < a[s].objects.length; ++c)
            a[s].objects[c].id = r.prefabIDS[a[s].objects[c].id || 0],
            a[s].objects[c].t = r.textureIDS[a[s].objects[c].t || 0];
    t.exports.maps = a,
    t.exports.manager = function(t, e, r, s) {
        var c, h;
        this.manager = new (n(26).manager)(t,r,s),
        this.maps = a,
        this.modes = o,
        this.spawns = [],
        this.lastGen = null,
        this.setMaps = function(t) {
            this.maps = t || a
        }
        ,
        this.getRandomMap = function() {
            return r.randInt(0, this.maps.length - 1)
        }
        ,
        this.getRandomMode = function(t) {
            return this.maps[t].modes[r.randInt(0, this.maps[t].modes.length - 1)]
        }
        ,
        this.generate = function(n, o, a) {
            var l = this.maps[n];
            t && (mapInfo.innerHTML = o.alias + "_" + l.name,
            curGameInfo.innerHTML = o.name + "<div style='color:rgba(255,255,255,0.6)'>on " + l.name + "</div>");
            var u = n;
            if (a || this.lastGen !== u) {
                var p = null;
                this.lastGen = u,
                this.manager.removeAll(),
                e && e.reset(),
                t && t.init(l);
                for (var d = 0; d < l.objects.length; ++d) {
                    var f = (c = l.objects[d]).p[0]
                      , m = c.p[1]
                      , g = c.p[2];
                    if ("CUBE" == c.id) {
                        for (var v = 1, y = 0; y < l.objects.length; ++y)
                            if ("CUBE" == (h = l.objects[y]).id && c != h && m <= h.p[1] + h.s[1] && m >= h.p[1] && f + c.s[0] / 2 < h.p[0] + h.s[0] / 2 && f - c.s[0] / 2 > h.p[0] - h.s[0] / 2 && g + c.s[2] / 2 < h.p[2] + h.s[2] / 2 && g - c.s[2] / 2 > h.p[2] - h.s[2] / 2) {
                                v = 0;
                                break
                            }
                        this.manager.addBlock(f, m, g, c.s[0], c.s[2], c.s[1], [1, 1, 1, v, 1, 1], {
                            src: c.t.toLowerCase() + "_0",
                            darken: c.da,
                            amb: c.a,
                            yR: c.r ? c.r[0] : 0,
                            xR: c.r ? c.r[1] : 0,
                            zR: c.r ? c.r[2] : 0,
                            noCol: c.col,
                            noVis: c.v
                        })
                    } else
                        "PLANE" == c.id ? c.pa ? e && i(e, f, m, g, c.s[2], 30, c.s[0]) : c.ter ? p = c : this.manager.addPlane(f, m, g, c.s[2] / 2, c.s[0] / 2, {
                            src: c.t.toLowerCase() + "_0",
                            col: !c.col,
                            noVis: c.v
                        }, c.r ? c.r[2] : 0, (c.r ? c.r[0] : 0) - Math.PI / 2, c.r ? c.r[1] : 0) : "RAMP" == c.id ? this.manager.addRamp(f, m, g, c.s[0], c.s[1], c.s[2], c.d * Math.PI / 2, c.t ? c.t.toLowerCase() + "_0" : "grey_0") : "LADDER" == c.id ? this.manager.addLadder(f, m, g, c.s[1], c.d * Math.PI / 2) : this.manager.addMesh(f, m, g, c.r ? c.r[1] ? c.r[1] : Math.PI : 0, c.s[0] / 2, c.s[1] / 2, c.s[2] / 2, c.id.toLowerCase(), c.col)
                }
                if (t) {
                    var x, w = s.ambScale, b = [];
                    for (d = 0; d < this.manager.objects.length; ++d)
                        if (!(c = this.manager.objects[d]).noVis && !c.complexMesh)
                            for (y = 0; y < this.manager.objects.length; ++y)
                                if (!(h = this.manager.objects[y]).noVis && !h.complexMesh && this.manager.collision(c, h, 0)) {
                                    if (y > d) {
                                        if (x = r.boxIntersection(c, h, "x", "z", [Math.PI, 0, Math.PI / 2, -Math.PI / 2]))
                                            for (var M = 0; M < x.length; ++M)
                                                for (var _ = r.getIntersection(c, h, "y"), E = 0; E < 2; E++) {
                                                    var S = (x[M].d + Math.PI / 2 * E) % (2 * Math.PI);
                                                    w = this.manager.limitAmb(s.ambScale, x[M], S, "x", "z", c, h),
                                                    this.manager.addAmbient(x[M].x + w * Math.cos(S), _.y, x[M].z + w * Math.sin(S), -S + Math.PI, 0, 0, _.height, w, 1)
                                                }
                                        if (x = r.boxIntersection(c, h, "z", "y", [Math.PI, 0, -Math.PI / 2, Math.PI / 2]))
                                            for (M = 0; M < x.length; ++M)
                                                for (_ = r.getIntersection(c, h, "x"),
                                                E = 0; E < 2; E++)
                                                    S = x[M].d + Math.PI / 2 * (E ? 0 : 1),
                                                    w = this.manager.limitAmb(s.ambScale, x[M], -S + Math.PI / 2, "z", "y", c, h),
                                                    this.manager.addAmbient(_.x, x[M].y + w * Math.cos(S), x[M].z + w * Math.sin(S), 0, S, -Math.PI / 2, _.width, w, 1);
                                        if (x = r.boxIntersection(c, h, "x", "y", [Math.PI, 0, -Math.PI / 2, Math.PI / 2]))
                                            for (M = 0; M < x.length; ++M)
                                                for (_ = r.getIntersection(c, h, "z"),
                                                E = 0; E < 2; E++)
                                                    S = x[M].d + Math.PI / 2 * (E ? 0 : 1),
                                                    w = this.manager.limitAmb(s.ambScale, x[M], -S + Math.PI / 2, "x", "y", c, h),
                                                    this.manager.addAmbient(x[M].x + w * Math.sin(S), x[M].y + w * Math.cos(S), _.z, Math.PI / 2, S, -Math.PI / 2, _.length, w, 1)
                                    }
                                    var T = c.y + c.height > h.y + h.height
                                      , A = c.y - c.height < h.y - h.height;
                                    if ((T || A) && (x = r.boxCornerIntersection(c, h, "x", "z")))
                                        for (M = 0; M < x.length; ++M)
                                            for (w = Math.sqrt(2) * s.ambScale,
                                            S = x[M].d - Math.PI / 4,
                                            E = 0; E < 2; ++E)
                                                if ((E || T) && (!E || A)) {
                                                    var L = r.limitRect(x[M].x - w * Math.sin(S), x[M].z - w * Math.cos(S), s.ambScale, s.ambScale, x[M].d, h, "x", "z");
                                                    b.push(this.manager.addAmbient(L.x, h.y + (h.height + s.ambOff) * (E ? -1 : 1), L.z, x[M].d, Math.PI / 2, 0, L.width, L.length, 0, !0)),
                                                    b[b.length - 1].org = {
                                                        x: x[M].x,
                                                        y: b[b.length - 1].y,
                                                        z: x[M].z
                                                    }
                                                }
                                    var R = c.x + c.width > h.x + h.width
                                      , P = c.x - c.width < h.x - h.width;
                                    if (R || P) {
                                        var C = [Math.PI / 2, 0, Math.PI, -Math.PI / 2];
                                        if (x = r.boxCornerIntersection(c, h, "z", "y"))
                                            for (M = 0; M < x.length; ++M)
                                                for (w = Math.sqrt(2) * s.ambScale,
                                                S = x[M].d - Math.PI / 4,
                                                E = 0; E < 2; ++E)
                                                    !E && !R || E && !P || (L = r.limitRect(x[M].z - w * Math.sin(S), x[M].y - w * Math.cos(S), s.ambScale, s.ambScale, x[M].d, h, "z", "y"),
                                                    b.push(this.manager.addAmbient(h.x + (h.width + s.ambOff) * (E ? -1 : 1), L.y, L.z, Math.PI / 2, Math.PI, C[x[M].i], L.length, L.height, 0, !0)),
                                                    b[b.length - 1].org = {
                                                        x: b[b.length - 1].x,
                                                        y: x[M].y,
                                                        z: x[M].z
                                                    })
                                    }
                                    var I = c.z + c.length > h.z + h.length
                                      , O = c.z - c.length < h.z - h.length;
                                    if ((I || O) && (C = [-Math.PI / 2, Math.PI, 0, Math.PI / 2],
                                    x = r.boxCornerIntersection(c, h, "x", "y")))
                                        for (M = 0; M < x.length; ++M)
                                            for (w = Math.sqrt(2) * s.ambScale,
                                            S = x[M].d - Math.PI / 4,
                                            E = 0; E < 2; ++E)
                                                !E && !I || E && !O || (L = r.limitRect(x[M].x - w * Math.sin(S), x[M].y - w * Math.cos(S), s.ambScale, s.ambScale, x[M].d, h, "x", "y"),
                                                b.push(this.manager.addAmbient(L.x, L.y, h.z + (h.length + s.ambOff) * (E ? -1 : 1), 0, 0, C[x[M].i], L.width, L.height, 0, !0)),
                                                b[b.length - 1].org = {
                                                    x: x[M].x,
                                                    y: x[M].y,
                                                    z: b[b.length - 1].z
                                                })
                                }
                    for (d = 0; d < b.length; ++d) {
                        var D = !0;
                        for (c = b[d],
                        y = 0; y < b.length; ++y)
                            if (d != y && r.sharePos(c.org, b[y].org)) {
                                D = !1;
                                break
                            }
                        D && this.manager.addAmbient(c.x, c.y, c.z, c.xD, c.yD, c.zD, c.w, c.h, c.i)
                    }
                    b.length = 0
                }
                if (p) {
                    var U = p.s[2] / 2;
                    w = p.s[0] / 2,
                    this.manager.addPlane(0, 0, 0, U, w, {
                        yOff: -U,
                        col: !0,
                        scale: 1
                    }, 0, -Math.PI / 2),
                    this.manager.addPlane(0, -.1, 0, U, w, {
                        yOff: -U,
                        tilesX: Math.round(w / s.terrainGrid),
                        tilesZ: Math.round(U / s.terrainGrid),
                        noise: 4,
                        margin: 3,
                        objects: this.manager.objects,
                        scale: 1
                    }, 0, -Math.PI / 2)
                }
                for (this.spawns.length = 0,
                d = 0; d < l.spawns.length; ++d)
                    this.spawns.push({
                        x: l.spawns[d][0],
                        y: l.spawns[d][1],
                        z: l.spawns[d][2]
                    });
                t && t.addMeshGroups()
            }
        }
    }
}
, function(t, e, n) {
    var r = n(2);
    const i = n(1);
    n(13);
    var o, a = {};
    t.exports.getColor = function(t, e) {
        var n = t + "-" + (e || "")
          , i = a[n];
        return i || (i = new r.Color(t),
        e && i.multiplyScalar(e),
        a[n] = i),
        i
    }
    ,
    t.exports.colorize = function(e, n, r) {
        n = r || t.exports.getColor(n);
        for (var i = 0; i < e.faces.length; ++i)
            e.faces[i].vertexColors[0] = n,
            e.faces[i].vertexColors[1] = n,
            e.faces[i].vertexColors[2] = n
    }
    ;
    var s = function(t, e, n, i) {
        for (var o = new r.Vector2(e,n).multiplyScalar(i || 1), a = 0; a < t.faceVertexUvs.length; a++)
            for (var s = t.faceVertexUvs[a], c = 0; c < s.length; c++)
                for (var h = 0; h < 3; h++) {
                    var l = s[c][h].multiply(o);
                    l.x = .5 + l.x - o.x / 2
                }
    }
      , c = function(t, e, n, r, i, o) {
        return t >= n - i && t <= n + i && e >= r - o && e <= r + o
    }
      , h = []
      , l = ["a", "b", "c", "d"];
    t.exports.generatePlane = function(e, n, a) {
        e *= a.ratio || 1;
        var u = (a.scale ? e + "_" + n + "_" : "") + (a.scale || "") + (a.tilesX || "") + (a.tilesZ || "") + (a.color || "") + (a.darken || "");
        if (!(o = h[u])) {
            if (o = new r.PlaneGeometry(1,1,a.tilesX || 1,a.tilesZ || 1),
            a.noise) {
                for (var p = {}, d = a.margin || 0, f = 0; f < o.vertices.length; ++f) {
                    var m = o.vertices[f].x
                      , g = o.vertices[f].y;
                    if (!a.pinEdges || -.5 != m && .5 != m && -.5 != g && .5 != g)
                        if (a.objects) {
                            for (var v = 0; v < a.objects.length; ++v)
                                if (a.objects[v].y - a.objects[v].height <= .1 && 2 * a.objects[v].height > a.noise && c(-g * e * 2, m * n * 2, a.objects[v].z, a.objects[v].x, a.objects[v].length + d, a.objects[v].width + d)) {
                                    o.vertices[f].z = Math.random() * a.noise + 1,
                                    p[f] = t.exports.getColor(a.color, .65);
                                    break
                                }
                        } else
                            o.vertices[f].z = Math.random() * a.noise;
                    p[f] || (p[f] = t.exports.getColor(a.color))
                }
                for (f = 0; f < o.faces.length; f++) {
                    for (var y = o.faces[f], x = 0, w = 0; w < 3; w++)
                        y.vertexColors[w] = p[y[l[w]]],
                        o.vertices[y[l[w]]].z <= 0 && x++;
                    x >= 3 && delete o.faces[f]
                }
                o.faces = o.faces.filter(function(t) {
                    return t
                }),
                o.elementsNeedUpdate = !0
            } else
                a.color ? t.exports.colorize(o, a.color) : a.darken && t.exports.colorize(o, null, t.exports.getColor(16777215, a.darken));
            a.scale && s(o, n / i.worldUV, e / i.worldUV, a.scale),
            h[u] = o
        }
        return o
    }
    ;
    var u = [];
    t.exports.generateCube = function(e, n, a, c, h) {
        e = e || [1, 1, 1, 1, 1, 1];
        for (var l = (h.scale ? n + "_" + a + "_" + c + "_" : "") + (h.darken || "") + (h.scale || "") + (h.amb || "") + (h.useScale || ""), p = 0; p < e.length; ++p)
            l += "_" + e[p];
        if (!(o = u[l])) {
            h.darken = h.darken || 1;
            var d = t.exports.getColor(16777215, h.darken)
              , f = h.noAmb ? d : h.amb ? t.exports.getColor(16777215, (i.ambientVal + h.amb * (1 - i.ambientVal)) * h.darken) : t.exports.getColor(16777215, i.ambientVal * h.darken)
              , m = h.noAmb || !h.amb && e[3] ? d : f;
            o = new r.Geometry;
            var g, v = [];
            for (e[0] && ((g = new r.PlaneGeometry(1,1)).rotateY(Math.PI / 2),
            g.translate(.5, .5, 0),
            g.faces[0].vertexColors = [d, m, d],
            g.faces[1].vertexColors = [m, m, d],
            h.scale && s(g, c / i.worldUV, a / i.worldUV, h.scale),
            v.push(g)),
            e[1] && ((g = new r.PlaneGeometry(1,1)).rotateY(-Math.PI / 2),
            g.translate(-.5, .5, 0),
            g.faces[0].vertexColors = [d, m, d],
            g.faces[1].vertexColors = [m, m, d],
            h.scale && s(g, c / i.worldUV, a / i.worldUV, h.scale),
            v.push(g)),
            e[2] && ((g = new r.PlaneGeometry(1,1)).rotateX(-Math.PI / 2),
            g.translate(0, 1, 0),
            g.faces[0].vertexColors = [d, d, d],
            g.faces[1].vertexColors = [d, d, d],
            h.scale && s(g, n / i.worldUV, c / i.worldUV, h.scale),
            v.push(g)),
            e[3] && ((g = new r.PlaneGeometry(1,1)).rotateX(Math.PI / 2),
            g.translate(0, 0, 0),
            g.faces[0].vertexColors = [m, m, m],
            g.faces[1].vertexColors = [m, m, m],
            h.scale && s(g, n / i.worldUV, c / i.worldUV, h.scale),
            v.push(g)),
            e[4] && ((g = new r.PlaneGeometry(1,1)).translate(0, .5, .5),
            g.faces[0].vertexColors = [d, m, d],
            g.faces[1].vertexColors = [m, m, d],
            h.scale && s(g, n / i.worldUV, a / i.worldUV, h.scale),
            v.push(g)),
            e[5] && ((g = new r.PlaneGeometry(1,1)).rotateY(Math.PI),
            g.translate(0, .5, -.5),
            g.faces[0].vertexColors = [d, m, d],
            g.faces[1].vertexColors = [m, m, d],
            h.scale && s(g, n / i.worldUV, a / i.worldUV, h.scale),
            v.push(g)),
            p = 0; p < v.length; p++)
                o.merge(v[p], new r.Matrix4);
            h && h.useScale && (o.scale(n, a, c),
            o.translate(0, -a / 2, 0)),
            u[l] = o
        }
        return o
    }
}
, function(t, e) {
    t.exports.keyboardMap = "   CANCEL   HELP  BACK_SPACE TAB   CLEAR ENTER ENTER_SPECIAL  SHIFT CONTROL ALT PAUSE CAPS_LOCK KANA EISU JUNJA FINAL HANJA  ESCAPE CONVERT NONCONVERT ACCEPT MODECHANGE SPACE PAGE_UP PAGE_DOWN END HOME LEFT UP RIGHT DOWN SELECT PRINT EXECUTE PRINTSCREEN INSERT DELETE  0 1 2 3 4 5 6 7 8 9 COLON SEMICOLON LESS_THAN EQUALS GREATER_THAN QUESTION_MARK AT A B C D E F G H I J K L M N O P Q R S T U V W X Y Z OS_KEY  CONTEXT_MENU  SLEEP NUMPAD0 NUMPAD1 NUMPAD2 NUMPAD3 NUMPAD4 NUMPAD5 NUMPAD6 NUMPAD7 NUMPAD8 NUMPAD9 MULTIPLY ADD SEPARATOR SUBTRACT DECIMAL DIVIDE F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24         NUM_LOCK SCROLL_LOCK WIN_OEM_FJ_JISHO WIN_OEM_FJ_MASSHOU WIN_OEM_FJ_TOUROKU WIN_OEM_FJ_LOYA WIN_OEM_FJ_ROYA          CIRCUMFLEX EXCLAMATION DOUBLE_QUOTE HASH DOLLAR PERCENT AMPERSAND UNDERSCORE OPEN_PAREN CLOSE_PAREN ASTERISK PLUS PIPE HYPHEN_MINUS OPEN_CURLY_BRACKET CLOSE_CURLY_BRACKET TILDE     VOLUME_MUTE VOLUME_DOWN VOLUME_UP   SEMICOLON EQUALS COMMA MINUS PERIOD SLASH BACK_QUOTE                           OPEN_BRACKET BACK_SLASH CLOSE_BRACKET QUOTE  META ALTGR  WIN_ICO_HELP WIN_ICO_00  WIN_ICO_CLEAR   WIN_OEM_RESET WIN_OEM_JUMP WIN_OEM_PA1 WIN_OEM_PA2 WIN_OEM_PA3 WIN_OEM_WSCTRL WIN_OEM_CUSEL WIN_OEM_ATTN WIN_OEM_FINISH WIN_OEM_COPY WIN_OEM_AUTO WIN_OEM_ENLW WIN_OEM_BACKTAB ATTN CRSEL EXSEL EREOF PLAY ZOOM  PA1 WIN_OEM_CLEAR ".split(" "),
    Number.prototype.round = function(t) {
        return +this.toFixed(t)
    }
    ,
    Number.prototype.roundToNearest = function(t) {
        return this > 0 ? Math.ceil(this / t) * t : this < 0 ? Math.floor(this / t) * t : this
    }
    ,
    t.exports.formatNum = function(t) {
        var e = Math.floor(Math.log(Math.abs(t)) / Math.log(1e3))
          , n = "kmb"[e - 1];
        return n ? (t / Math.pow(1e3, e)).toFixed(1) + n : "" + t
    }
    ,
    t.exports.randInt = function(t, e) {
        return Math.floor(Math.random() * (e - t + 1)) + t
    }
    ,
    t.exports.randFloat = function(t, e) {
        return Math.random() * (e - t) + t
    }
    ,
    t.exports.getRandom = function(e) {
        return e[t.exports.randInt(0, e.length - 1)]
    }
    ,
    t.exports.getDistance = function(t, e, n, r) {
        return Math.sqrt((n -= t) * n + (r -= e) * r)
    }
    ,
    t.exports.getDistance3D = function(t, e, n, r, i, o) {
        var a = t - r
          , s = e - i
          , c = n - o;
        return Math.sqrt(a * a + s * s + c * c)
    }
    ,
    t.exports.getAnglesSSS = function(t, e, n) {
        var r = Math.acos((e * e + n * n - t * t) / (2 * e * n))
          , i = Math.acos((n * n + t * t - e * e) / (2 * n * t))
          , o = Math.PI - r - i;
        return [-r - Math.PI / 2, i, o]
    }
    ,
    t.exports.getXDir = function(e, n, r, i, o, a) {
        var s = Math.abs(n - o)
          , c = t.exports.getDistance3D(e, n, r, i, o, a);
        return Math.asin(s / c) * (n > o ? -1 : 1)
    }
    ,
    t.exports.getAngleDist = function(t, e) {
        return Math.atan2(Math.sin(e - t), Math.cos(t - e))
    }
    ,
    t.exports.toRad = function(t) {
        return t * (Math.PI / 180)
    }
    ,
    t.exports.getDirection = function(t, e, n, r) {
        return Math.atan2(e - r, t - n)
    }
    ,
    t.exports.lerp = function(t, e, n) {
        return t + (e - t) * n
    }
    ,
    t.exports.orderByScore = function(t, e) {
        return e.score - t.score
    }
    ,
    t.exports.orderByDst = function(t, e) {
        return t.dst - e.dst
    }
    ,
    t.exports.capFirst = function(t) {
        return t.charAt(0).toUpperCase() + t.slice(1)
    }
    ,
    t.exports.truncateText = function(t, e) {
        return t.length > e ? t.substring(0, e) + "..." : t
    }
    ,
    t.exports.randomString = function(t) {
        for (var e = "", n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", r = 0; r < t; r++)
            e += n.charAt(Math.floor(Math.random() * n.length));
        return e
    }
    ,
    t.exports.formatNumCash = function(t) {
        return parseFloat(Math.round(100 * t) / 100).toFixed(2)
    }
    ,
    t.exports.getKeyName = function(e) {
        return t.exports.keyboardMap[e]
    }
    ,
    t.exports.getTime = function(t) {
        var e = Math.floor(t / 6e4)
          , n = (t % 6e4 / 1e3).toFixed(0);
        return e + ":" + (n < 10 ? "0" : "") + n
    }
    ,
    t.exports.getReadableTime = function(t) {
        var e = t / 1e3 / 60
          , n = parseInt(e % 60);
        e /= 60;
        var r = parseInt(e % 24);
        e /= 24;
        var i = parseInt(e);
        return (i ? i + "d " : "") + (r ? r + "h " : "") + (n || 0) + "m "
    }
    ,
    t.exports.fixTo = function(t, e) {
        return parseFloat(t.toFixed(e))
    }
    ,
    t.exports.limit = function(t, e) {
        return t < -e ? -e : t > e ? e : t
    }
    ,
    t.exports.limitMM = function(t, e, n) {
        return t < e ? e : t > n ? n : t
    }
    ,
    t.exports.cropVal = function(t, e) {
        return t <= e && t >= -e ? 0 : t
    }
    ,
    t.exports.isNumber = function(t) {
        return null !== t && void 0 !== t && "number" == typeof t && !isNaN(t) && isFinite(t)
    }
    ,
    t.exports.arrayInts = function(e) {
        for (var n = 0; n < e.length; ++n)
            if (!t.exports.isNumber(e[n]))
                return !1;
        return !0
    }
    ,
    t.exports.isArray = function(t) {
        return !!t && t.constructor === Array
    }
    ,
    t.exports.isString = function(t) {
        return t && "string" == typeof t
    }
    ,
    t.exports.lineInRect = function(t, e, n, r, i, o, a, s, c, h, l, u) {
        var p = (a - t) * r
          , d = (h - t) * r
          , f = (c - n) * o
          , m = (u - n) * o
          , g = (s - e) * i
          , v = (l - e) * i
          , y = Math.max(Math.max(Math.min(p, d), Math.min(f, m)), Math.min(g, v))
          , x = Math.min(Math.min(Math.max(p, d), Math.max(f, m)), Math.max(g, v));
        return !(x < 0) && !(y > x) && y
    }
    ,
    t.exports.pointInBox = function(t, e, n, r, i, o, a) {
        return a ? t >= n && t <= i && e >= r && e <= o : t > n && t < i && e > r && e < o
    }
    ,
    t.exports.sharePos = function(t, e, n) {
        return n = n || 0,
        Math.abs(t.x - e.x) <= n && Math.abs(t.y - e.y) <= n && Math.abs(t.z - e.z) <= n
    }
    ,
    t.exports.cdv = {
        x: "width",
        y: "height",
        z: "length"
    },
    t.exports.boxIntersection = function(e, n, r, i, o) {
        var a = t.exports.cdv[r]
          , s = t.exports.cdv[i]
          , c = e[r] - e[a] - .1
          , h = n[r] - n[a] - .1
          , l = e[r] + e[a] + .1
          , u = n[r] + n[a] + .1
          , p = e[i] - e[s] - .1
          , d = n[i] - n[s] - .1
          , f = e[i] + e[s] + .1
          , m = n[i] + n[s] + .1
          , g = Math.max(c, h)
          , v = Math.min(l, u);
        if (v >= g) {
            var y = Math.max(p, d)
              , x = Math.min(f, m);
            if (x >= y) {
                for (var w = [{
                    [r]: g,
                    [i]: y,
                    d: o[0]
                }, {
                    [r]: v,
                    [i]: x,
                    d: o[1]
                }, {
                    [r]: g,
                    [i]: x,
                    d: o[2]
                }, {
                    [r]: v,
                    [i]: y,
                    d: o[3]
                }], b = w.length - 1; b >= 0; --b)
                    (w[b][r] == l && w[b][r] == u || w[b][r] == c && w[b][r] == h || w[b][i] == f && w[b][i] == m || w[b][i] == p && w[b][i] == d || t.exports.pointInBox(w[b][r], w[b][i], c, p, l, f) || t.exports.pointInBox(w[b][r], w[b][i], h, d, u, m)) && w.splice(b, 1);
                return w.length ? w : null
            }
        }
        return null
    }
    ,
    t.exports.boxCornerIntersection = function(e, n, r, i) {
        for (var o = t.exports.cdv[r], a = t.exports.cdv[i], s = e[r] - e[o], c = n[r] - n[o], h = e[r] + e[o], l = n[r] + n[o], u = e[i] - e[a], p = n[i] - n[a], d = e[i] + e[a], f = n[i] + n[a], m = [{
            [r]: s,
            [i]: u,
            d: Math.PI / 2
        }, {
            [r]: s,
            [i]: d,
            d: Math.PI
        }, {
            [r]: h,
            [i]: u,
            d: 0
        }, {
            [r]: h,
            [i]: d,
            d: -Math.PI / 2
        }], g = m.length - 1; g >= 0; --g)
            m[g].i = g,
            t.exports.pointInBox(m[g][r], m[g][i], c, p, l, f, !0) || m.splice(g, 1);
        return m.length ? m : null
    }
    ,
    t.exports.getIntersection = function(e, n, r) {
        var i = t.exports.cdv[r]
          , o = e[r] - e[i]
          , a = n[r] - n[i]
          , s = e[r] + e[i]
          , c = n[r] + n[i]
          , h = Math.max(o, a)
          , l = Math.min(s, c);
        if (l >= h) {
            var u = (l - h) / 2;
            return {
                [r]: h + u,
                [i]: u
            }
        }
        return null
    }
    ,
    t.exports.limitRectVal = function(e, n, r) {
        var i = t.exports.cdv[r];
        if (e[r] - e[i] < n[r] - n[i]) {
            var o = (n[r] - n[i] - (e[r] - e[i])) / 2;
            e[i] -= o,
            e[r] += o
        }
        e[r] + e[i] > n[r] + n[i] && (o = (e[r] + e[i] - (n[r] + n[i])) / 2,
        e[i] -= o,
        e[r] -= o)
    }
    ,
    t.exports.limitRect = function(e, n, r, i, o, a, s, c) {
        var h = t.exports.cdv[s]
          , l = t.exports.cdv[c]
          , u = {};
        if (u[s] = e,
        u[c] = n,
        u[h] = r,
        u[l] = i,
        t.exports.limitRectVal(u, a, s),
        t.exports.limitRectVal(u, a, c),
        0 == o || o == Math.PI) {
            var p = u[h];
            u[h] = u[l],
            u[l] = p
        }
        return u
    }
    ,
    t.exports.progressOnLine = function(t, e, n, r, i, o) {
        var a = n - t
          , s = r - e
          , c = Math.sqrt(a * a + s * s);
        return ((a /= c) * (i - t) + (s /= c) * (o - e)) / Math.sqrt(Math.pow(n - t, 2) + Math.pow(r - e, 2))
    }
    ,
    t.exports.generateSID = function(t) {
        for (var e = 0, n = !0; n; ) {
            n = !1,
            e++;
            for (var r = 0; r < t.length; ++r)
                if (t[r].sid == e) {
                    n = !0;
                    break
                }
        }
        return e
    }
    ;
    var n = function(t, e) {
        return t.concat(e)
    };
    Array.prototype.flatMap = function(t) {
        return function(t, e) {
            return e.map(t).reduce(n, [])
        }(t, this)
    }
}
, function(t, e, n) {
    let r = n(2);
    const i = n(1)
      , o = n(12);
    let a = new r.TextureLoader;
    function s(t, e, n, i) {
        return new Promise(o=>{
            (new r.OBJLoader).load(e, e=>{
                let s;
                n && (s = a.load(n, t=>{
                    t.wrapS = r.RepeatWrapping,
                    t.wrapT = r.RepeatWrapping,
                    t.repeat.set(1, 1),
                    t.minFilter = r.NearestFilter,
                    t.magFilter = r.NearestFilter,
                    t.needsUpdate = !0
                }
                ));
                let c = new r.MeshLambertMaterial({
                    map: s
                })
                  , h = new r.Geometry;
                e.traverse(t=>{
                    t instanceof r.Mesh && (t.geometry.isBufferGeometry ? (h.fromBufferGeometry(t.geometry),
                    h.computeFlatVertexNormals(),
                    t.geometry.fromGeometry(h)) : t.geometry.computeFlatVertexNormals(),
                    t.material = c)
                }
                ),
                e.scale.setScalar(i || 1),
                t.add(e),
                o()
            }
            )
        }
        )
    }
    function c(t, e, n) {
        let i = (new r.TextureLoader).load(e);
        i.magFilter = r.NearestFilter;
        let o = new r.SpriteMaterial({
            map: i,
            color: 16777215
        })
          , a = new r.Sprite(o);
        n && a.scale.set(n, n, 1),
        t.add(a)
    }
    function h(t, e, n, i) {
        var a = o.generateCube([1, 1, 1, 1, 1, 1], t, e, n, {
            scale: 1,
            amb: i,
            useScale: !0
        });
        return (new r.BufferGeometry).fromGeometry(a)
    }
    new r.BoxBufferGeometry(1,1,1),
    new r.PlaneBufferGeometry(1,1).rotateX(-Math.PI / 2),
    new r.MeshLambertMaterial({
        color: 65280
    }),
    new r.MeshLambertMaterial({
        color: 5592405
    }),
    t.exports.prefabs = {
        CRATE: {
            dontRound: !0,
            gen: t=>s(t, "models/crate_0.obj", "textures/crate_0.png", i.crateScale),
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0
        },
        STACK: {
            dontRound: !0,
            gen: t=>s(t, "models/stack_0.obj", "textures/stack_0.png", i.crateScale),
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0
        },
        BARREL: {
            dontRound: !0,
            complex: !0,
            gen: t=>s(t, "models/barrel_0.obj", "textures/barrel_0.png", i.barrelScale),
            castShadow: !0,
            receiveShadow: !0
        },
        VEHICLE: {
            dontRound: !0,
            complex: !0,
            gen: t=>s(t, "models/vehicle_0.obj", "textures/vehicle_0.png", i.vehicleScale),
            castShadow: !0,
            receiveShadow: !0
        },
        LADDER: {
            defaultSize: [2, 10, 4],
            scalable: !0,
            scaleWithSize: !1,
            hideBoundingBox: !1,
            texturable: !1,
            genGeo: async t=>h(...t),
            customDirection: !0,
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0
        },
        CUBE: {
            defaultSize: [10, 10, 10],
            scalable: !0,
            editAmb: !0,
            scaleWithSize: !1,
            editDarkness: !0,
            hideBoundingBox: !1,
            texturable: !0,
            genGeo: async(t,e)=>h(...t, e),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0
        },
        RAMP: {
            defaultSize: [10, 5, 10],
            scalable: !0,
            scaleWithSize: !1,
            hideBoundingBox: !1,
            texturable: !0,
            genGeo: async t=>h(...t),
            shootable: !0,
            customDirection: !0,
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0
        },
        PLANE: {
            defaultSize: [4, .01, 4],
            dontRound: !0,
            particles: !0,
            scalable: !0,
            canTerrain: !0,
            scaleWithSize: !0,
            editDarkness: !0,
            hideBoundingBox: !1,
            texturable: !0,
            genGeo: async t=>(function(t, e) {
                let n = new r.PlaneGeometry(t,e);
                return n.rotateX(-Math.PI / 2),
                n
            }
            )(t[0], t[2]),
            stepSrc: "a",
            dummy: !1,
            castShadow: !0,
            receiveShadow: !0
        },
        SPAWN_POINT: {
            defaultSize: [8, 8, 8],
            scalable: !1,
            scaleWithSize: !1,
            hideBoundingBox: !0,
            editorGen: t=>c(t, "img/favicon.png", 8),
            stepSrc: "a",
            assignTeam: !0,
            dummy: !1,
            castShadow: !1,
            receiveShadow: !1
        },
        CAMERA_POSITION: {
            defaultSize: [2, 2, 2],
            scalable: !1,
            scaleWithSize: !1,
            hideBoundingBox: !0,
            editorGen: t=>c(t, "img/crosshair.png", 5),
            stepSrc: "a",
            dummy: !1,
            castShadow: !1,
            receiveShadow: !1
        }
    },
    t.exports.texturePrefabs = {
        WALL: {
            src: "wall_0",
            filter: r.NearestFilter
        },
        DIRT: {
            src: "dirt_0",
            filter: r.NearestFilter
        },
        FLOOR: {
            src: "floor_0",
            filter: r.NearestFilter
        },
        ORANGE: {
            src: "orange_0",
            filter: r.NearestFilter
        },
        GREY: {
            src: "grey_0",
            filter: r.NearestFilter
        },
        WATER: {
            src: "water_0",
            filter: r.NearestFilter
        },
        ROOF: {
            src: "roof_0",
            filter: r.NearestFilter
        },
        FLAG: {
            src: "flag_0",
            filter: r.NearestFilter
        }
    },
    t.exports.loadTexturePrefab = function(e) {
        let n = t.exports.texturePrefabs[e];
        return a.load("/textures/" + n.src + ".png", t=>{
            t.wrapS = r.RepeatWrapping,
            t.wrapT = r.RepeatWrapping,
            t.minFilter = n.filter,
            t.magFilter = n.filter,
            t.needsUpdate = !0
        }
        )
    }
}
, function(t, e, n) {
    !function(e) {
        t.exports = e;
        var n = "listeners"
          , r = {
            on: function(t, e) {
                return a(this, t).push(e),
                this
            },
            once: function(t, e) {
                var n = this;
                return r.originalListener = e,
                a(n, t).push(r),
                n;
                function r() {
                    o.call(n, t, r),
                    e.apply(this, arguments)
                }
            },
            off: o,
            emit: function(t, e) {
                var n = this
                  , r = a(n, t, !0);
                if (!r)
                    return !1;
                var i = arguments.length;
                if (1 === i)
                    r.forEach(function(t) {
                        t.call(n)
                    });
                else if (2 === i)
                    r.forEach(function(t) {
                        t.call(n, e)
                    });
                else {
                    var o = Array.prototype.slice.call(arguments, 1);
                    r.forEach(function(t) {
                        t.apply(n, o)
                    })
                }
                return !!r.length
            }
        };
        function i(t) {
            for (var e in r)
                t[e] = r[e];
            return t
        }
        function o(t, e) {
            var r;
            if (arguments.length) {
                if (e) {
                    if (r = a(this, t, !0)) {
                        if (!(r = r.filter(function(t) {
                            return t !== e && t.originalListener !== e
                        })).length)
                            return o.call(this, t);
                        this[n][t] = r
                    }
                } else if ((r = this[n]) && (delete r[t],
                !Object.keys(r).length))
                    return o.call(this)
            } else
                delete this[n];
            return this
        }
        function a(t, e, r) {
            if (!r || t[n]) {
                var i = t[n] || (t[n] = {});
                return i[e] || (i[e] = [])
            }
        }
        i(e.prototype),
        e.mixin = i
    }(/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */
    function t() {
        if (!(this instanceof t))
            return new t
    })
}
, function(t, e, n) {
    var r = n(8)
      , i = n(6)
      , o = i.Uint64BE
      , a = i.Int64BE;
    e.getReadFormat = function(t) {
        var e = s.hasArrayBuffer && t && t.binarraybuffer
          , n = t && t.int64;
        return {
            map: h && t && t.usemap ? p : u,
            array: d,
            str: f,
            bin: e ? g : m,
            ext: v,
            uint8: y,
            uint16: w,
            uint32: M,
            uint64: E(8, n ? A : S),
            int8: x,
            int16: b,
            int32: _,
            int64: E(8, n ? L : T),
            float32: E(4, R),
            float64: E(8, P)
        }
    }
    ,
    e.readUint8 = y;
    var s = n(0)
      , c = n(7)
      , h = "undefined" != typeof Map
      , l = !0;
    function u(t, e) {
        var n, r = {}, i = new Array(e), o = new Array(e), a = t.codec.decode;
        for (n = 0; n < e; n++)
            i[n] = a(t),
            o[n] = a(t);
        for (n = 0; n < e; n++)
            r[i[n]] = o[n];
        return r
    }
    function p(t, e) {
        var n, r = new Map, i = new Array(e), o = new Array(e), a = t.codec.decode;
        for (n = 0; n < e; n++)
            i[n] = a(t),
            o[n] = a(t);
        for (n = 0; n < e; n++)
            r.set(i[n], o[n]);
        return r
    }
    function d(t, e) {
        for (var n = new Array(e), r = t.codec.decode, i = 0; i < e; i++)
            n[i] = r(t);
        return n
    }
    function f(t, e) {
        var n = t.reserve(e)
          , r = n + e;
        return c.toString.call(t.buffer, "utf-8", n, r)
    }
    function m(t, e) {
        var n = t.reserve(e)
          , r = n + e
          , i = c.slice.call(t.buffer, n, r);
        return s.from(i)
    }
    function g(t, e) {
        var n = t.reserve(e)
          , r = n + e
          , i = c.slice.call(t.buffer, n, r);
        return s.Uint8Array.from(i).buffer
    }
    function v(t, e) {
        var n = t.reserve(e + 1)
          , r = t.buffer[n++]
          , i = n + e
          , o = t.codec.getExtUnpacker(r);
        if (!o)
            throw new Error("Invalid ext type: " + (r ? "0x" + r.toString(16) : r));
        return o(c.slice.call(t.buffer, n, i))
    }
    function y(t) {
        var e = t.reserve(1);
        return t.buffer[e]
    }
    function x(t) {
        var e = t.reserve(1)
          , n = t.buffer[e];
        return 128 & n ? n - 256 : n
    }
    function w(t) {
        var e = t.reserve(2)
          , n = t.buffer;
        return n[e++] << 8 | n[e]
    }
    function b(t) {
        var e = t.reserve(2)
          , n = t.buffer
          , r = n[e++] << 8 | n[e];
        return 32768 & r ? r - 65536 : r
    }
    function M(t) {
        var e = t.reserve(4)
          , n = t.buffer;
        return 16777216 * n[e++] + (n[e++] << 16) + (n[e++] << 8) + n[e]
    }
    function _(t) {
        var e = t.reserve(4)
          , n = t.buffer;
        return n[e++] << 24 | n[e++] << 16 | n[e++] << 8 | n[e]
    }
    function E(t, e) {
        return function(n) {
            var r = n.reserve(t);
            return e.call(n.buffer, r, l)
        }
    }
    function S(t) {
        return new o(this,t).toNumber()
    }
    function T(t) {
        return new a(this,t).toNumber()
    }
    function A(t) {
        return new o(this,t)
    }
    function L(t) {
        return new a(this,t)
    }
    function R(t) {
        return r.read(this, t, !1, 23, 4)
    }
    function P(t) {
        return r.read(this, t, !1, 52, 8)
    }
}
, function(t, e, n) {
    e.DecodeBuffer = i;
    var r = n(5).preset;
    function i(t) {
        if (!(this instanceof i))
            return new i(t);
        if (t && (this.options = t,
        t.codec)) {
            var e = this.codec = t.codec;
            e.bufferish && (this.bufferish = e.bufferish)
        }
    }
    n(19).FlexDecoder.mixin(i.prototype),
    i.prototype.codec = r,
    i.prototype.fetch = function() {
        return this.codec.decode(this)
    }
}
, function(t, e, n) {
    e.decode = function(t, e) {
        var n = new r(e);
        return n.write(t),
        n.read()
    }
    ;
    var r = n(17).DecodeBuffer
}
, function(t, e, n) {
    e.FlexDecoder = o,
    e.FlexEncoder = a;
    var r = n(0)
      , i = "BUFFER_SHORTAGE";
    function o() {
        if (!(this instanceof o))
            return new o
    }
    function a() {
        if (!(this instanceof a))
            return new a
    }
    function s() {
        throw new Error("method not implemented: write()")
    }
    function c() {
        throw new Error("method not implemented: fetch()")
    }
    function h() {
        return this.buffers && this.buffers.length ? (this.flush(),
        this.pull()) : this.fetch()
    }
    function l(t) {
        (this.buffers || (this.buffers = [])).push(t)
    }
    function u() {
        return (this.buffers || (this.buffers = [])).shift()
    }
    function p(t) {
        return function(e) {
            for (var n in t)
                e[n] = t[n];
            return e
        }
    }
    o.mixin = p({
        bufferish: r,
        write: function(t) {
            var e = this.offset ? r.prototype.slice.call(this.buffer, this.offset) : this.buffer;
            this.buffer = e ? t ? this.bufferish.concat([e, t]) : e : t,
            this.offset = 0
        },
        fetch: c,
        flush: function() {
            for (; this.offset < this.buffer.length; ) {
                var t, e = this.offset;
                try {
                    t = this.fetch()
                } catch (t) {
                    if (t && t.message != i)
                        throw t;
                    this.offset = e;
                    break
                }
                this.push(t)
            }
        },
        push: l,
        pull: u,
        read: h,
        reserve: function(t) {
            var e = this.offset
              , n = e + t;
            if (n > this.buffer.length)
                throw new Error(i);
            return this.offset = n,
            e
        },
        offset: 0
    }),
    o.mixin(o.prototype),
    a.mixin = p({
        bufferish: r,
        write: s,
        fetch: function() {
            var t = this.start;
            if (t < this.offset) {
                var e = this.start = this.offset;
                return r.prototype.slice.call(this.buffer, t, e)
            }
        },
        flush: function() {
            for (; this.start < this.offset; ) {
                var t = this.fetch();
                t && this.push(t)
            }
        },
        push: l,
        pull: function() {
            var t = this.buffers || (this.buffers = [])
              , e = t.length > 1 ? this.bufferish.concat(t) : t[0];
            return t.length = 0,
            e
        },
        read: h,
        reserve: function(t) {
            var e = 0 | t;
            if (this.buffer) {
                var n = this.buffer.length
                  , r = 0 | this.offset
                  , i = r + e;
                if (i < n)
                    return this.offset = i,
                    r;
                this.flush(),
                t = Math.max(t, Math.min(2 * n, this.maxBufferSize))
            }
            return t = Math.max(t, this.minBufferSize),
            this.buffer = this.bufferish.alloc(t),
            this.start = 0,
            this.offset = e,
            0
        },
        send: function(t) {
            var e = t.length;
            if (e > this.minBufferSize)
                this.flush(),
                this.push(t);
            else {
                var n = this.reserve(e);
                r.prototype.copy.call(t, this.buffer, n)
            }
        },
        maxBufferSize: 65536,
        minBufferSize: 2048,
        offset: 0,
        start: 0
    }),
    a.mixin(a.prototype)
}
, function(t, e) {
    for (var n = e.uint8 = new Array(256), r = 0; r <= 255; r++)
        n[r] = i(r);
    function i(t) {
        return function(e) {
            var n = e.reserve(1);
            e.buffer[n] = t
        }
    }
}
, function(t, e, n) {
    "use strict";
    (function(t) {
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
        var r = n(40)
          , i = n(8)
          , o = n(4);
        function a() {
            return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }
        function s(t, e) {
            if (a() < e)
                throw new RangeError("Invalid typed array length");
            return c.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = c.prototype : (null === t && (t = new c(e)),
            t.length = e),
            t
        }
        function c(t, e, n) {
            if (!(c.TYPED_ARRAY_SUPPORT || this instanceof c))
                return new c(t,e,n);
            if ("number" == typeof t) {
                if ("string" == typeof e)
                    throw new Error("If encoding is specified then the first argument must be a string");
                return u(this, t)
            }
            return h(this, t, e, n)
        }
        function h(t, e, n, r) {
            if ("number" == typeof e)
                throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function(t, e, n, r) {
                if (e.byteLength,
                n < 0 || e.byteLength < n)
                    throw new RangeError("'offset' is out of bounds");
                if (e.byteLength < n + (r || 0))
                    throw new RangeError("'length' is out of bounds");
                return e = void 0 === n && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e,n) : new Uint8Array(e,n,r),
                c.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = c.prototype : t = p(t, e),
                t
            }(t, e, n, r) : "string" == typeof e ? function(t, e, n) {
                if ("string" == typeof n && "" !== n || (n = "utf8"),
                !c.isEncoding(n))
                    throw new TypeError('"encoding" must be a valid string encoding');
                var r = 0 | f(e, n)
                  , i = (t = s(t, r)).write(e, n);
                return i !== r && (t = t.slice(0, i)),
                t
            }(t, e, n) : function(t, e) {
                if (c.isBuffer(e)) {
                    var n = 0 | d(e.length);
                    return 0 === (t = s(t, n)).length ? t : (e.copy(t, 0, 0, n),
                    t)
                }
                if (e) {
                    if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length"in e)
                        return "number" != typeof e.length || function(t) {
                            return t != t
                        }(e.length) ? s(t, 0) : p(t, e);
                    if ("Buffer" === e.type && o(e.data))
                        return p(t, e.data)
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
            }(t, e)
        }
        function l(t) {
            if ("number" != typeof t)
                throw new TypeError('"size" argument must be a number');
            if (t < 0)
                throw new RangeError('"size" argument must not be negative')
        }
        function u(t, e) {
            if (l(e),
            t = s(t, e < 0 ? 0 : 0 | d(e)),
            !c.TYPED_ARRAY_SUPPORT)
                for (var n = 0; n < e; ++n)
                    t[n] = 0;
            return t
        }
        function p(t, e) {
            var n = e.length < 0 ? 0 : 0 | d(e.length);
            t = s(t, n);
            for (var r = 0; r < n; r += 1)
                t[r] = 255 & e[r];
            return t
        }
        function d(t) {
            if (t >= a())
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a().toString(16) + " bytes");
            return 0 | t
        }
        function f(t, e) {
            if (c.isBuffer(t))
                return t.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer))
                return t.byteLength;
            "string" != typeof t && (t = "" + t);
            var n = t.length;
            if (0 === n)
                return 0;
            for (var r = !1; ; )
                switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                    return n;
                case "utf8":
                case "utf-8":
                case void 0:
                    return k(t).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return 2 * n;
                case "hex":
                    return n >>> 1;
                case "base64":
                    return H(t).length;
                default:
                    if (r)
                        return k(t).length;
                    e = ("" + e).toLowerCase(),
                    r = !0
                }
        }
        function m(t, e, n) {
            var r = t[e];
            t[e] = t[n],
            t[n] = r
        }
        function g(t, e, n, r, i) {
            if (0 === t.length)
                return -1;
            if ("string" == typeof n ? (r = n,
            n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648),
            n = +n,
            isNaN(n) && (n = i ? 0 : t.length - 1),
            n < 0 && (n = t.length + n),
            n >= t.length) {
                if (i)
                    return -1;
                n = t.length - 1
            } else if (n < 0) {
                if (!i)
                    return -1;
                n = 0
            }
            if ("string" == typeof e && (e = c.from(e, r)),
            c.isBuffer(e))
                return 0 === e.length ? -1 : v(t, e, n, r, i);
            if ("number" == typeof e)
                return e &= 255,
                c.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : v(t, [e], n, r, i);
            throw new TypeError("val must be string, number or Buffer")
        }
        function v(t, e, n, r, i) {
            var o, a = 1, s = t.length, c = e.length;
            if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                if (t.length < 2 || e.length < 2)
                    return -1;
                a = 2,
                s /= 2,
                c /= 2,
                n /= 2
            }
            function h(t, e) {
                return 1 === a ? t[e] : t.readUInt16BE(e * a)
            }
            if (i) {
                var l = -1;
                for (o = n; o < s; o++)
                    if (h(t, o) === h(e, -1 === l ? 0 : o - l)) {
                        if (-1 === l && (l = o),
                        o - l + 1 === c)
                            return l * a
                    } else
                        -1 !== l && (o -= o - l),
                        l = -1
            } else
                for (n + c > s && (n = s - c),
                o = n; o >= 0; o--) {
                    for (var u = !0, p = 0; p < c; p++)
                        if (h(t, o + p) !== h(e, p)) {
                            u = !1;
                            break
                        }
                    if (u)
                        return o
                }
            return -1
        }
        function y(t, e, n, r) {
            n = Number(n) || 0;
            var i = t.length - n;
            r ? (r = Number(r)) > i && (r = i) : r = i;
            var o = e.length;
            if (o % 2 != 0)
                throw new TypeError("Invalid hex string");
            r > o / 2 && (r = o / 2);
            for (var a = 0; a < r; ++a) {
                var s = parseInt(e.substr(2 * a, 2), 16);
                if (isNaN(s))
                    return a;
                t[n + a] = s
            }
            return a
        }
        function x(t, e, n, r) {
            return G(k(e, t.length - n), t, n, r)
        }
        function w(t, e, n, r) {
            return G(function(t) {
                for (var e = [], n = 0; n < t.length; ++n)
                    e.push(255 & t.charCodeAt(n));
                return e
            }(e), t, n, r)
        }
        function b(t, e, n, r) {
            return w(t, e, n, r)
        }
        function M(t, e, n, r) {
            return G(H(e), t, n, r)
        }
        function _(t, e, n, r) {
            return G(function(t, e) {
                for (var n, r, i, o = [], a = 0; a < t.length && !((e -= 2) < 0); ++a)
                    r = (n = t.charCodeAt(a)) >> 8,
                    i = n % 256,
                    o.push(i),
                    o.push(r);
                return o
            }(e, t.length - n), t, n, r)
        }
        function E(t, e, n) {
            return 0 === e && n === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, n))
        }
        function S(t, e, n) {
            n = Math.min(t.length, n);
            for (var r = [], i = e; i < n; ) {
                var o, a, s, c, h = t[i], l = null, u = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
                if (i + u <= n)
                    switch (u) {
                    case 1:
                        h < 128 && (l = h);
                        break;
                    case 2:
                        128 == (192 & (o = t[i + 1])) && (c = (31 & h) << 6 | 63 & o) > 127 && (l = c);
                        break;
                    case 3:
                        o = t[i + 1],
                        a = t[i + 2],
                        128 == (192 & o) && 128 == (192 & a) && (c = (15 & h) << 12 | (63 & o) << 6 | 63 & a) > 2047 && (c < 55296 || c > 57343) && (l = c);
                        break;
                    case 4:
                        o = t[i + 1],
                        a = t[i + 2],
                        s = t[i + 3],
                        128 == (192 & o) && 128 == (192 & a) && 128 == (192 & s) && (c = (15 & h) << 18 | (63 & o) << 12 | (63 & a) << 6 | 63 & s) > 65535 && c < 1114112 && (l = c)
                    }
                null === l ? (l = 65533,
                u = 1) : l > 65535 && (l -= 65536,
                r.push(l >>> 10 & 1023 | 55296),
                l = 56320 | 1023 & l),
                r.push(l),
                i += u
            }
            return function(t) {
                var e = t.length;
                if (e <= T)
                    return String.fromCharCode.apply(String, t);
                for (var n = "", r = 0; r < e; )
                    n += String.fromCharCode.apply(String, t.slice(r, r += T));
                return n
            }(r)
        }
        e.Buffer = c,
        e.SlowBuffer = function(t) {
            return +t != t && (t = 0),
            c.alloc(+t)
        }
        ,
        e.INSPECT_MAX_BYTES = 50,
        c.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function() {
            try {
                var t = new Uint8Array(1);
                return t.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42
                    }
                },
                42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
            } catch (t) {
                return !1
            }
        }(),
        e.kMaxLength = a(),
        c.poolSize = 8192,
        c._augment = function(t) {
            return t.__proto__ = c.prototype,
            t
        }
        ,
        c.from = function(t, e, n) {
            return h(null, t, e, n)
        }
        ,
        c.TYPED_ARRAY_SUPPORT && (c.prototype.__proto__ = Uint8Array.prototype,
        c.__proto__ = Uint8Array,
        "undefined" != typeof Symbol && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, {
            value: null,
            configurable: !0
        })),
        c.alloc = function(t, e, n) {
            return function(t, e, n, r) {
                return l(e),
                e <= 0 ? s(t, e) : void 0 !== n ? "string" == typeof r ? s(t, e).fill(n, r) : s(t, e).fill(n) : s(t, e)
            }(null, t, e, n)
        }
        ,
        c.allocUnsafe = function(t) {
            return u(null, t)
        }
        ,
        c.allocUnsafeSlow = function(t) {
            return u(null, t)
        }
        ,
        c.isBuffer = function(t) {
            return !(null == t || !t._isBuffer)
        }
        ,
        c.compare = function(t, e) {
            if (!c.isBuffer(t) || !c.isBuffer(e))
                throw new TypeError("Arguments must be Buffers");
            if (t === e)
                return 0;
            for (var n = t.length, r = e.length, i = 0, o = Math.min(n, r); i < o; ++i)
                if (t[i] !== e[i]) {
                    n = t[i],
                    r = e[i];
                    break
                }
            return n < r ? -1 : r < n ? 1 : 0
        }
        ,
        c.isEncoding = function(t) {
            switch (String(t).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
            }
        }
        ,
        c.concat = function(t, e) {
            if (!o(t))
                throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === t.length)
                return c.alloc(0);
            var n;
            if (void 0 === e)
                for (e = 0,
                n = 0; n < t.length; ++n)
                    e += t[n].length;
            var r = c.allocUnsafe(e)
              , i = 0;
            for (n = 0; n < t.length; ++n) {
                var a = t[n];
                if (!c.isBuffer(a))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                a.copy(r, i),
                i += a.length
            }
            return r
        }
        ,
        c.byteLength = f,
        c.prototype._isBuffer = !0,
        c.prototype.swap16 = function() {
            var t = this.length;
            if (t % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var e = 0; e < t; e += 2)
                m(this, e, e + 1);
            return this
        }
        ,
        c.prototype.swap32 = function() {
            var t = this.length;
            if (t % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var e = 0; e < t; e += 4)
                m(this, e, e + 3),
                m(this, e + 1, e + 2);
            return this
        }
        ,
        c.prototype.swap64 = function() {
            var t = this.length;
            if (t % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var e = 0; e < t; e += 8)
                m(this, e, e + 7),
                m(this, e + 1, e + 6),
                m(this, e + 2, e + 5),
                m(this, e + 3, e + 4);
            return this
        }
        ,
        c.prototype.toString = function() {
            var t = 0 | this.length;
            return 0 === t ? "" : 0 === arguments.length ? S(this, 0, t) : function(t, e, n) {
                var r = !1;
                if ((void 0 === e || e < 0) && (e = 0),
                e > this.length)
                    return "";
                if ((void 0 === n || n > this.length) && (n = this.length),
                n <= 0)
                    return "";
                if ((n >>>= 0) <= (e >>>= 0))
                    return "";
                for (t || (t = "utf8"); ; )
                    switch (t) {
                    case "hex":
                        return R(this, e, n);
                    case "utf8":
                    case "utf-8":
                        return S(this, e, n);
                    case "ascii":
                        return A(this, e, n);
                    case "latin1":
                    case "binary":
                        return L(this, e, n);
                    case "base64":
                        return E(this, e, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return P(this, e, n);
                    default:
                        if (r)
                            throw new TypeError("Unknown encoding: " + t);
                        t = (t + "").toLowerCase(),
                        r = !0
                    }
            }
            .apply(this, arguments)
        }
        ,
        c.prototype.equals = function(t) {
            if (!c.isBuffer(t))
                throw new TypeError("Argument must be a Buffer");
            return this === t || 0 === c.compare(this, t)
        }
        ,
        c.prototype.inspect = function() {
            var t = ""
              , n = e.INSPECT_MAX_BYTES;
            return this.length > 0 && (t = this.toString("hex", 0, n).match(/.{2}/g).join(" "),
            this.length > n && (t += " ... ")),
            "<Buffer " + t + ">"
        }
        ,
        c.prototype.compare = function(t, e, n, r, i) {
            if (!c.isBuffer(t))
                throw new TypeError("Argument must be a Buffer");
            if (void 0 === e && (e = 0),
            void 0 === n && (n = t ? t.length : 0),
            void 0 === r && (r = 0),
            void 0 === i && (i = this.length),
            e < 0 || n > t.length || r < 0 || i > this.length)
                throw new RangeError("out of range index");
            if (r >= i && e >= n)
                return 0;
            if (r >= i)
                return -1;
            if (e >= n)
                return 1;
            if (e >>>= 0,
            n >>>= 0,
            r >>>= 0,
            i >>>= 0,
            this === t)
                return 0;
            for (var o = i - r, a = n - e, s = Math.min(o, a), h = this.slice(r, i), l = t.slice(e, n), u = 0; u < s; ++u)
                if (h[u] !== l[u]) {
                    o = h[u],
                    a = l[u];
                    break
                }
            return o < a ? -1 : a < o ? 1 : 0
        }
        ,
        c.prototype.includes = function(t, e, n) {
            return -1 !== this.indexOf(t, e, n)
        }
        ,
        c.prototype.indexOf = function(t, e, n) {
            return g(this, t, e, n, !0)
        }
        ,
        c.prototype.lastIndexOf = function(t, e, n) {
            return g(this, t, e, n, !1)
        }
        ,
        c.prototype.write = function(t, e, n, r) {
            if (void 0 === e)
                r = "utf8",
                n = this.length,
                e = 0;
            else if (void 0 === n && "string" == typeof e)
                r = e,
                n = this.length,
                e = 0;
            else {
                if (!isFinite(e))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                e |= 0,
                isFinite(n) ? (n |= 0,
                void 0 === r && (r = "utf8")) : (r = n,
                n = void 0)
            }
            var i = this.length - e;
            if ((void 0 === n || n > i) && (n = i),
            t.length > 0 && (n < 0 || e < 0) || e > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            r || (r = "utf8");
            for (var o = !1; ; )
                switch (r) {
                case "hex":
                    return y(this, t, e, n);
                case "utf8":
                case "utf-8":
                    return x(this, t, e, n);
                case "ascii":
                    return w(this, t, e, n);
                case "latin1":
                case "binary":
                    return b(this, t, e, n);
                case "base64":
                    return M(this, t, e, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return _(this, t, e, n);
                default:
                    if (o)
                        throw new TypeError("Unknown encoding: " + r);
                    r = ("" + r).toLowerCase(),
                    o = !0
                }
        }
        ,
        c.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }
        ;
        var T = 4096;
        function A(t, e, n) {
            var r = "";
            n = Math.min(t.length, n);
            for (var i = e; i < n; ++i)
                r += String.fromCharCode(127 & t[i]);
            return r
        }
        function L(t, e, n) {
            var r = "";
            n = Math.min(t.length, n);
            for (var i = e; i < n; ++i)
                r += String.fromCharCode(t[i]);
            return r
        }
        function R(t, e, n) {
            var r = t.length;
            (!e || e < 0) && (e = 0),
            (!n || n < 0 || n > r) && (n = r);
            for (var i = "", o = e; o < n; ++o)
                i += F(t[o]);
            return i
        }
        function P(t, e, n) {
            for (var r = t.slice(e, n), i = "", o = 0; o < r.length; o += 2)
                i += String.fromCharCode(r[o] + 256 * r[o + 1]);
            return i
        }
        function C(t, e, n) {
            if (t % 1 != 0 || t < 0)
                throw new RangeError("offset is not uint");
            if (t + e > n)
                throw new RangeError("Trying to access beyond buffer length")
        }
        function I(t, e, n, r, i, o) {
            if (!c.isBuffer(t))
                throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > i || e < o)
                throw new RangeError('"value" argument is out of bounds');
            if (n + r > t.length)
                throw new RangeError("Index out of range")
        }
        function O(t, e, n, r) {
            e < 0 && (e = 65535 + e + 1);
            for (var i = 0, o = Math.min(t.length - n, 2); i < o; ++i)
                t[n + i] = (e & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i)
        }
        function D(t, e, n, r) {
            e < 0 && (e = 4294967295 + e + 1);
            for (var i = 0, o = Math.min(t.length - n, 4); i < o; ++i)
                t[n + i] = e >>> 8 * (r ? i : 3 - i) & 255
        }
        function U(t, e, n, r, i, o) {
            if (n + r > t.length)
                throw new RangeError("Index out of range");
            if (n < 0)
                throw new RangeError("Index out of range")
        }
        function N(t, e, n, r, o) {
            return o || U(t, 0, n, 4),
            i.write(t, e, n, r, 23, 4),
            n + 4
        }
        function B(t, e, n, r, o) {
            return o || U(t, 0, n, 8),
            i.write(t, e, n, r, 52, 8),
            n + 8
        }
        c.prototype.slice = function(t, e) {
            var n, r = this.length;
            if (t = ~~t,
            e = void 0 === e ? r : ~~e,
            t < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
            e < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
            e < t && (e = t),
            c.TYPED_ARRAY_SUPPORT)
                (n = this.subarray(t, e)).__proto__ = c.prototype;
            else {
                var i = e - t;
                n = new c(i,void 0);
                for (var o = 0; o < i; ++o)
                    n[o] = this[o + t]
            }
            return n
        }
        ,
        c.prototype.readUIntLE = function(t, e, n) {
            t |= 0,
            e |= 0,
            n || C(t, e, this.length);
            for (var r = this[t], i = 1, o = 0; ++o < e && (i *= 256); )
                r += this[t + o] * i;
            return r
        }
        ,
        c.prototype.readUIntBE = function(t, e, n) {
            t |= 0,
            e |= 0,
            n || C(t, e, this.length);
            for (var r = this[t + --e], i = 1; e > 0 && (i *= 256); )
                r += this[t + --e] * i;
            return r
        }
        ,
        c.prototype.readUInt8 = function(t, e) {
            return e || C(t, 1, this.length),
            this[t]
        }
        ,
        c.prototype.readUInt16LE = function(t, e) {
            return e || C(t, 2, this.length),
            this[t] | this[t + 1] << 8
        }
        ,
        c.prototype.readUInt16BE = function(t, e) {
            return e || C(t, 2, this.length),
            this[t] << 8 | this[t + 1]
        }
        ,
        c.prototype.readUInt32LE = function(t, e) {
            return e || C(t, 4, this.length),
            (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
        }
        ,
        c.prototype.readUInt32BE = function(t, e) {
            return e || C(t, 4, this.length),
            16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
        }
        ,
        c.prototype.readIntLE = function(t, e, n) {
            t |= 0,
            e |= 0,
            n || C(t, e, this.length);
            for (var r = this[t], i = 1, o = 0; ++o < e && (i *= 256); )
                r += this[t + o] * i;
            return r >= (i *= 128) && (r -= Math.pow(2, 8 * e)),
            r
        }
        ,
        c.prototype.readIntBE = function(t, e, n) {
            t |= 0,
            e |= 0,
            n || C(t, e, this.length);
            for (var r = e, i = 1, o = this[t + --r]; r > 0 && (i *= 256); )
                o += this[t + --r] * i;
            return o >= (i *= 128) && (o -= Math.pow(2, 8 * e)),
            o
        }
        ,
        c.prototype.readInt8 = function(t, e) {
            return e || C(t, 1, this.length),
            128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        }
        ,
        c.prototype.readInt16LE = function(t, e) {
            e || C(t, 2, this.length);
            var n = this[t] | this[t + 1] << 8;
            return 32768 & n ? 4294901760 | n : n
        }
        ,
        c.prototype.readInt16BE = function(t, e) {
            e || C(t, 2, this.length);
            var n = this[t + 1] | this[t] << 8;
            return 32768 & n ? 4294901760 | n : n
        }
        ,
        c.prototype.readInt32LE = function(t, e) {
            return e || C(t, 4, this.length),
            this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
        }
        ,
        c.prototype.readInt32BE = function(t, e) {
            return e || C(t, 4, this.length),
            this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
        }
        ,
        c.prototype.readFloatLE = function(t, e) {
            return e || C(t, 4, this.length),
            i.read(this, t, !0, 23, 4)
        }
        ,
        c.prototype.readFloatBE = function(t, e) {
            return e || C(t, 4, this.length),
            i.read(this, t, !1, 23, 4)
        }
        ,
        c.prototype.readDoubleLE = function(t, e) {
            return e || C(t, 8, this.length),
            i.read(this, t, !0, 52, 8)
        }
        ,
        c.prototype.readDoubleBE = function(t, e) {
            return e || C(t, 8, this.length),
            i.read(this, t, !1, 52, 8)
        }
        ,
        c.prototype.writeUIntLE = function(t, e, n, r) {
            t = +t,
            e |= 0,
            n |= 0,
            r || I(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
            var i = 1
              , o = 0;
            for (this[e] = 255 & t; ++o < n && (i *= 256); )
                this[e + o] = t / i & 255;
            return e + n
        }
        ,
        c.prototype.writeUIntBE = function(t, e, n, r) {
            t = +t,
            e |= 0,
            n |= 0,
            r || I(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
            var i = n - 1
              , o = 1;
            for (this[e + i] = 255 & t; --i >= 0 && (o *= 256); )
                this[e + i] = t / o & 255;
            return e + n
        }
        ,
        c.prototype.writeUInt8 = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 1, 255, 0),
            c.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
            this[e] = 255 & t,
            e + 1
        }
        ,
        c.prototype.writeUInt16LE = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 2, 65535, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t,
            this[e + 1] = t >>> 8) : O(this, t, e, !0),
            e + 2
        }
        ,
        c.prototype.writeUInt16BE = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 2, 65535, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8,
            this[e + 1] = 255 & t) : O(this, t, e, !1),
            e + 2
        }
        ,
        c.prototype.writeUInt32LE = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 4, 4294967295, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24,
            this[e + 2] = t >>> 16,
            this[e + 1] = t >>> 8,
            this[e] = 255 & t) : D(this, t, e, !0),
            e + 4
        }
        ,
        c.prototype.writeUInt32BE = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 4, 4294967295, 0),
            c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24,
            this[e + 1] = t >>> 16,
            this[e + 2] = t >>> 8,
            this[e + 3] = 255 & t) : D(this, t, e, !1),
            e + 4
        }
        ,
        c.prototype.writeIntLE = function(t, e, n, r) {
            if (t = +t,
            e |= 0,
            !r) {
                var i = Math.pow(2, 8 * n - 1);
                I(this, t, e, n, i - 1, -i)
            }
            var o = 0
              , a = 1
              , s = 0;
            for (this[e] = 255 & t; ++o < n && (a *= 256); )
                t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1),
                this[e + o] = (t / a >> 0) - s & 255;
            return e + n
        }
        ,
        c.prototype.writeIntBE = function(t, e, n, r) {
            if (t = +t,
            e |= 0,
            !r) {
                var i = Math.pow(2, 8 * n - 1);
                I(this, t, e, n, i - 1, -i)
            }
            var o = n - 1
              , a = 1
              , s = 0;
            for (this[e + o] = 255 & t; --o >= 0 && (a *= 256); )
                t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1),
                this[e + o] = (t / a >> 0) - s & 255;
            return e + n
        }
        ,
        c.prototype.writeInt8 = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 1, 127, -128),
            c.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
            t < 0 && (t = 255 + t + 1),
            this[e] = 255 & t,
            e + 1
        }
        ,
        c.prototype.writeInt16LE = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 2, 32767, -32768),
            c.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t,
            this[e + 1] = t >>> 8) : O(this, t, e, !0),
            e + 2
        }
        ,
        c.prototype.writeInt16BE = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 2, 32767, -32768),
            c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8,
            this[e + 1] = 255 & t) : O(this, t, e, !1),
            e + 2
        }
        ,
        c.prototype.writeInt32LE = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 4, 2147483647, -2147483648),
            c.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t,
            this[e + 1] = t >>> 8,
            this[e + 2] = t >>> 16,
            this[e + 3] = t >>> 24) : D(this, t, e, !0),
            e + 4
        }
        ,
        c.prototype.writeInt32BE = function(t, e, n) {
            return t = +t,
            e |= 0,
            n || I(this, t, e, 4, 2147483647, -2147483648),
            t < 0 && (t = 4294967295 + t + 1),
            c.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24,
            this[e + 1] = t >>> 16,
            this[e + 2] = t >>> 8,
            this[e + 3] = 255 & t) : D(this, t, e, !1),
            e + 4
        }
        ,
        c.prototype.writeFloatLE = function(t, e, n) {
            return N(this, t, e, !0, n)
        }
        ,
        c.prototype.writeFloatBE = function(t, e, n) {
            return N(this, t, e, !1, n)
        }
        ,
        c.prototype.writeDoubleLE = function(t, e, n) {
            return B(this, t, e, !0, n)
        }
        ,
        c.prototype.writeDoubleBE = function(t, e, n) {
            return B(this, t, e, !1, n)
        }
        ,
        c.prototype.copy = function(t, e, n, r) {
            if (n || (n = 0),
            r || 0 === r || (r = this.length),
            e >= t.length && (e = t.length),
            e || (e = 0),
            r > 0 && r < n && (r = n),
            r === n)
                return 0;
            if (0 === t.length || 0 === this.length)
                return 0;
            if (e < 0)
                throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length)
                throw new RangeError("sourceStart out of bounds");
            if (r < 0)
                throw new RangeError("sourceEnd out of bounds");
            r > this.length && (r = this.length),
            t.length - e < r - n && (r = t.length - e + n);
            var i, o = r - n;
            if (this === t && n < e && e < r)
                for (i = o - 1; i >= 0; --i)
                    t[i + e] = this[i + n];
            else if (o < 1e3 || !c.TYPED_ARRAY_SUPPORT)
                for (i = 0; i < o; ++i)
                    t[i + e] = this[i + n];
            else
                Uint8Array.prototype.set.call(t, this.subarray(n, n + o), e);
            return o
        }
        ,
        c.prototype.fill = function(t, e, n, r) {
            if ("string" == typeof t) {
                if ("string" == typeof e ? (r = e,
                e = 0,
                n = this.length) : "string" == typeof n && (r = n,
                n = this.length),
                1 === t.length) {
                    var i = t.charCodeAt(0);
                    i < 256 && (t = i)
                }
                if (void 0 !== r && "string" != typeof r)
                    throw new TypeError("encoding must be a string");
                if ("string" == typeof r && !c.isEncoding(r))
                    throw new TypeError("Unknown encoding: " + r)
            } else
                "number" == typeof t && (t &= 255);
            if (e < 0 || this.length < e || this.length < n)
                throw new RangeError("Out of range index");
            if (n <= e)
                return this;
            var o;
            if (e >>>= 0,
            n = void 0 === n ? this.length : n >>> 0,
            t || (t = 0),
            "number" == typeof t)
                for (o = e; o < n; ++o)
                    this[o] = t;
            else {
                var a = c.isBuffer(t) ? t : k(new c(t,r).toString())
                  , s = a.length;
                for (o = 0; o < n - e; ++o)
                    this[o + e] = a[o % s]
            }
            return this
        }
        ;
        var z = /[^+\/0-9A-Za-z-_]/g;
        function F(t) {
            return t < 16 ? "0" + t.toString(16) : t.toString(16)
        }
        function k(t, e) {
            var n;
            e = e || 1 / 0;
            for (var r = t.length, i = null, o = [], a = 0; a < r; ++a) {
                if ((n = t.charCodeAt(a)) > 55295 && n < 57344) {
                    if (!i) {
                        if (n > 56319) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        if (a + 1 === r) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        i = n;
                        continue
                    }
                    if (n < 56320) {
                        (e -= 3) > -1 && o.push(239, 191, 189),
                        i = n;
                        continue
                    }
                    n = 65536 + (i - 55296 << 10 | n - 56320)
                } else
                    i && (e -= 3) > -1 && o.push(239, 191, 189);
                if (i = null,
                n < 128) {
                    if ((e -= 1) < 0)
                        break;
                    o.push(n)
                } else if (n < 2048) {
                    if ((e -= 2) < 0)
                        break;
                    o.push(n >> 6 | 192, 63 & n | 128)
                } else if (n < 65536) {
                    if ((e -= 3) < 0)
                        break;
                    o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                } else {
                    if (!(n < 1114112))
                        throw new Error("Invalid code point");
                    if ((e -= 4) < 0)
                        break;
                    o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                }
            }
            return o
        }
        function H(t) {
            return r.toByteArray(function(t) {
                if ((t = function(t) {
                    return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
                }(t).replace(z, "")).length < 2)
                    return "";
                for (; t.length % 4 != 0; )
                    t += "=";
                return t
            }(t))
        }
        function G(t, e, n, r) {
            for (var i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)
                e[i + n] = t[i];
            return i
        }
    }
    ).call(this, n(25))
}
, function(t, e, n) {
    e.EncodeBuffer = i;
    var r = n(10).preset;
    function i(t) {
        if (!(this instanceof i))
            return new i(t);
        if (t && (this.options = t,
        t.codec)) {
            var e = this.codec = t.codec;
            e.bufferish && (this.bufferish = e.bufferish)
        }
    }
    n(19).FlexEncoder.mixin(i.prototype),
    i.prototype.codec = r,
    i.prototype.write = function(t) {
        this.codec.encode(this, t)
    }
}
, function(t, e, n) {
    e.encode = function(t, e) {
        var n = new r(e);
        return n.write(t),
        n.read()
    }
    ;
    var r = n(22).EncodeBuffer
}
, function(t, e) {
    var n, r, i = t.exports = {};
    function o() {
        throw new Error("setTimeout has not been defined")
    }
    function a() {
        throw new Error("clearTimeout has not been defined")
    }
    function s(t) {
        if (n === setTimeout)
            return setTimeout(t, 0);
        if ((n === o || !n) && setTimeout)
            return n = setTimeout,
            setTimeout(t, 0);
        try {
            return n(t, 0)
        } catch (e) {
            try {
                return n.call(null, t, 0)
            } catch (e) {
                return n.call(this, t, 0)
            }
        }
    }
    !function() {
        try {
            n = "function" == typeof setTimeout ? setTimeout : o
        } catch (t) {
            n = o
        }
        try {
            r = "function" == typeof clearTimeout ? clearTimeout : a
        } catch (t) {
            r = a
        }
    }();
    var c, h = [], l = !1, u = -1;
    function p() {
        l && c && (l = !1,
        c.length ? h = c.concat(h) : u = -1,
        h.length && d())
    }
    function d() {
        if (!l) {
            var t = s(p);
            l = !0;
            for (var e = h.length; e; ) {
                for (c = h,
                h = []; ++u < e; )
                    c && c[u].run();
                u = -1,
                e = h.length
            }
            c = null,
            l = !1,
            function(t) {
                if (r === clearTimeout)
                    return clearTimeout(t);
                if ((r === a || !r) && clearTimeout)
                    return r = clearTimeout,
                    clearTimeout(t);
                try {
                    r(t)
                } catch (e) {
                    try {
                        return r.call(null, t)
                    } catch (e) {
                        return r.call(this, t)
                    }
                }
            }(t)
        }
    }
    function f(t, e) {
        this.fun = t,
        this.array = e
    }
    function m() {}
    i.nextTick = function(t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var n = 1; n < arguments.length; n++)
                e[n - 1] = arguments[n];
        h.push(new f(t,e)),
        1 !== h.length || l || s(d)
    }
    ,
    f.prototype.run = function() {
        this.fun.apply(null, this.array)
    }
    ,
    i.title = "browser",
    i.browser = !0,
    i.env = {},
    i.argv = [],
    i.version = "",
    i.versions = {},
    i.on = m,
    i.addListener = m,
    i.once = m,
    i.off = m,
    i.removeListener = m,
    i.removeAllListeners = m,
    i.emit = m,
    i.prependListener = m,
    i.prependOnceListener = m,
    i.listeners = function(t) {
        return []
    }
    ,
    i.binding = function(t) {
        throw new Error("process.binding is not supported")
    }
    ,
    i.cwd = function() {
        return "/"
    }
    ,
    i.chdir = function(t) {
        throw new Error("process.chdir is not supported")
    }
    ,
    i.umask = function() {
        return 0
    }
}
, function(t, e) {
    var n;
    n = function() {
        return this
    }();
    try {
        n = n || Function("return this")() || (0,
        eval)("this")
    } catch (t) {
        "object" == typeof window && (n = window)
    }
    t.exports = n
}
, function(t, e, n) {
    var r, i, o = function(t) {
        this.width = t.w,
        this.length = t.l,
        this.height = t.h,
        this.x = t.x,
        this.y = t.y,
        this.z = t.z,
        this.dir = t.d,
        this.src = t.src,
        this.ramp = t.ramp,
        this.ladder = t.ladder,
        this.noShoot = t.noShoot,
        this.stepSrc = t.s,
        this.dummy = t.dummy,
        this.terrain = t.ter,
        this.noVis = t.noVis,
        this.complexMesh = t.complexMesh
    };
    t.exports.manager = function(t, e, a) {
        var s;
        t && (r = n(14).prefabs,
        i = n(2)),
        this.objects = [],
        this.collision = function(t, e, n) {
            return t.x - t.width - n <= e.x + e.width && t.x + t.width + n >= e.x - e.width && t.z - t.length - n <= e.z + e.length && t.z + t.length + n >= e.z - e.length && t.y - t.height - n <= e.y + e.height && t.y + t.height + n >= e.y - e.height
        }
        ,
        this.addCylinder = function(e, n, r, i, o, a) {
            t && (a.shadows = !0,
            t.addCylinder(e, n, r, i, o, a))
        }
        ,
        this.addLadder = function(n, r, c, h, l) {
            var u = a.ladderScale
              , p = a.ladderScale;
            if (0 == l || l == Math.PI ? p = a.ladderWidth : u = a.ladderWidth,
            s = new o({
                ladder: !0,
                complexMesh: !0,
                noShoot: !0,
                d: l,
                x: n + a.ladderScale * Math.cos(l),
                z: c + a.ladderScale * Math.sin(l),
                y: r,
                w: u,
                l: p,
                h: h
            }),
            this.objects.push(s),
            t) {
                var d = {
                    src: "floor_0",
                    vertexColors: i.VertexColors,
                    scale: .02,
                    shadows: !0
                };
                t.addCube(s.x + a.ladderWidth * Math.sin(l), s.y, s.z + a.ladderWidth * Math.cos(l), 2 * a.ladderScale, h + 2, 2 * a.ladderScale, [1, 1, 1, 0, 1, 1], d),
                t.addCube(s.x - a.ladderWidth * Math.sin(l), s.y, s.z - a.ladderWidth * Math.cos(l), 2 * a.ladderScale, h + 2, 2 * a.ladderScale, [1, 1, 1, 0, 1, 1], d);
                for (var f = Math.floor(h / 6), m = 0; m < f; ++m)
                    d.darken = a.ambientVal + (1 - a.ambientVal) * (m / f),
                    t.addPlane(s.x, r + 6 * (m + 1) + e.randFloat(-1, 1), s.z, a.ladderWidth, a.ladderScale, d, -l + Math.PI / 2, Math.PI / 2, e.randFloat(-.1, .1))
            }
        }
        ,
        this.addRamp = function(e, n, r, s, c, h, l, u) {
            var p = 0 != l && l != Math.PI
              , d = (p ? h : s) / 2;
            if (this.objects.push(new o({
                x: e,
                z: r,
                y: n + c / 2,
                w: s / 2,
                l: h / 2,
                h: c / 2,
                d: l,
                noShoot: !0,
                complexMesh: !0,
                ramp: {
                    sX: e - d * Math.cos(l),
                    sZ: r - d * Math.sin(l),
                    eX: e + d * Math.cos(l),
                    eZ: r + d * Math.sin(l)
                }
            })),
            t) {
                t.addRamp(e, n, r, p ? s : h, c, (p ? h : s) / 2, l, {
                    src: u || "default",
                    scale: 1,
                    shadowsR: !0
                }),
                n += a.ambOff;
                var f = (p ? s : h) / 2 - a.ambScale;
                p ? s = 2 * a.ambScale : h = 2 * a.ambScale;
                for (var m = 0; m < 2; ++m) {
                    var g = m ? 1 : -1;
                    t.addRamp(e + f * g * Math.cos(l + Math.PI / 2), n, r + f * g * Math.sin(l + Math.PI / 2), p ? s : h, c, (p ? h : s) / 2, l, {
                        src: "ambient_1",
                        side: i.DoubleSide,
                        shadowsR: !0,
                        transparent: !0,
                        depthWrite: !1
                    }, m ? 0 : Math.PI)
                }
            }
        }
        ,
        this.addBlock = function(e, n, r, a, s, c, h, l) {
            (l = l || {}).src = l.src || "wall_0",
            l.noCol || this.objects.push(new o({
                x: e,
                z: r,
                y: n + c / 2,
                w: a / 2,
                l: s / 2,
                h: c / 2,
                s: l.sound,
                src: l.src,
                noVis: l.noVis,
                ter: !0
            })),
            t && !l.noVis && (l.vertexColors = i.VertexColors,
            l.scale = void 0 == l.scale ? 1 : l.scale,
            l.shadows = !l.shadowsR,
            t.addCube(e, n, r, a, c, s, h, l))
        }
        ,
        this.addMesh = function(e, n, i, s, c, h, l, u, p) {
            n += h,
            p || this.objects.push(new o({
                complexMesh: !!r && r[u.toUpperCase()].complex,
                x: e,
                z: i,
                y: n,
                w: c,
                l: l,
                h: h,
                ter: !0
            })),
            t && t.loadMesh({
                src: u + "_0",
                shadows: !0
            }, e, n, i, s, a[u + "Scale"], t.scene, !0)
        }
        ,
        this.addPlane = function(e, n, r, a, s, c, h, l, u) {
            if ((c = c || {}).col && this.objects.push(new o({
                x: e,
                z: r,
                y: n,
                w: s,
                l: a,
                h: 0,
                s: c.sound,
                noVis: c.noVis
            })),
            t && !c.noVis)
                return c.transparent = !0,
                c.vertexColors = i.VertexColors,
                c.premultipliedAlpha = !0,
                c.depthWrite = !1,
                c.side = i.DoubleSide,
                c.shadowsR = !0,
                t.addPlane(e, n, r, s, a, c, h, (l || 0) + Math.PI / 2, u)
        }
        ,
        this.addAmbient = function(t, e, n, r, i, o, a, s, c, h) {
            if (h)
                return {
                    x: t,
                    y: e,
                    z: n,
                    xD: r,
                    yD: i,
                    zD: o,
                    w: a,
                    h: s,
                    i: c
                };
            this.addPlane(t, e, n, a, s, {
                src: "ambient_" + (c || 0),
                euler: "ZYX",
                depthWrite: !1
            }, r, i, o)
        }
        ,
        this.limitAmb = function(t, n, r, i, o, a, s) {
            var c = [e.cdv[i]]
              , h = [e.cdv[o]];
            return r == -Math.PI / 2 || r == Math.PI + Math.PI / 2 ? Math.min(t, (n[o] - Math.min(a[o] - a[h], s[o] - s[h])) / 2) : r == Math.PI / 2 ? Math.min(t, (Math.max(a[o] + a[h], s[o] + s[h]) - n[o]) / 2) : 0 == r ? Math.min(t, (Math.max(a[i] + a[c], s[i] + s[c]) - n[i]) / 2) : Math.min(t, (n[i] - Math.min(a[i] - a[c], s[i] - s[c])) / 2)
        }
        ,
        this.removeAll = function() {
            this.objects.length = 0
        }
    }
}
, function(t, e, n) {
    n(5),
    n(10),
    e.codec = {
        preset: n(3).preset
    }
}
, function(t, e, n) {
    n(5),
    n(10),
    e.createCodec = n(3).createCodec
}
, function(t, e, n) {
    e.Decoder = o;
    var r = n(15)
      , i = n(17).DecodeBuffer;
    function o(t) {
        if (!(this instanceof o))
            return new o(t);
        i.call(this, t)
    }
    o.prototype = new i,
    r.mixin(o.prototype),
    o.prototype.decode = function(t) {
        arguments.length && this.write(t),
        this.flush()
    }
    ,
    o.prototype.push = function(t) {
        this.emit("data", t)
    }
    ,
    o.prototype.end = function(t) {
        this.decode(t),
        this.emit("end")
    }
}
, function(t, e, n) {
    e.Encoder = o;
    var r = n(15)
      , i = n(22).EncodeBuffer;
    function o(t) {
        if (!(this instanceof o))
            return new o(t);
        i.call(this, t)
    }
    o.prototype = new i,
    r.mixin(o.prototype),
    o.prototype.encode = function(t) {
        this.write(t),
        this.emit("data", this.read())
    }
    ,
    o.prototype.end = function(t) {
        arguments.length && this.encode(t),
        this.flush(),
        this.emit("end")
    }
}
, function(t, e, n) {
    var r = n(16);
    function i(t) {
        var e, n = new Array(256);
        for (e = 0; e <= 127; e++)
            n[e] = o(e);
        for (e = 128; e <= 143; e++)
            n[e] = s(e - 128, t.map);
        for (e = 144; e <= 159; e++)
            n[e] = s(e - 144, t.array);
        for (e = 160; e <= 191; e++)
            n[e] = s(e - 160, t.str);
        for (n[192] = o(null),
        n[193] = null,
        n[194] = o(!1),
        n[195] = o(!0),
        n[196] = a(t.uint8, t.bin),
        n[197] = a(t.uint16, t.bin),
        n[198] = a(t.uint32, t.bin),
        n[199] = a(t.uint8, t.ext),
        n[200] = a(t.uint16, t.ext),
        n[201] = a(t.uint32, t.ext),
        n[202] = t.float32,
        n[203] = t.float64,
        n[204] = t.uint8,
        n[205] = t.uint16,
        n[206] = t.uint32,
        n[207] = t.uint64,
        n[208] = t.int8,
        n[209] = t.int16,
        n[210] = t.int32,
        n[211] = t.int64,
        n[212] = s(1, t.ext),
        n[213] = s(2, t.ext),
        n[214] = s(4, t.ext),
        n[215] = s(8, t.ext),
        n[216] = s(16, t.ext),
        n[217] = a(t.uint8, t.str),
        n[218] = a(t.uint16, t.str),
        n[219] = a(t.uint32, t.str),
        n[220] = a(t.uint16, t.array),
        n[221] = a(t.uint32, t.array),
        n[222] = a(t.uint16, t.map),
        n[223] = a(t.uint32, t.map),
        e = 224; e <= 255; e++)
            n[e] = o(e - 256);
        return n
    }
    function o(t) {
        return function() {
            return t
        }
    }
    function a(t, e) {
        return function(n) {
            var r = t(n);
            return e(n, r)
        }
    }
    function s(t, e) {
        return function(n) {
            return e(n, t)
        }
    }
    e.getReadToken = function(t) {
        var e = r.getReadFormat(t);
        return t && t.useraw ? function(t) {
            var e, n = i(t).slice();
            for (n[217] = n[196],
            n[218] = n[197],
            n[219] = n[198],
            e = 160; e <= 191; e++)
                n[e] = s(e - 160, t.bin);
            return n
        }(e) : i(e)
    }
}
, function(t, e, n) {
    e.setExtUnpackers = function(t) {
        t.addExtUnpacker(14, [s, h(Error)]),
        t.addExtUnpacker(1, [s, h(EvalError)]),
        t.addExtUnpacker(2, [s, h(RangeError)]),
        t.addExtUnpacker(3, [s, h(ReferenceError)]),
        t.addExtUnpacker(4, [s, h(SyntaxError)]),
        t.addExtUnpacker(5, [s, h(TypeError)]),
        t.addExtUnpacker(6, [s, h(URIError)]),
        t.addExtUnpacker(10, [s, c]),
        t.addExtUnpacker(11, [s, l(Boolean)]),
        t.addExtUnpacker(12, [s, l(String)]),
        t.addExtUnpacker(13, [s, l(Date)]),
        t.addExtUnpacker(15, [s, l(Number)]),
        "undefined" != typeof Uint8Array && (t.addExtUnpacker(17, l(Int8Array)),
        t.addExtUnpacker(18, l(Uint8Array)),
        t.addExtUnpacker(19, [u, l(Int16Array)]),
        t.addExtUnpacker(20, [u, l(Uint16Array)]),
        t.addExtUnpacker(21, [u, l(Int32Array)]),
        t.addExtUnpacker(22, [u, l(Uint32Array)]),
        t.addExtUnpacker(23, [u, l(Float32Array)]),
        "undefined" != typeof Float64Array && t.addExtUnpacker(24, [u, l(Float64Array)]),
        "undefined" != typeof Uint8ClampedArray && t.addExtUnpacker(25, l(Uint8ClampedArray)),
        t.addExtUnpacker(26, u),
        t.addExtUnpacker(29, [u, l(DataView)])),
        i.hasBuffer && t.addExtUnpacker(27, l(o))
    }
    ;
    var r, i = n(0), o = i.global, a = {
        name: 1,
        message: 1,
        stack: 1,
        columnNumber: 1,
        fileName: 1,
        lineNumber: 1
    };
    function s(t) {
        return r || (r = n(18).decode),
        r(t)
    }
    function c(t) {
        return RegExp.apply(null, t)
    }
    function h(t) {
        return function(e) {
            var n = new t;
            for (var r in a)
                n[r] = e[r];
            return n
        }
    }
    function l(t) {
        return function(e) {
            return new t(e)
        }
    }
    function u(t) {
        return new Uint8Array(t).buffer
    }
}
, function(t, e, n) {
    var r = n(8)
      , i = n(6)
      , o = i.Uint64BE
      , a = i.Int64BE
      , s = n(20).uint8
      , c = n(0)
      , h = c.global
      , l = c.hasBuffer && "TYPED_ARRAY_SUPPORT"in h && !h.TYPED_ARRAY_SUPPORT
      , u = c.hasBuffer && h.prototype || {};
    function p() {
        var t = s.slice();
        return t[196] = d(196),
        t[197] = f(197),
        t[198] = m(198),
        t[199] = d(199),
        t[200] = f(200),
        t[201] = m(201),
        t[202] = g(202, 4, u.writeFloatBE || x, !0),
        t[203] = g(203, 8, u.writeDoubleBE || w, !0),
        t[204] = d(204),
        t[205] = f(205),
        t[206] = m(206),
        t[207] = g(207, 8, v),
        t[208] = d(208),
        t[209] = f(209),
        t[210] = m(210),
        t[211] = g(211, 8, y),
        t[217] = d(217),
        t[218] = f(218),
        t[219] = m(219),
        t[220] = f(220),
        t[221] = m(221),
        t[222] = f(222),
        t[223] = m(223),
        t
    }
    function d(t) {
        return function(e, n) {
            var r = e.reserve(2)
              , i = e.buffer;
            i[r++] = t,
            i[r] = n
        }
    }
    function f(t) {
        return function(e, n) {
            var r = e.reserve(3)
              , i = e.buffer;
            i[r++] = t,
            i[r++] = n >>> 8,
            i[r] = n
        }
    }
    function m(t) {
        return function(e, n) {
            var r = e.reserve(5)
              , i = e.buffer;
            i[r++] = t,
            i[r++] = n >>> 24,
            i[r++] = n >>> 16,
            i[r++] = n >>> 8,
            i[r] = n
        }
    }
    function g(t, e, n, r) {
        return function(i, o) {
            var a = i.reserve(e + 1);
            i.buffer[a++] = t,
            n.call(i.buffer, o, a, r)
        }
    }
    function v(t, e) {
        new o(this,e,t)
    }
    function y(t, e) {
        new a(this,e,t)
    }
    function x(t, e) {
        r.write(this, t, e, !1, 23, 4)
    }
    function w(t, e) {
        r.write(this, t, e, !1, 52, 8)
    }
    e.getWriteToken = function(t) {
        return t && t.uint8array ? function() {
            var t = p();
            return t[202] = g(202, 4, x),
            t[203] = g(203, 8, w),
            t
        }() : l || c.hasBuffer && t && t.safe ? function() {
            var t = s.slice();
            return t[196] = g(196, 1, h.prototype.writeUInt8),
            t[197] = g(197, 2, h.prototype.writeUInt16BE),
            t[198] = g(198, 4, h.prototype.writeUInt32BE),
            t[199] = g(199, 1, h.prototype.writeUInt8),
            t[200] = g(200, 2, h.prototype.writeUInt16BE),
            t[201] = g(201, 4, h.prototype.writeUInt32BE),
            t[202] = g(202, 4, h.prototype.writeFloatBE),
            t[203] = g(203, 8, h.prototype.writeDoubleBE),
            t[204] = g(204, 1, h.prototype.writeUInt8),
            t[205] = g(205, 2, h.prototype.writeUInt16BE),
            t[206] = g(206, 4, h.prototype.writeUInt32BE),
            t[207] = g(207, 8, v),
            t[208] = g(208, 1, h.prototype.writeInt8),
            t[209] = g(209, 2, h.prototype.writeInt16BE),
            t[210] = g(210, 4, h.prototype.writeInt32BE),
            t[211] = g(211, 8, y),
            t[217] = g(217, 1, h.prototype.writeUInt8),
            t[218] = g(218, 2, h.prototype.writeUInt16BE),
            t[219] = g(219, 4, h.prototype.writeUInt32BE),
            t[220] = g(220, 2, h.prototype.writeUInt16BE),
            t[221] = g(221, 4, h.prototype.writeUInt32BE),
            t[222] = g(222, 2, h.prototype.writeUInt16BE),
            t[223] = g(223, 4, h.prototype.writeUInt32BE),
            t
        }() : p()
    }
}
, function(t, e, n) {
    var r = n(4)
      , i = n(6)
      , o = i.Uint64BE
      , a = i.Int64BE
      , s = n(0)
      , c = n(7)
      , h = n(33)
      , l = n(20).uint8
      , u = n(9).ExtBuffer
      , p = "undefined" != typeof Uint8Array
      , d = "undefined" != typeof Map
      , f = [];
    f[1] = 212,
    f[2] = 213,
    f[4] = 214,
    f[8] = 215,
    f[16] = 216,
    e.getWriteType = function(t) {
        var e = h.getWriteToken(t)
          , n = t && t.useraw
          , i = p && t && t.binarraybuffer
          , m = i ? s.isArrayBuffer : s.isBuffer
          , g = i ? function(t, e) {
            w(t, new Uint8Array(e))
        }
        : w
          , v = d && t && t.usemap ? function(t, n) {
            if (!(n instanceof Map))
                return b(t, n);
            var r = n.size;
            e[r < 16 ? 128 + r : r <= 65535 ? 222 : 223](t, r);
            var i = t.codec.encode;
            n.forEach(function(e, n, r) {
                i(t, n),
                i(t, e)
            })
        }
        : b;
        return {
            boolean: function(t, n) {
                e[n ? 195 : 194](t, n)
            },
            function: x,
            number: function(t, n) {
                var r = 0 | n;
                n === r ? e[-32 <= r && r <= 127 ? 255 & r : 0 <= r ? r <= 255 ? 204 : r <= 65535 ? 205 : 206 : -128 <= r ? 208 : -32768 <= r ? 209 : 210](t, r) : e[203](t, n)
            },
            object: n ? function(t, n) {
                if (m(n))
                    return function(t, n) {
                        var r = n.length;
                        e[r < 32 ? 160 + r : r <= 65535 ? 218 : 219](t, r),
                        t.send(n)
                    }(t, n);
                y(t, n)
            }
            : y,
            string: function(t) {
                return function(n, r) {
                    var i = r.length
                      , o = 5 + 3 * i;
                    n.offset = n.reserve(o);
                    var a = n.buffer
                      , s = t(i)
                      , h = n.offset + s;
                    i = c.write.call(a, r, h);
                    var l = t(i);
                    if (s !== l) {
                        var u = h + l - s
                          , p = h + i;
                        c.copy.call(a, a, u, h, p)
                    }
                    e[1 === l ? 160 + i : l <= 3 ? 215 + l : 219](n, i),
                    n.offset += i
                }
            }(n ? function(t) {
                return t < 32 ? 1 : t <= 65535 ? 3 : 5
            }
            : function(t) {
                return t < 32 ? 1 : t <= 255 ? 2 : t <= 65535 ? 3 : 5
            }
            ),
            symbol: x,
            undefined: x
        };
        function y(t, n) {
            if (null === n)
                return x(t, n);
            if (m(n))
                return g(t, n);
            if (r(n))
                return function(t, n) {
                    var r = n.length;
                    e[r < 16 ? 144 + r : r <= 65535 ? 220 : 221](t, r);
                    for (var i = t.codec.encode, o = 0; o < r; o++)
                        i(t, n[o])
                }(t, n);
            if (o.isUint64BE(n))
                return function(t, n) {
                    e[207](t, n.toArray())
                }(t, n);
            if (a.isInt64BE(n))
                return function(t, n) {
                    e[211](t, n.toArray())
                }(t, n);
            var i = t.codec.getExtPacker(n);
            if (i && (n = i(n)),
            n instanceof u)
                return function(t, n) {
                    var r = n.buffer
                      , i = r.length
                      , o = f[i] || (i < 255 ? 199 : i <= 65535 ? 200 : 201);
                    e[o](t, i),
                    l[n.type](t),
                    t.send(r)
                }(t, n);
            v(t, n)
        }
        function x(t, n) {
            e[192](t, n)
        }
        function w(t, n) {
            var r = n.length;
            e[r < 255 ? 196 : r <= 65535 ? 197 : 198](t, r),
            t.send(n)
        }
        function b(t, n) {
            var r = Object.keys(n)
              , i = r.length;
            e[i < 16 ? 128 + i : i <= 65535 ? 222 : 223](t, i);
            var o = t.codec.encode;
            r.forEach(function(e) {
                o(t, e),
                o(t, n[e])
            })
        }
    }
}
, function(t, e, n) {
    e.setExtPackers = function(t) {
        t.addExtPacker(14, Error, [u, c]),
        t.addExtPacker(1, EvalError, [u, c]),
        t.addExtPacker(2, RangeError, [u, c]),
        t.addExtPacker(3, ReferenceError, [u, c]),
        t.addExtPacker(4, SyntaxError, [u, c]),
        t.addExtPacker(5, TypeError, [u, c]),
        t.addExtPacker(6, URIError, [u, c]),
        t.addExtPacker(10, RegExp, [l, c]),
        t.addExtPacker(11, Boolean, [h, c]),
        t.addExtPacker(12, String, [h, c]),
        t.addExtPacker(13, Date, [Number, c]),
        t.addExtPacker(15, Number, [h, c]),
        "undefined" != typeof Uint8Array && (t.addExtPacker(17, Int8Array, a),
        t.addExtPacker(18, Uint8Array, a),
        t.addExtPacker(19, Int16Array, a),
        t.addExtPacker(20, Uint16Array, a),
        t.addExtPacker(21, Int32Array, a),
        t.addExtPacker(22, Uint32Array, a),
        t.addExtPacker(23, Float32Array, a),
        "undefined" != typeof Float64Array && t.addExtPacker(24, Float64Array, a),
        "undefined" != typeof Uint8ClampedArray && t.addExtPacker(25, Uint8ClampedArray, a),
        t.addExtPacker(26, ArrayBuffer, a),
        t.addExtPacker(29, DataView, a)),
        i.hasBuffer && t.addExtPacker(27, o, i.from)
    }
    ;
    var r, i = n(0), o = i.global, a = i.Uint8Array.from, s = {
        name: 1,
        message: 1,
        stack: 1,
        columnNumber: 1,
        fileName: 1,
        lineNumber: 1
    };
    function c(t) {
        return r || (r = n(23).encode),
        r(t)
    }
    function h(t) {
        return t.valueOf()
    }
    function l(t) {
        (t = RegExp.prototype.toString.call(t).split("/")).shift();
        var e = [t.pop()];
        return e.unshift(t.join("/")),
        e
    }
    function u(t) {
        var e = {};
        for (var n in s)
            e[n] = t[n];
        return e
    }
}
, function(t, e) {
    e.copy = function(t, e, n, r) {
        var i;
        n || (n = 0),
        r || 0 === r || (r = this.length),
        e || (e = 0);
        var o = r - n;
        if (t === this && n < e && e < r)
            for (i = o - 1; i >= 0; i--)
                t[i + e] = this[i + n];
        else
            for (i = 0; i < o; i++)
                t[i + e] = this[i + n];
        return o
    }
    ,
    e.toString = function(t, e, n) {
        var r = 0 | e;
        n || (n = this.length);
        for (var i = "", o = 0; r < n; )
            (o = this[r++]) < 128 ? i += String.fromCharCode(o) : (192 == (224 & o) ? o = (31 & o) << 6 | 63 & this[r++] : 224 == (240 & o) ? o = (15 & o) << 12 | (63 & this[r++]) << 6 | 63 & this[r++] : 240 == (248 & o) && (o = (7 & o) << 18 | (63 & this[r++]) << 12 | (63 & this[r++]) << 6 | 63 & this[r++]),
            o >= 65536 ? (o -= 65536,
            i += String.fromCharCode(55296 + (o >>> 10), 56320 + (1023 & o))) : i += String.fromCharCode(o));
        return i
    }
    ,
    e.write = function(t, e) {
        for (var n = e || (e |= 0), r = t.length, i = 0, o = 0; o < r; )
            (i = t.charCodeAt(o++)) < 128 ? this[n++] = i : i < 2048 ? (this[n++] = 192 | i >>> 6,
            this[n++] = 128 | 63 & i) : i < 55296 || i > 57343 ? (this[n++] = 224 | i >>> 12,
            this[n++] = 128 | i >>> 6 & 63,
            this[n++] = 128 | 63 & i) : (i = 65536 + (i - 55296 << 10 | t.charCodeAt(o++) - 56320),
            this[n++] = 240 | i >>> 18,
            this[n++] = 128 | i >>> 12 & 63,
            this[n++] = 128 | i >>> 6 & 63,
            this[n++] = 128 | 63 & i);
        return n - e
    }
}
, function(t, e, n) {
    var r = n(0);
    function i(t) {
        return new Uint8Array(t)
    }
    (e = t.exports = r.hasArrayBuffer ? i(0) : []).alloc = i,
    e.concat = r.concat,
    e.from = function(t) {
        if (r.isView(t)) {
            var n = t.byteOffset
              , i = t.byteLength;
            (t = t.buffer).byteLength !== i && (t.slice ? t = t.slice(n, n + i) : (t = new Uint8Array(t)).byteLength !== i && (t = Array.prototype.slice.call(t, n, n + i)))
        } else {
            if ("string" == typeof t)
                return r.from.call(e, t);
            if ("number" == typeof t)
                throw new TypeError('"value" argument must not be a number')
        }
        return new Uint8Array(t)
    }
}
, function(t, e, n) {
    var r = n(0)
      , i = r.global;
    function o(t) {
        return new i(t)
    }
    (e = t.exports = r.hasBuffer ? o(0) : []).alloc = r.hasBuffer && i.alloc || o,
    e.concat = r.concat,
    e.from = function(t) {
        if (!r.isBuffer(t) && r.isView(t))
            t = r.Uint8Array.from(t);
        else if (r.isArrayBuffer(t))
            t = new Uint8Array(t);
        else {
            if ("string" == typeof t)
                return r.from.call(e, t);
            if ("number" == typeof t)
                throw new TypeError('"value" argument must not be a number')
        }
        return i.from && 1 !== i.from.length ? i.from(t) : new i(t)
    }
}
, function(t, e, n) {
    var r = n(0);
    function i(t) {
        return new Array(t)
    }
    (e = t.exports = i(0)).alloc = i,
    e.concat = r.concat,
    e.from = function(t) {
        if (!r.isBuffer(t) && r.isView(t))
            t = r.Uint8Array.from(t);
        else if (r.isArrayBuffer(t))
            t = new Uint8Array(t);
        else {
            if ("string" == typeof t)
                return r.from.call(e, t);
            if ("number" == typeof t)
                throw new TypeError('"value" argument must not be a number')
        }
        return Array.prototype.slice.call(t)
    }
}
, function(t, e, n) {
    "use strict";
    e.byteLength = function(t) {
        var e = h(t)
          , n = e[0]
          , r = e[1];
        return 3 * (n + r) / 4 - r
    }
    ,
    e.toByteArray = function(t) {
        for (var e, n = h(t), r = n[0], a = n[1], s = new o(3 * (r + a) / 4 - a), c = 0, l = a > 0 ? r - 4 : r, u = 0; u < l; u += 4)
            e = i[t.charCodeAt(u)] << 18 | i[t.charCodeAt(u + 1)] << 12 | i[t.charCodeAt(u + 2)] << 6 | i[t.charCodeAt(u + 3)],
            s[c++] = e >> 16 & 255,
            s[c++] = e >> 8 & 255,
            s[c++] = 255 & e;
        return 2 === a && (e = i[t.charCodeAt(u)] << 2 | i[t.charCodeAt(u + 1)] >> 4,
        s[c++] = 255 & e),
        1 === a && (e = i[t.charCodeAt(u)] << 10 | i[t.charCodeAt(u + 1)] << 4 | i[t.charCodeAt(u + 2)] >> 2,
        s[c++] = e >> 8 & 255,
        s[c++] = 255 & e),
        s
    }
    ,
    e.fromByteArray = function(t) {
        for (var e, n = t.length, i = n % 3, o = [], a = 0, s = n - i; a < s; a += 16383)
            o.push(u(t, a, a + 16383 > s ? s : a + 16383));
        return 1 === i ? (e = t[n - 1],
        o.push(r[e >> 2] + r[e << 4 & 63] + "==")) : 2 === i && (e = (t[n - 2] << 8) + t[n - 1],
        o.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + "=")),
        o.join("")
    }
    ;
    for (var r = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, c = a.length; s < c; ++s)
        r[s] = a[s],
        i[a.charCodeAt(s)] = s;
    function h(t) {
        var e = t.length;
        if (e % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
        var n = t.indexOf("=");
        return -1 === n && (n = e),
        [n, n === e ? 0 : 4 - n % 4]
    }
    function l(t) {
        return r[t >> 18 & 63] + r[t >> 12 & 63] + r[t >> 6 & 63] + r[63 & t]
    }
    function u(t, e, n) {
        for (var r, i = [], o = e; o < n; o += 3)
            r = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (255 & t[o + 2]),
            i.push(l(r));
        return i.join("")
    }
    i["-".charCodeAt(0)] = 62,
    i["_".charCodeAt(0)] = 63
}
, function(t, e, n) {
    (function(e) {
        function n(t) {
            return t && t.isBuffer && t
        }
        t.exports = n(void 0 !== e && e) || n(this.Buffer) || n("undefined" != typeof window && window.Buffer) || this.Buffer
    }
    ).call(this, n(21).Buffer)
}
, function(t, e, n) {
    e.encode = n(23).encode,
    e.decode = n(18).decode,
    e.Encoder = n(30).Encoder,
    e.Decoder = n(29).Decoder,
    e.createCodec = n(28).createCodec,
    e.codec = n(27).codec
}
, function(t, e, n) {
    var r = n(42)
      , i = n(1);
    t.exports = {
        socket: null,
        connected: !1,
        socketId: -1,
        connect: function(t, e, n) {
            if (!this.socket) {
                var o = i.enableHttps ? "wss:" : "ws:"
                  , a = this;
                try {
                    var s = !1
                      , c = o + t;
                    this.socket = new WebSocket(c),
                    this.socket.binaryType = "arraybuffer",
                    this.socket.onmessage = function(t) {
                        var e = new Uint8Array(t.data)
                          , i = r.decode(e)
                          , o = i[0];
                        e = i[1],
                        "io-init" == o ? a.socketId = e[0] : n[o].apply(void 0, e)
                    }
                    ,
                    this.socket.onopen = function() {
                        a.connected = !0,
                        e()
                    }
                    ,
                    this.socket.onclose = function() {
                        a.connected = !1,
                        s || e("Disconnected. Try connecting to another server.")
                    }
                    ,
                    this.socket.onerror = function(t) {
                        this.socket.readyState != WebSocket.OPEN && (s = !0,
                        console.error("Socket error", arguments),
                        e("Socket error"))
                    }
                } catch (t) {
                    console.error("Socket connection error:", t),
                    e(t)
                }
            }
        },
        send: function(t) {
            var e = Array.prototype.slice.call(arguments, 1)
              , n = r.encode([t, e]);
            this.socket.send(n)
        },
        socketReady: function() {
            return this.socket && this.connected
        }
    }
}
, function(t, e, n) {
    var r = n(1)
      , i = n(2);
    t.exports = function(e, r, i) {
        var o = n(12)
          , a = new e.LoadingManager
          , s = new e.OBJLoader(a);
        this.cubeGeo = new e.BoxGeometry(1,1,1);
        var c = new e.PlaneGeometry(1,1)
          , h = new e.CylinderGeometry(.1,1,1,4,1,!1,Math.PI / 4);
        h.computeFlatVertexNormals();
        var l = new e.TextureLoader
          , u = {}
          , p = {}
          , d = {}
          , f = this
          , m = {};
        this.frustum = new e.Frustum;
        var g = new e.Matrix4;
        this.camera = new e.PerspectiveCamera(0,window.innerWidth / window.innerHeight,.07,8e3),
        this.weaponLean = 1,
        this.init = function(n) {
            this.scene = new e.Scene,
            t.exports.initScene.call(this, n),
            this.addPlane(0, 5e3, -4500, 750, 750, {
                src: "sun_0",
                noFog: !0,
                transparent: !0,
                mat: e.MeshBasicMaterial,
                noGroup: !0
            }, 0, r.getDirection(-4500, 5e3, 0, 0))
        }
        ,
        this.renderer = new e.WebGLRenderer,
        this.renderer.shadowMap.enabled = !0,
        this.renderer.shadowMap.type = e.BasicShadowMap,
        this.renderer.setPixelRatio(window.devicePixelRatio),
        this.renderer.setSize(window.innerWidth, window.innerHeight),
        document.body.appendChild(this.renderer.domElement),
        this.zoom = function(t) {
            this.camera.fov = this.fov / t,
            this.camera.updateProjectionMatrix()
        }
        ,
        this.setFov = function(t) {
            this.fov = t,
            this.camera.fov = t
        }
        ,
        this.setFov(i.fov),
        this.resize = function() {
            this.camera.aspect = window.innerWidth / window.innerHeight,
            this.camera.updateProjectionMatrix(),
            this.renderer.setSize(window.innerWidth, window.innerHeight)
        }
        ,
        this.setResMlt = function(t) {
            this.renderer.setPixelRatio(window.devicePixelRatio * t),
            this.renderer.setSize(window.innerWidth, window.innerHeight)
        }
        ,
        this.updateFrustum = function() {
            this.frustum.setFromMatrix(g.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse))
        }
        ,
        this.render = function(t) {
            this.scene && this.renderer.render(this.scene, this.camera)
        }
        ,
        this.updateTexture = function(t, n) {
            var r = d[t];
            r ? r.image = n : (r = new e.Texture(n),
            d[t] = r),
            r.needsUpdate = !0
        }
        ,
        this.loadTexture = function(t, n, r, i) {
            return d[n] ? d[n].mats ? d[n].mats.push(t) : (t[i || "map"] = d[n],
            t.needsUpdate = !0) : (d[n] = {
                mats: [t]
            },
            r = r || {},
            l.load("/textures/" + n + ".png", function(t) {
                t.wrapS = e.RepeatWrapping,
                t.wrapT = e.RepeatWrapping,
                t.repeat.set(r.repeatX || 1, r.repeatY || 1),
                t.minFilter = e.NearestFilter,
                t.magFilter = e.NearestFilter,
                t.needsUpdate = !0;
                for (var o = 0; o < d[n].mats.length; ++o)
                    d[n].mats[o][i || "map"] = t,
                    d[n].mats[o].needsUpdate = !0;
                d[n] = t
            })),
            t
        }
        ,
        this.getMat = function(t, n) {
            var r = t + (n ? (n.rotation || "") + (n.noFog || "") + (n.opacity || "") + (n.color || "") + (n.ao || "") : "")
              , i = p[r];
            return i || (i = new (n && n.mat ? n.mat : e.MeshLambertMaterial)(n),
            t && "default" != t && this.loadTexture(i, t, n),
            n && n.emissive && this.loadTexture(i, t + "_e", n, "emissiveMap"),
            n && n.ao && this.loadTexture(i, t + "_ao", n, "aoMap"),
            n && n.normal && this.loadTexture(i, t + "_n", n, "normalMap"),
            "default" == t && (i.vertexColors = e.VertexColors),
            n && n.noFog && (i.fog = !1),
            p[r] = i),
            i
        }
        ,
        this.offsetMesh = function(t, e) {
            t.translateZ(e)
        }
        ,
        this.genColorCube = function(t, n, r, i, a) {
            for (var s = "", c = 0; c < i.length; ++c)
                s += i[c] + "_";
            var h = u[s];
            if (!h) {
                h = new e.Geometry;
                var l = .5 + (a || 0);
                for (c = 0; c < i.length; ) {
                    var p = i[c + 1]
                      , d = new e.BoxGeometry(1 * (4 == c ? .9 : 1),p,1 * (4 == c ? .9 : 1));
                    o.colorize(d, i[c]);
                    var f = new e.Mesh(d);
                    this.moveMesh(f, 0, l - p / 2, 0),
                    this.merge(h, f),
                    l -= p,
                    c += 2
                }
                u[s] = h
            }
            return f = new e.Mesh(h,this.getMat("default")),
            this.scaleMesh(f, t, n, r),
            f
        }
        ;
        var v = {};
        this.genBody = function(t, n, r, o) {
            var a = v[t];
            if (!a) {
                a = new e.Geometry;
                var s = i.playerHeight - i.headScale - i.legHeight
                  , c = this.genColorCube(i.chestWidth, s, i.chestScale, [t, .8, n, .2]);
                this.moveMesh(c, 0, s / 2, 0),
                this.merge(a, c);
                var h = this.genColorCube(i.headScale, i.headScale, i.headScale, [r, .2, o, .8]);
                this.moveMesh(h, 0, i.playerHeight - i.headScale / 2 - i.legHeight, 0),
                this.merge(a, h),
                v[t] = a
            }
            var l = new e.Mesh(a,this.getMat("default"));
            return l.castShadow = !0,
            l.receiveShadow = !0,
            l
        }
        ;
        var y = {};
        this.genLeg = function(t, n, r, o) {
            var a = i.legScale
              , s = null;
            if (o) {
                var c = n + "-" + (o || "");
                if (!(s = y[c])) {
                    var h = i.legHeight / 2
                      , l = a / 2
                      , u = [.5, 2]
                      , p = this.genColorCube(a, h, a, [n, 1]);
                    this.moveMesh(p, 0, -h / 2 * Math.cos(u[1]), -h / 2 * Math.sin(u[1])),
                    this.rotateMesh(p, 0, u[1], 0);
                    var d = Math.sqrt(l * l + l * l - 2 * l * l * Math.cos(u[0] - u[1]))
                      , f = 2 * Math.sqrt(l * l - d / 2 * (d / 2))
                      , m = this.genColorCube(a, d, f, [n, 1]);
                    this.moveMesh(m, 0, -h * Math.cos(u[1]), -h * Math.sin(u[1])),
                    this.rotateMesh(m, 0, (u[1] + u[0]) / 2, 0);
                    var g = this.genColorCube(a, h, a, [n, .5, r, .5]);
                    this.moveMesh(g, 0, -h * Math.cos(u[1]) - h / 2 * Math.cos(u[0]), -h * Math.sin(u[1]) - h / 2 * Math.sin(u[0])),
                    this.rotateMesh(g, 0, u[0], 0),
                    s = new e.Geometry,
                    this.merge(s, p),
                    this.merge(s, m),
                    this.merge(s, g),
                    y[c] = s
                }
                s = new e.Mesh(s,this.getMat("default")),
                this.moveMesh(s, i.legScale / 2 * (t ? -1 : 1), i.legHeight - i.crouchDst + .5, 0)
            } else
                s = this.genColorCube(a, i.legHeight, a, [n, .75, r, .25], -.5),
                this.moveMesh(s, i.legScale / 2 * (t ? -1 : 1), i.legHeight, 0);
            return s.castShadow = !0,
            s.receiveShadow = !0,
            s
        }
        ;
        var x = {};
        this.genArms = function(t, n, r, o, a) {
            var s = x[t.name + "-" + r + "-" + a];
            if (!s) {
                s = new e.Geometry;
                var c = (-i.chestWidth + i.armScale / 2 - i.armInset) * (a ? .4 : 1);
                this.merge(s, this.genArm(c, i.armOff, t, !0, n, r, o, a)),
                this.merge(s, this.genArm(-c, i.armOff, t, !1, n, r, o, a)),
                x[t.name + "-" + r + "-" + a] = s
            }
            return (s = new e.Mesh(s,this.getMat("default"))).receiveShadow = !0,
            s
        }
        ,
        this.genArm = function(t, n, o, a, s, c, h, l) {
            var u = a ? o.leftHoldY : o.rightHoldY
              , p = a ? o.leftHoldZ : o.rightHoldZ
              , d = a ? 0 : o.rightHoldX || 0
              , f = i.armScale * (l ? .75 : 1)
              , m = Math.min(i.uArmLength + i.lArmLength - .01, r.getDistance3D(t, n, 0, o.xOff - d, o.yOff + u, o.zOff - p))
              , g = r.getAnglesSSS(m, i.uArmLength, i.lArmLength)
              , v = Math.PI / 2;
            if (!l) {
                var y = this.genColorCube(f, i.uArmLength, f, [s, 1]);
                this.moveMesh(y, 0, -i.uArmLength / 2 * Math.cos(v), -i.uArmLength / 2 * Math.sin(v)),
                this.rotateMesh(y, 0, v, 0);
                var x = f / 2
                  , w = Math.sqrt(x * x + x * x - 2 * x * x * Math.cos(Math.PI + g[0] + Math.PI / 2))
                  , b = 2 * Math.sqrt(x * x - w / 2 * (w / 2))
                  , M = this.genColorCube(f, w, b, [s, 1]);
                this.moveMesh(M, 0, -i.uArmLength * Math.cos(v), -i.uArmLength * Math.sin(v)),
                this.rotateMesh(M, 0, (v + g[0]) / 2, 0)
            }
            var _ = this.genColorCube(f, i.lArmLength, f, [s, .65, c, .15, h, .2])
              , E = i.lArmLength / 2;
            this.moveMesh(_, 0, -i.uArmLength * Math.cos(v) - E * Math.cos(g[0]), -i.uArmLength * Math.sin(v) - E * Math.sin(g[0])),
            this.rotateMesh(_, 0, g[0], 0);
            var S = new e.Geometry;
            if (l) {
                if (a) {
                    var T = this.genColorCube(f, 20, f, [s, 1]);
                    this.moveMesh(T, 0, -i.uArmLength * Math.cos(v) - -10 * Math.cos(g[0]), -i.uArmLength * Math.sin(v) - -10 * Math.sin(g[0])),
                    this.rotateMesh(T, 0, g[0], 0),
                    this.merge(S, T)
                }
            } else
                this.merge(S, y),
                this.merge(S, M);
            return this.merge(S, _),
            S = new e.Mesh(S),
            this.moveMesh(S, t - o.xOff, n - o.yOff, -o.zOff),
            S.rotation.order = "YXZ",
            S.rotation.x = -g[1] - r.getDirection(0, n, o.zOff - p, o.yOff + u),
            S.rotation.y = r.getDirection(-t, 0, -o.xOff - d, o.zOff - p) - Math.PI / 2,
            S
        }
        ,
        this.addCube = function(t, n, r, i, a, s, c, h) {
            h = h || {};
            var l = new e.Mesh(o.generateCube(c, i, a, s, h));
            return this.moveMesh(l, t, n, r),
            l.rotateY(h.xR || 0),
            l.rotateX(h.yR || 0),
            l.rotateZ(h.zR || 0),
            l.scale.set(i, a, s),
            h.src ? this.meshGroup(l, h) : this.add(l, h),
            l
        }
        ;
        var w = [];
        this.addSpray = function(t, n, o, a, s, h, l, u) {
            tmpObj = null;
            for (var p = 0; p < w.length; ++p)
                if (w[p].sid == t) {
                    tmpObj = w[p];
                    break
                }
            tmpObj || (tmpObj = new e.Mesh(c),
            tmpObj.sid = t,
            tmpObj.scale.set(i.sprayScale, i.sprayScale, 1),
            tmpObj.receiveShadow = !0,
            w.push(tmpObj),
            this.add(tmpObj)),
            this.moveMesh(tmpObj, o, a, s),
            tmpObj.rotation.y = r.toRad(h),
            tmpObj.rotation.x = r.toRad(l),
            tmpObj.material = this.getMat("sprays/" + n, {
                depthWrite: !1,
                opacity: u,
                transparent: !0
            })
        }
        ,
        this.clearSprays = function() {
            for (var t = 0; t < w.length; ++t)
                w[t].material.map.dispose(),
                this.scene.remove(w[t]);
            w.length = 0
        }
        ,
        this.addPlane = function(t, n, r, i, a, s, c, h, l) {
            s = s || {};
            var u = new e.Mesh(o.generatePlane(a, i, s));
            return s.euler && (u.eulerOrder = s.euler),
            this.moveMesh(u, t, n, r),
            u.rotateY(c || 0),
            u.rotateX((h || 0) - Math.PI / 2),
            u.rotateZ(l || 0),
            u.scale.set(2 * i, 2 * a, 1),
            s.dontAdd ? s.src && (u.material = this.getMat(s.src, s)) : s.src && !s.noGroup ? this.meshGroup(u, s) : this.add(u, s),
            u
        }
        ,
        this.addRamp = function(t, n, r, i, a, s, c, h, l) {
            h = h || {};
            var u = new e.Mesh(o.generatePlane(2 * s, i, h));
            this.moveMesh(u, t, n + a / 2, r),
            s *= 2;
            var p = Math.sqrt(a * a + s * s);
            return u.scale.set(i, p, 2),
            u.rotateY(-Math.PI / 2 - c),
            u.rotateX(Math.asin(a / p) - Math.PI / 2),
            u.rotateZ(l || 0),
            h.src ? this.meshGroup(u, h) : this.add(u, h),
            u
        }
        ,
        this.addCylinder = function(t, n, r, i, o, a) {
            a = a || {};
            var s = new e.Mesh(h);
            return this.moveMesh(s, t, n + o / 2, r),
            s.scale.set(2 * i, o, 2 * i),
            a.src ? this.meshGroup(s, a) : this.add(s, a),
            s
        }
        ;
        var b = []
          , M = [];
        this.loadMesh = function(t, n, r, i, o, a, c, h) {
            var l = this.getMat(t.src, t)
              , u = b[t.src];
            u || (u = h ? new e.Geometry : new e.BufferGeometry,
            b[t.src] = u,
            s.load("/models/" + t.src + ".obj", function(n) {
                if (n.children[0].geometry.computeVertexNormals(),
                u.copy(h ? (new e.Geometry).fromBufferGeometry(n.children[0].geometry) : n.children[0].geometry),
                t.uv2 && u.addAttribute("uv2", new e.BufferAttribute(u.attributes.uv.array,2)),
                h) {
                    for (var r = new e.Geometry, i = 0; i < M[t.src].length; ++i)
                        f.merge(r, M[t.src][i]);
                    f.add(new e.Mesh(r,l), t),
                    M[t.src].loaded = !0
                }
            }));
            var p = new e.Mesh(u,l);
            p.receiveShadow = !0,
            p.castShadow = t.shadows,
            p.rotation.y = o || 0,
            f.moveMesh(p, n, r, i),
            f.scaleMesh(p, a || 1, a || 1, a || 1),
            h ? M[t.src] ? M[t.src].loaded ? this.meshGroup(p, t) : M[t.src].push(p) : M[t.src] = [p] : c.add(p)
        }
        ,
        this.genObj3D = function(t, n, r) {
            var i = new e.Object3D;
            return this.moveMesh(i, t || 0, n || 0, r || 0),
            i
        }
        ,
        this.merge = function(t, e, n) {
            e.updateMatrix(),
            t.merge(e.geometry, e.matrix, n)
        }
        ,
        this.meshGroup = function(t, n) {
            var r = n.src + "-" + n.shadowsR;
            m[r] || (m[r] = new e.Geometry,
            m[r].data = n),
            t.updateMatrix(),
            m[r].merge(t.geometry, t.matrix)
        }
        ,
        this.addMeshGroups = function() {
            for (var t in m)
                if (m.hasOwnProperty(t)) {
                    var n = new e.Mesh(m[t]);
                    this.add(n, m[t].data)
                }
            m = {}
        }
        ,
        this.add = function(t, e) {
            e && (t.castShadow = e.shadows,
            t.receiveShadow = e.shadows || e.shadowsR,
            t.material = this.getMat(e.src, e)),
            this.scene.add(t)
        }
        ,
        this.remove = function(t) {
            this.scene.remove(t)
        }
        ,
        this.moveMesh = function(t, e, n, r) {
            void 0 != e && (t.position.x = e),
            void 0 != n && (t.position.y = n),
            void 0 != r && (t.position.z = r)
        }
        ,
        this.scaleMesh = function(t, e, n, r) {
            t.scale.set(e, n, r)
        }
        ,
        this.rotateMesh = function(t, e, n, r) {
            (e || 0 == e) && (t.rotation.y = e),
            (n || 0 == n) && (t.rotation.x = n),
            (r || 0 == r) && (t.rotation.z = r)
        }
    }
    ,
    t.exports.initScene = function(t) {
        this.ambientLight = new i.AmbientLight(t.ambient),
        this.scene.add(this.ambientLight),
        this.skyLight = new i.DirectionalLight(t.light,1.1),
        this.scene.fog = new i.Fog(t.fog,1,t.fogD),
        this.renderer.setClearColor(t.sky),
        this.scene.add(this.skyLight);
        var e = -.3 * Math.PI
          , n = 2 * Math.PI * -.25;
        this.skyLight.position.x = r.lightDistance * Math.cos(n),
        this.skyLight.position.y = r.lightDistance * Math.sin(n) * Math.sin(e),
        this.skyLight.position.z = r.lightDistance * Math.sin(n) * Math.cos(e),
        this.skyLight.castShadow = !0,
        this.skyLight.shadow.bias = .001,
        this.skyLight.shadow.mapSize.width = r.shadowRes,
        this.skyLight.shadow.mapSize.height = r.shadowRes,
        this.skyLight.shadow.camera.far = r.shadowDst,
        this.skyLight.shadow.camera.right = t.shadScale,
        this.skyLight.shadow.camera.left = -t.shadScale,
        this.skyLight.shadow.camera.top = t.shadScale,
        this.skyLight.shadow.camera.bottom = -t.shadScale
    }
}
, function(t, e) {
    t.exports = function(t) {
        return function() {
            var e = /^[og]\s*(.+)?/
              , n = /^mtllib /
              , r = /^usemtl /;
            function i(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager,
                this.materials = null
            }
            return i.prototype = {
                constructor: i,
                load: function(e, n, r, i) {
                    var o = this
                      , a = new t.FileLoader(o.manager);
                    a.setPath(this.path),
                    a.load(e, function(t) {
                        n(o.parse(t))
                    }, r, i)
                },
                setPath: function(t) {
                    return this.path = t,
                    this
                },
                setMaterials: function(t) {
                    return this.materials = t,
                    this
                },
                parse: function(i) {
                    console.time("OBJLoader");
                    var o = new function() {
                        var t = {
                            objects: [],
                            object: {},
                            vertices: [],
                            normals: [],
                            colors: [],
                            uvs: [],
                            materialLibraries: [],
                            startObject: function(t, e) {
                                if (this.object && !1 === this.object.fromDeclaration)
                                    return this.object.name = t,
                                    void (this.object.fromDeclaration = !1 !== e);
                                var n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                                if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0),
                                this.object = {
                                    name: t || "",
                                    fromDeclaration: !1 !== e,
                                    geometry: {
                                        vertices: [],
                                        normals: [],
                                        colors: [],
                                        uvs: []
                                    },
                                    materials: [],
                                    smooth: !0,
                                    startMaterial: function(t, e) {
                                        var n = this._finalize(!1);
                                        n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                                        var r = {
                                            index: this.materials.length,
                                            name: t || "",
                                            mtllib: Array.isArray(e) && e.length > 0 ? e[e.length - 1] : "",
                                            smooth: void 0 !== n ? n.smooth : this.smooth,
                                            groupStart: void 0 !== n ? n.groupEnd : 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1,
                                            clone: function(t) {
                                                var e = {
                                                    index: "number" == typeof t ? t : this.index,
                                                    name: this.name,
                                                    mtllib: this.mtllib,
                                                    smooth: this.smooth,
                                                    groupStart: 0,
                                                    groupEnd: -1,
                                                    groupCount: -1,
                                                    inherited: !1
                                                };
                                                return e.clone = this.clone.bind(e),
                                                e
                                            }
                                        };
                                        return this.materials.push(r),
                                        r
                                    },
                                    currentMaterial: function() {
                                        if (this.materials.length > 0)
                                            return this.materials[this.materials.length - 1]
                                    },
                                    _finalize: function(t) {
                                        var e = this.currentMaterial();
                                        if (e && -1 === e.groupEnd && (e.groupEnd = this.geometry.vertices.length / 3,
                                        e.groupCount = e.groupEnd - e.groupStart,
                                        e.inherited = !1),
                                        t && this.materials.length > 1)
                                            for (var n = this.materials.length - 1; n >= 0; n--)
                                                this.materials[n].groupCount <= 0 && this.materials.splice(n, 1);
                                        return t && 0 === this.materials.length && this.materials.push({
                                            name: "",
                                            smooth: this.smooth
                                        }),
                                        e
                                    }
                                },
                                n && n.name && "function" == typeof n.clone) {
                                    var r = n.clone(0);
                                    r.inherited = !0,
                                    this.object.materials.push(r)
                                }
                                this.objects.push(this.object)
                            },
                            finalize: function() {
                                this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                            },
                            parseVertexIndex: function(t, e) {
                                var n = parseInt(t, 10);
                                return 3 * (n >= 0 ? n - 1 : n + e / 3)
                            },
                            parseNormalIndex: function(t, e) {
                                var n = parseInt(t, 10);
                                return 3 * (n >= 0 ? n - 1 : n + e / 3)
                            },
                            parseUVIndex: function(t, e) {
                                var n = parseInt(t, 10);
                                return 2 * (n >= 0 ? n - 1 : n + e / 2)
                            },
                            addVertex: function(t, e, n) {
                                var r = this.vertices
                                  , i = this.object.geometry.vertices;
                                i.push(r[t + 0], r[t + 1], r[t + 2]),
                                i.push(r[e + 0], r[e + 1], r[e + 2]),
                                i.push(r[n + 0], r[n + 1], r[n + 2])
                            },
                            addVertexPoint: function(t) {
                                var e = this.vertices;
                                this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2])
                            },
                            addVertexLine: function(t) {
                                var e = this.vertices;
                                this.object.geometry.vertices.push(e[t + 0], e[t + 1], e[t + 2])
                            },
                            addNormal: function(t, e, n) {
                                var r = this.normals
                                  , i = this.object.geometry.normals;
                                i.push(r[t + 0], r[t + 1], r[t + 2]),
                                i.push(r[e + 0], r[e + 1], r[e + 2]),
                                i.push(r[n + 0], r[n + 1], r[n + 2])
                            },
                            addColor: function(t, e, n) {
                                var r = this.colors
                                  , i = this.object.geometry.colors;
                                i.push(r[t + 0], r[t + 1], r[t + 2]),
                                i.push(r[e + 0], r[e + 1], r[e + 2]),
                                i.push(r[n + 0], r[n + 1], r[n + 2])
                            },
                            addUV: function(t, e, n) {
                                var r = this.uvs
                                  , i = this.object.geometry.uvs;
                                i.push(r[t + 0], r[t + 1]),
                                i.push(r[e + 0], r[e + 1]),
                                i.push(r[n + 0], r[n + 1])
                            },
                            addUVLine: function(t) {
                                var e = this.uvs;
                                this.object.geometry.uvs.push(e[t + 0], e[t + 1])
                            },
                            addFace: function(t, e, n, r, i, o, a, s, c) {
                                var h = this.vertices.length
                                  , l = this.parseVertexIndex(t, h)
                                  , u = this.parseVertexIndex(e, h)
                                  , p = this.parseVertexIndex(n, h);
                                if (this.addVertex(l, u, p),
                                void 0 !== r && "" !== r) {
                                    var d = this.uvs.length;
                                    l = this.parseUVIndex(r, d),
                                    u = this.parseUVIndex(i, d),
                                    p = this.parseUVIndex(o, d),
                                    this.addUV(l, u, p)
                                }
                                if (void 0 !== a && "" !== a) {
                                    var f = this.normals.length;
                                    l = this.parseNormalIndex(a, f),
                                    u = a === s ? l : this.parseNormalIndex(s, f),
                                    p = a === c ? l : this.parseNormalIndex(c, f),
                                    this.addNormal(l, u, p)
                                }
                                this.colors.length > 0 && this.addColor(l, u, p)
                            },
                            addPointGeometry: function(t) {
                                this.object.geometry.type = "Points";
                                for (var e = this.vertices.length, n = 0, r = t.length; n < r; n++)
                                    this.addVertexPoint(this.parseVertexIndex(t[n], e))
                            },
                            addLineGeometry: function(t, e) {
                                this.object.geometry.type = "Line";
                                for (var n = this.vertices.length, r = this.uvs.length, i = 0, o = t.length; i < o; i++)
                                    this.addVertexLine(this.parseVertexIndex(t[i], n));
                                var a = 0;
                                for (o = e.length; a < o; a++)
                                    this.addUVLine(this.parseUVIndex(e[a], r))
                            }
                        };
                        return t.startObject("", !1),
                        t
                    }
                    ;
                    -1 !== i.indexOf("\r\n") && (i = i.replace(/\r\n/g, "\n")),
                    -1 !== i.indexOf("\\\n") && (i = i.replace(/\\\n/g, ""));
                    for (var a = i.split("\n"), s = "", c = "", h = [], l = "function" == typeof "".trimLeft, u = 0, p = a.length; u < p; u++)
                        if (s = a[u],
                        0 !== (s = l ? s.trimLeft() : s.trim()).length && "#" !== (c = s.charAt(0)))
                            if ("v" === c) {
                                var d = s.split(/\s+/);
                                switch (d[0]) {
                                case "v":
                                    o.vertices.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3])),
                                    8 === d.length && o.colors.push(parseFloat(d[4]), parseFloat(d[5]), parseFloat(d[6]));
                                    break;
                                case "vn":
                                    o.normals.push(parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3]));
                                    break;
                                case "vt":
                                    o.uvs.push(parseFloat(d[1]), parseFloat(d[2]))
                                }
                            } else if ("f" === c) {
                                for (var f = s.substr(1).trim().split(/\s+/), m = [], g = 0, v = f.length; g < v; g++) {
                                    var y = f[g];
                                    if (y.length > 0) {
                                        var x = y.split("/");
                                        m.push(x)
                                    }
                                }
                                var w = m[0];
                                for (g = 1,
                                v = m.length - 1; g < v; g++) {
                                    var b = m[g]
                                      , M = m[g + 1];
                                    o.addFace(w[0], b[0], M[0], w[1], b[1], M[1], w[2], b[2], M[2])
                                }
                            } else if ("l" === c) {
                                var _ = s.substring(1).trim().split(" ")
                                  , E = []
                                  , S = [];
                                if (-1 === s.indexOf("/"))
                                    E = _;
                                else
                                    for (var T = 0, A = _.length; T < A; T++) {
                                        var L = _[T].split("/");
                                        "" !== L[0] && E.push(L[0]),
                                        "" !== L[1] && S.push(L[1])
                                    }
                                o.addLineGeometry(E, S)
                            } else if ("p" === c) {
                                var R = s.substr(1).trim().split(" ");
                                o.addPointGeometry(R)
                            } else if (null !== (h = e.exec(s))) {
                                var P = (" " + h[0].substr(1).trim()).substr(1);
                                o.startObject(P)
                            } else if (r.test(s))
                                o.object.startMaterial(s.substring(7).trim(), o.materialLibraries);
                            else if (n.test(s))
                                o.materialLibraries.push(s.substring(7).trim());
                            else {
                                if ("s" !== c) {
                                    if ("\0" === s)
                                        continue;
                                    throw new Error('THREE.OBJLoader: Unexpected line: "' + s + '"')
                                }
                                if ((h = s.split(" ")).length > 1) {
                                    var C = h[1].trim().toLowerCase();
                                    o.object.smooth = "0" !== C && "off" !== C
                                } else
                                    o.object.smooth = !0;
                                (W = o.object.currentMaterial()) && (W.smooth = o.object.smooth)
                            }
                    o.finalize();
                    var I = new t.Group;
                    for (I.materialLibraries = [].concat(o.materialLibraries),
                    u = 0,
                    p = o.objects.length; u < p; u++) {
                        var O = o.objects[u]
                          , D = O.geometry
                          , U = O.materials
                          , N = "Line" === D.type
                          , B = "Points" === D.type
                          , z = !1;
                        if (0 !== D.vertices.length) {
                            var F = new t.BufferGeometry;
                            F.addAttribute("position", new t.Float32BufferAttribute(D.vertices,3)),
                            D.normals.length > 0 ? F.addAttribute("normal", new t.Float32BufferAttribute(D.normals,3)) : F.computeVertexNormals(),
                            D.colors.length > 0 && (z = !0,
                            F.addAttribute("color", new t.Float32BufferAttribute(D.colors,3))),
                            D.uvs.length > 0 && F.addAttribute("uv", new t.Float32BufferAttribute(D.uvs,2));
                            for (var k, H = [], G = 0, V = U.length; G < V; G++) {
                                var j = U[G]
                                  , W = void 0;
                                if (null !== this.materials)
                                    if (W = this.materials.create(j.name),
                                    !N || !W || W instanceof t.LineBasicMaterial) {
                                        if (B && W && !(W instanceof t.PointsMaterial)) {
                                            var Y = new t.PointsMaterial({
                                                size: 10,
                                                sizeAttenuation: !1
                                            });
                                            X.copy(W),
                                            W = Y
                                        }
                                    } else {
                                        var X = new t.LineBasicMaterial;
                                        X.copy(W),
                                        X.lights = !1,
                                        W = X
                                    }
                                W || ((W = N ? new t.LineBasicMaterial : B ? new t.PointsMaterial({
                                    size: 1,
                                    sizeAttenuation: !1
                                }) : new t.MeshPhongMaterial).name = j.name),
                                W.flatShading = !j.smooth,
                                W.vertexColors = z ? t.VertexColors : t.NoColors,
                                H.push(W)
                            }
                            if (H.length > 1) {
                                for (G = 0,
                                V = U.length; G < V; G++)
                                    j = U[G],
                                    F.addGroup(j.groupStart, j.groupCount, G);
                                k = N ? new t.LineSegments(F,H) : B ? new t.Points(F,H) : new t.Mesh(F,H)
                            } else
                                k = N ? new t.LineSegments(F,H[0]) : B ? new t.Points(F,H[0]) : new t.Mesh(F,H[0]);
                            k.name = O.name,
                            I.add(k)
                        }
                    }
                    return console.timeEnd("OBJLoader"),
                    I
                }
            },
            i
        }()
    }
}
, function(t, e) {
    var n = {
        utf8: {
            stringToBytes: function(t) {
                return n.bin.stringToBytes(unescape(encodeURIComponent(t)))
            },
            bytesToString: function(t) {
                return decodeURIComponent(escape(n.bin.bytesToString(t)))
            }
        },
        bin: {
            stringToBytes: function(t) {
                for (var e = [], n = 0; n < t.length; n++)
                    e.push(255 & t.charCodeAt(n));
                return e
            },
            bytesToString: function(t) {
                for (var e = [], n = 0; n < t.length; n++)
                    e.push(String.fromCharCode(t[n]));
                return e.join("")
            }
        }
    };
    t.exports = n
}
, , , , , function(t, e) {
    t.exports = function(t, e, n, r) {
        n = n || {},
        this.id = t,
        this.name = e,
        this.score = n.player_score || 0,
        this.kills = n.player_kills || 0,
        this.deaths = n.player_deaths || 0,
        this.wins = n.player_wins || 0,
        this.games = n.player_games_played || 0,
        this.clan = n.player_clanid,
        this.funds = n.player_funds || 0,
        this.timePlayed = n.player_timeplayed || 0,
        this.setData = function(t) {
            this.kills = t[1],
            this.wins = t[2],
            this.games = t[3],
            this.deaths = t[4],
            this.funds = t[5],
            this.score = t[6],
            this.updateLevel(),
            this.clan = t[7],
            this.timePlayed = t[8]
        }
        ,
        this.updateLevel = function() {
            this.level = Math.max(1, Math.floor(r.rankVar * Math.sqrt(this.score)))
        }
        ,
        this.updateLevel(),
        this.getData = function() {
            return [this.id, this.kills, this.wins, this.games, this.deaths, this.funds, this.score, this.clan, this.timePlayed]
        }
    }
}
, function(t, e) {
    var n = ["Double Kill", "Triple Kill", "Quad Kill", "Multi Kill", "Mega Kill", "Ultra Kill", "Super Kill"]
      , r = [];
    t.exports.reward = function(t, e, i, o) {
        if (r.length = 0,
        e.weapon.melee)
            r.push("Execution", 300);
        else {
            e.weapon.kill ? r.push(e.weapon.kill[0], e.weapon.kill[1]) : e.weapon.scope && 1 == e.aimVal ? r.push("No Scope", 100) : !e.weapon.scope || 0 == e.aimVal && e.aimTime > 180 || 1 == e.aimDir ? r.push("", 50) : r.push("Quick Scope", 75);
            var a = t.getSpin(e);
            a >= 720 ? r.push("720!", 500) : a >= 360 && r.push("360!", 250),
            o.headShot && r.push("Headshot", 50),
            !e.weapon.scope && o.dst * e.weapon.range > 200 && r.push("Longshot", 25)
        }
        e.airTime >= 400 && r.push("Mid Air", 25);
        for (var s = n.length - 1; s >= 0; --s)
            if (e.streak > s) {
                r.push(n[s], 50 * (s + 1));
                break
            }
        return r.length ? r : null
    }
    ,
    t.exports.getScore = function(t) {
        var e = 0;
        if (t)
            for (var n = 1; n < t.length; n += 2)
                e += t[n];
        return e
    }
}
, function(t, e, n) {
    var r = n(2);
    t.exports.manager = function(t, e, i, o, a, s, c) {
        var h, l, u;
        this.list = [];
        var p = n(52);
        this.setTeam = function(t, e) {
            if (e.teams && !t.team) {
                for (var n = 0, r = 0, i = 0; i < this.list.length; ++i)
                    1 == this.list[i].team && n++,
                    2 == this.list[i].team && r++;
                t.team = n >= r ? 2 : 1
            }
        }
        ,
        this.update = function(n) {
            e && (l = e.camera.getWorldPosition());
            for (var r = 0; r < this.list.length; ++r)
                if ((h = this.list[r]).active && (h.update(t, n),
                c && (this.tickPlayer(h, n),
                this.storeState(h),
                h.y <= s.deathY && this.kill(h)),
                e && (this.updateMesh(h),
                h.isYou || this.updateHeight(h)),
                !h.isYou && h.objInstances)) {
                    var i = document.getElementById("pInfo" + h.sid);
                    if (i)
                        if (cheatSettings.espName || h.inView && h.objInstances.visible) {
                            var o = h.objInstances.position.clone();
                            o.y += s.playerHeight + s.nameOffset - h.crouchVal * s.crouchDst;
                            var u = Math.max(.3, 1 - a.getDistance3D(l.x, l.y, l.z, o.x, o.y, o.z) / 600)
                              , p = 22 * u
                              , d = p >= 1 && e.frustum.containsPoint(o);
                            if (i.style.display = d ? "block" : "none",
                            d) {
                                o.project(e.camera),
                                o.x = (o.x + 1) / 2,
                                o.y = (o.y + 1) / 2;
                                var f = 14 * u
                                  , m = 22 * u;
                                i.style.left = 100 * o.x + "%",
                                i.style.marginLeft = -i.offsetWidth / 2 + "px",
                                i.style.top = 100 * (1 - o.y) + "%",
                                i.style.marginTop = -(f + m) + "px",
                                (i = document.getElementById("pInfoH" + h.sid)) && (i.style.fontSize = p + "px",
                                i.children[1].style.width = 120 * u + "px",
                                i.children[1].style.height = f + "px",
                                i.children[1].style.marginTop = m + "px"),
                                h.level && (i = document.getElementById("pInfoR" + h.sid)) && (i.style.fontSize = 32 * u + "px",
                                i.style.marginRight = 10 * u + "px")
                            }
                        } else {
                            i.style.display = "none"
						}
                }
        }
        ,
        this.forcePos = function() {
            for (var t = 0; t < this.list.length; ++t)
                this.list[t].forcePos = !0,
                this.list[t].objInstances && (this.list[t].objInstances.visible = !1,
                this.list[t].inView = !1)
        }
        ,
        this.saveSpin = function(t, e) {
            c && (t.spins.unshift(e),
            t.spins.length > s.spinTimer / s.serverTickRate && (t.spins.length = Math.round(s.spinTimer / s.serverTickRate)))
        }
        ,
        this.getSpin = function(t) {
            for (var e = 0, n = 0; n < t.spins.length; ++n)
                e += t.spins[n];
            return Math.abs(e * (180 / Math.PI))
        }
        ,
        this.storeState = function(e) {
            e.stateHistory.unshift({
                time: t.now,
                x: e.x,
                y: e.y,
                z: e.z
            });
            for (var n = e.stateHistory.length - 1; n >= 0; --n)
                t.now - e.stateHistory[n].time >= s.stateHistory && e.stateHistory.splice(n, 1)
        }
        ,
        this.fetchState = function(e, n) {
            for (var r = t.now - (n + s.serverSendRate * s.interpolation), i = 0; i < e.stateHistory.length; ++i)
                if (e.stateHistory[i].time <= r)
                    return e.stateHistory[i];
            return e.stateHistory[e.stateHistory.length - 1]
        }
        ,
        this.updateMesh = function(t) {
            if (t.objInstances) {
                var n = (1 - (1 - s.aimAnimMlt) * (1 - t.aimVal)) * s.animMult * e.weaponLean
                  , r = 1 - .55 * (1 - t.aimVal)
                  , i = Math.sin(t.stepVal) * s.stepAnim
                  , o = Math.cos(2 * t.stepVal) / 2 * s.stepAnim
                  , a = 1 - t.aimVal
                  , c = .35 * (a <= .5 ? a : .5 - (a - .5))
                  , h = t.swapTime / t.weapon.swapTime
                  , l = t.weapon.xOff
                  , u = 0;
                t.reloadTimer > 0 && (u = (u = 1 - t.reloadTimer / t.weapon.reload) > .5 ? .5 - (u - .5) : u),
                e.moveMesh(t.objInstances, t.x, t.y + (t.isYou ? 0 : Math.abs(3.5 * i)), t.z),
                e.rotateMesh(t.objInstances, t.xDir + (t.isYou ? 0 : 2 * -i)),
                o -= o * (t.crouchVal * s.crouchAnimMlt),
                i -= i * (t.crouchVal * s.crouchAnimMlt);
                for (var p = 0; p < t.legMeshes.length; ++p)
                    t.legMeshes[p].rotation.x = i * (1 == p || 3 == p ? 1 : -1) * 7 + (p > 1 ? -.6 : 0);
                e.rotateMesh(t.upperBody, -1 * u, -2.8 * u + t.yDir * (t.isYou ? 1 : .5) + (-Math.PI / 4 * h + (.2 * t.landAnim + t.recoilAnimY * s.recoilMlt * (t.weapon.recoilY || 1)) - t.bobAnimY * n)),
                e.moveMesh(t.upperBody, 5 * t.leanAnimX * n, t.height - s.cameraHeight - s.legHeight, Math.abs(1.8 * t.leanAnimX) * n),
                e.rotateMesh(t.weaponMeshes[t.weaponIndex], (.3 * i + t.leanAnimX * (t.weapon.leanMlt || 0)) * n, (t.recoilAnimY * (t.weapon.recoilY || 0) + 1.8 * t.leanAnimY - .15 * o - .2 * t.bobAnimY) * n, c + (t.leanAnimZ + .3 * i) * n),
                e.moveMesh(t.weaponMeshes[t.weaponIndex], (1.2 * t.leanAnimZ + i) * t.aimVal * n + l - (l - t.weapon.xOrg) * a, (t.landAnim + (o + 5 * t.leanAnimY)) * n + t.weapon.yOff - (t.weapon.yOff - t.weapon.yOrg) * a, t.weapon.zOff - (t.weapon.zOff - t.weapon.zOrg) * a + (t.recoilAnim * (t.weapon.recoilZ || 0) + t.bobAnimZ) * r)
            }
        }
        ,
        this.updateHeight = function(t) {
            var n = s.crouchDst * t.crouchVal;
            if (e && !t.isYou) {
                var r = s.crouchLean * t.crouchVal;
                e.rotateMesh(t.lowerBody, 0, r + .5 * t.yDir, 0),
                t.upperBody.rotation.x -= r,
                e.moveMesh(t.lowerBody, 0, s.legHeight - n, 0);
                for (var i = 0; i < 4; ++i)
                    t.legMeshes[i].visible = i <= 1 ? !t.crouchVal : !!t.crouchVal
            } else
                t.height = s.playerHeight - n
        }
        ,
        this.generateMeshes = function(n, i) {
            var a = t.classes[n.classIndex].colors;
            if (n.objInstances = e.genObj3D(n.x, n.y, n.z),
            n.lowerBody = e.genObj3D(0, s.legHeight, 0),
            i || n.lowerBody.add(e.genBody(a[1], a[2], a[4], a[0])),
            n.upperBody = e.genObj3D(0, 0, 0),
            n.lowerBody.add(n.upperBody),
            !i)
                for (var c = 0; c < 4; ++c)
                    n.legMeshes.push(e.genLeg(1 == c || 3 == c, a[2], a[3], c > 1)),
                    c >= 2 && e.rotateMesh(n.legMeshes[c], 2 == c ? -Math.PI / 6 : Math.PI / 8, 0, 0),
                    n.legMeshes[c].visible = c <= 1,
                    n.objInstances.add(n.legMeshes[c]);
            for (c = 0; c < n.ammos.length; ++c) {
                var h = e.genObj3D(0, 0, 0)
                  , l = t.weapons[n.loadout[c]];
                i && (h.muzzle = new r.Sprite,
                h.muzzle.visible = !1,
                h.muzzle.static = !0,
                o.particles.push(h.muzzle),
                h.add(h.muzzle),
                h.casing = e.genObj3D(0, l.caseYOff || 0, l.caseZOff || 0),
                h.add(h.casing)),
                h.add(e.genArms(l, a[1], a[5], a[0], i)),
                n.weaponMeshes.push(h),
                n.weaponMeshes[c].visible = !1,
                n.upperBody.add(n.weaponMeshes[c]),
                e.loadMesh({
                    src: "weapons/" + l.src,
                    uv2: !0,
                    ao: i,
                    emissive: l.transp ? 16777215 : null
                }, 0, 0, 0, Math.PI / 2, l.scale, n.weaponMeshes[c])
            }
            n.objInstances.add(n.lowerBody),
            e.add(n.objInstances)
        }
        ,
        this.hideAll = function() {
            for (var t = 0; t < this.list.length; ++t)
                this.list[t].active && this.list[t].objInstances && (this.list[t].forcePos = !this.list[t].objInstances.visible,
                this.list[t].isYou || (this.list[t].objInstances.visible = !1))
        }
        ,
        this.clear = function() {
            if (e)
                for (var t = 0; t < this.list.length; ++t)
                    this.disposeMesh(this.list[t]);
            this.list.length = 0
        }
        ,
        this.disposeMesh = function(t) {
            e.remove(t.objInstances),
            t.objInstances = null,
            t.weaponMeshes.length = 0,
            t.legMeshes.length = 0;
            var n = document.getElementById("pInfo" + t.sid);
            n && n.parentNode.removeChild(n)
        }
        ,
        this.add = function(n, r, i, o, c, h, l, u) {
            for (var p, d = 0; d < this.list.length; ++d)
                if (this.list[d].id == n) {
                    p = this.list[d];
                    break
                }
            return p || ((p = new function(t, e, n, r) {
                var i;
                this.id = t,
                this.sentTo = [],
                this.inputs = [],
                this.spins = [],
                this.stateHistory = [],
                this.weaponMeshes = [],
                this.legMeshes = [],
                this.lastInput = [],
                this.reloads = [],
                this.ammos = [],
                this.ping = 0,
                this.pings = [],
                this.score = 0,
                this.kills = 0,
                this.deaths = 0,
                this.level = 0,
                this.highest = 0,
                this.deltaAdd = 0,
                this.deltaDiv = 1,
                this.sprayIndex = 0,
                this.lastSpray = 0,
                this.playTime = 0,
                this.init = function(t, e, n, i, o) {
                    this.x = t,
                    this.y = e,
                    this.z = n,
                    this.stepSrc = null,
                    this.name = i || "unknown",
                    this.xVel = 0,
                    this.yVel = 0,
                    this.zVel = 0,
                    this.spins.length = 0,
                    this.xDir = 0,
                    this.yDir = 0,
                    this.hitTimer = 0,
                    this.ticker = 0,
                    this.spread = 0,
                    this.spreadPlus = 0,
                    this.aimVal = 1,
                    this.aimDir = 0,
                    this.aimTime = 0,
                    this.streak = 0,
                    this.lastKill = 0,
                    this.stateHistory.length = 0,
                    this.lastInput.length = 0,
                    this.dmgReceived = {},
                    this.landAnim = 0,
                    this.landVelocity = 0,
                    this.leanAnimX = 0,
                    this.leanAnimY = 0,
                    this.leanAnimZ = 0,
                    this.bobAnimZ = 0,
                    this.bobAnimY = 0,
                    this.stepVal = 0,
                    this.stepDir = 1,
                    this.recoilAnim = 0,
                    this.recoilAnimY = 0,
                    this.recoilForce = 0,
                    this.crouchVal = 0,
                    this.onGround = !0,
                    this.onLadder = !1,
                    this.rampFix = null,
                    this.fixRamp = !1,
                    this.didJump = !1,
                    this.didShoot = !1,
                    this.airTime = 0,
                    this.height = r.playerHeight,
                    this.headScale = r.cameraHeight,
                    this.scale = r.playerScale,
                    this.active = !0,
                    this.interpolate = !1,
                    this.isYou = o,
                    this.sentTo.length = 0,
                    this.inputSN = 0,
                    this.weaponIndex = 0,
                    this.swapTime = 0,
                    this.recon = !1,
                    this.inView = !1
                }
                ,
                this.setClass = function(t, e) {
                    this.classIndex = e,
                    this.reloads.length = 0,
                    this.ammos.length = 0,
                    this.loadout = t.classes[e].loadout,
                    this.speed = t.classes[e].speed || 1;
                    for (var n = 0; n < this.loadout.length; ++n)
                        this.reloads.push(0),
                        this.ammos.push(t.weapons[this.loadout[n]].ammo);
                    this.reloadTimer = 0,
                    this.maxHealth = t.classes[e].health,
                    this.health = this.maxHealth
                }
                ,
                this.resetInputs = function() {
                    this.inputs.length = 0
                }
                ,
                this.processInput = function(t, o, a) {
                    this.recon = a;
                    var s = Math.min(t[1], r.dltMx) / this.deltaDiv;
                    this.inputSN = t[0];
                    var c = n.getAngleDist(t[2], this.xDir);
                    e.saveSpin(this, c);
                    var h = !a && this.isYou;
                    if (h && (this.leanAnimX -= c * r.leanSens,
                    this.leanAnimX = n.limit(this.leanAnimX, r.leanMax),
                    this.leanAnimY -= n.getAngleDist(t[3], this.yDir) * r.leanSens,
                    this.leanAnimY = n.limit(this.leanAnimY, r.leanMax),
                    this.leanAnimX && (this.leanAnimX *= Math.pow(r.leanPull, s)),
                    this.leanAnimY && (this.leanAnimY *= Math.pow(r.leanPull, s)),
                    this.leanAnimZ && (this.leanAnimZ *= Math.pow(r.leanPullZ, s)),
                    this.bobAnimZ && (this.bobAnimZ *= Math.pow(r.bobPullZ, s)),
                    this.bobAnimY && (this.bobAnimY *= Math.pow(r.bobPullY, s)),
                    this.landAnim += this.landVelocity,
                    this.landVelocity ? (this.landVelocity *= Math.pow(r.landPullV, s),
                    this.landVelocity = n.cropVal(this.landVelocity, .01)) : this.landAnim && (this.landAnim *= Math.pow(r.landPull, s))),
                    t[10] && e.swapWeapon(this, t[10]),
                    a || (this.recoilForce && (this.recoilAnim += this.recoilForce * s,
                    this.recoilAnimY += this.recoilForce * s,
                    this.recoilForce *= Math.pow(this.weapon.recoverF, s)),
                    this.recoilAnim && (this.recoilAnim *= Math.pow(this.weapon.recover, s)),
                    this.recoilAnimY && (this.recoilAnimY *= Math.pow(this.weapon.recoverY || this.weapon.recover, s))),
                    this.xDir = t[2].round(3),
                    this.yDir = t[3].round(3),
                    this.oldX = this.x,
                    this.oldY = this.y,
                    this.oldZ = this.z,
                    this.weapon.zoom) {
                        var l = this.reloadTimer <= 0 && this.swapTime <= 0;
                        t[6] && this.aimVal > 0 && l ? (this.aimDir = 0,
                        this.aimVal -= 1 / (this.weapon.aimSpeed / s),
                        this.aimVal <= 0 && (this.aimVal = 0,
                        this.isYou && !a && e.toggleAim(this, 1)),
                        !this.isYou || a || this.weapon.scope || e.updateAim(this, 1 - this.aimVal)) : (!l || !t[6] && this.aimVal < 1) && (this.aimDir = 1,
                        this.aimVal || !this.isYou || a || e.toggleAim(this, 0),
                        this.aimVal += 1 / (this.weapon.aimSpeed / s),
                        this.aimVal >= 1 && (this.aimVal = 1),
                        !this.isYou || a || this.weapon.scope || e.updateAim(this, 1 - this.aimVal)),
                        0 == this.aimVal ? this.aimTime += s : this.aimTime = 0
                    }
                    t[8] && this.crouchVal < 1 && !this.onLadder ? (this.crouchVal += r.crouchSpeed * s,
                    this.crouchVal >= 1 && (this.crouchVal = 1),
                    this.onGround ? h && (this.bobAnimY -= r.crouchAnim * s) : this.y += r.crouchSpeed * s) : !t[8] && this.crouchVal > 0 && (this.crouchVal -= r.crouchSpeed * s,
                    this.crouchVal <= 0 && (this.crouchVal = 0),
                    this.onGround ? h && (this.bobAnimY += r.crouchAnim * s) : this.y -= r.crouchSpeed * s),
                    this.crouchVal && (this.crouchVal = this.crouchVal.round(3)),
                    e.updateHeight(this);
                    var u = this.onGround || this.onLadder
                      , p = s * (u ? r.playerSpeed * this.speed : r.airSpeed) * (this.aimVal ? 1 : r.aimSlow) * (this.crouchVal ? r.crouchSlow : 1) * this.weapon.spdMlt
                      , d = this.onLadder ? r.ladderDecel : this.onGround ? r.groundDecel : r.airDecel;
                    this.onGround && (this.didJump && !t[7] && (this.didJump = !1),
                    !this.didJump && t[7] && e.jump(this)),
                    u || (this.yVel -= s * (r.gravity * o.config.gravMlt));
                    var f = r.movDirs[t[4]];
                    void 0 !== f && (this.xVel += p * Math.cos(f - this.xDir),
                    this.zVel += p * Math.sin(f - this.xDir)),
                    this.xVel && (this.x += this.xVel * s,
                    this.xVel *= Math.pow(d, s),
                    this.xVel = n.cropVal(this.xVel, r.decelMin)),
                    this.yVel && (this.y += this.yVel * s,
                    this.yVel *= Math.pow(d, s),
                    this.yVel = n.cropVal(this.yVel, r.decelMin)),
                    this.zVel && (this.z += this.zVel * s,
                    this.zVel *= Math.pow(d, s),
                    this.zVel = n.cropVal(this.zVel, r.decelMin));
                    var m = this.onGround && !this.didJump
                      , g = !1;
                    this.onGround = !1,
                    this.onLadder = !1;
                    for (var v = 0; v < o.map.manager.objects.length; ++v)
                        if (i = o.map.manager.objects[v],
                        this.collides(i))
                            if (i.ladder) {
                                if (this.y < i.y + i.height && 0 == this.crouchVal && (this.yVel = 0,
                                this.onLadder = !0,
                                this.stepSrc = null,
                                void 0 !== f)) {
                                    var y = (Math.abs(n.getAngleDist(i.dir, f - this.xDir)) - Math.PI / 2) / (Math.PI / 2);
                                    y > 0 && (this.y += r.ladderSpeed * this.weapon.spdMlt * s * y,
                                    this.y <= i.y - i.height ? this.y = i.y - i.height : this.y >= i.y + i.height && (this.y = i.y + i.height))
                                }
                            } else if (i.ramp) {
                                if (this.y < i.y + i.height) {
                                    var x = Math.max(0, Math.min(1, n.progressOnLine(i.ramp.sX, i.ramp.sZ, i.ramp.eX, i.ramp.eZ, this.x + this.scale * Math.cos(i.dir), this.z + this.scale * Math.sin(i.dir))))
                                      , w = i.y - i.height + 2 * i.height * x;
                                    (this.y <= w || m) && (!a && this.oldY > this.y && e.resetStep(this),
                                    this.y = w,
                                    this.yVel = 0,
                                    this.onGround = !0,
                                    g = !0,
                                    this.rampFix = i.y - i.height + 2 * i.height * Math.round(x))
                                }
                            } else
                                this.y < i.y + i.height && i.y + i.height - this.y <= r.climbHeight && this.oldY < i.y + i.height && m ? (this.y += .2 * (i.y + i.height - this.y),
                                this.onGround = !0) : this.oldY >= i.y + i.height ? (this.stepSrc = i.stepSrc,
                                !a && this.oldY > this.y && e.resetStep(this),
                                this.y = i.y + i.height,
                                this.yVel = 0,
                                this.onGround = !0) : this.oldX - this.scale >= i.x + i.width ? (this.x = i.x + i.width + this.scale,
                                this.xVel = 0) : this.oldX + this.scale <= i.x - i.width ? (this.x = i.x - i.width - this.scale,
                                this.xVel = 0) : this.oldZ - this.scale >= i.z + i.length ? (this.z = i.z + i.length + this.scale,
                                this.zVel = 0) : this.oldZ + this.scale <= i.z - i.length ? (this.z = i.z - i.length - this.scale,
                                this.zVel = 0) : this.oldY + this.height <= i.y - i.height && (this.y = i.y - i.height - this.height,
                                this.yVel = 0);
                    if (!this.didJump && null != this.rampFix && Math.abs(this.y - this.rampFix) <= r.climbHeight ? g || (this.y = this.rampFix,
                    this.onGround = !0,
                    this.yVel = 0,
                    this.rampFix = null) : this.rampFix = null,
                    this.onGround ? this.airTime = 0 : this.airTime += s,
                    !a) {
                        var b = n.getDistance3D(this.oldX, this.oldY, this.oldZ, this.x, this.y, this.z);
                        if (this.isYou && (this.onLadder && (b *= 1.4),
                        n.getDirection(this.oldX, this.oldZ, this.x, this.z),
                        this.bobAnimZ += b * r.bobMltZ,
                        this.bobAnimY += (this.oldY - this.y) * r.bobMltY,
                        u && void 0 !== f ? (e.playerStep(this, b),
                        this.leanAnimZ -= b * r.leanMltZ * Math.cos(f)) : this.stepVal *= Math.pow(r.stepPull, s)),
                        this.spreadPlus += b * r.spreadMove + Math.abs(this.oldY - this.y) * r.spreadFall,
                        this.spreadPlus *= Math.pow(r.spreadRecover, s),
                        this.spread = Math.max(this.weapon.minSpread || 0, (this.weapon.spread - this.weapon.spread * r.crouchSpread * this.crouchVal + this.recoilAnim * r.spreadMlt + this.spreadPlus) * this.aimVal),
                        t[9] && e.reload(this),
                        this.reloadTimer > 0) {
                            var M = this.reloadTimer;
                            this.reloadTimer -= s,
                            this.isYou && M >= this.weapon.reload / 2 && this.reloadTimer < this.weapon.reload / 2 && e.endReload(),
                            this.reloadTimer <= 0 && (this.reloadTimer = 0,
                            this.didShoot = !1,
                            this.ammos[this.weaponIndex] = this.weapon.ammo,
                            e.updatePlayerAmmo(this))
                        }
                        for (this.swapTime > 0 && (this.swapTime -= s,
                        this.swapTime < 0 && (this.swapTime = 0)),
                        v = 0; v < this.reloads.length; ++v)
                            this.reloads[v] > 0 && (this.reloads[v] -= s,
                            this.reloads[v] < 0 && (this.reloads[v] = 0));
                        var _ = !this.weapon.nAuto && t[5];
                        this.didShoot && !t[5] && (this.didShoot = !1),
                        !this.didShoot && t[5] && (_ = !0),
                        _ && this.reloads[this.weaponIndex] <= 0 && this.swapTime <= 0 && this.reloadTimer <= 0 && (this.ammos[this.weaponIndex] > 0 ? e.shoot(this) : e.reload(this))
                    }
                }
                ,
                this.collides = function(t) {
                    return this.x - this.scale < t.x + t.width && this.x + this.scale > t.x - t.width && this.z - this.scale < t.z + t.length && this.z + this.scale > t.z - t.length && this.y <= t.y + t.height && this.y + this.height >= t.y - t.height
                }
                ,
                this.update = function(t, i) {
                    if (this.active) {
                        if (this.inputs.length) {
                            for (var o = 0; o < this.inputs.length; ++o)
                                this.processInput(this.inputs[o], t);
                            this.resetInputs()
                        }
                        if (this.interpolate) {
                            this.dt += i;
                            var a = Math.min(1.6, this.dt / (r.serverSendRate * r.interpolation));
                            this.oldX = this.x,
                            this.oldY = this.y,
                            this.oldZ = this.z,
                            this.x = this.x1 + (this.x2 - this.x1) * a,
                            this.y = this.y1 + (this.y2 - this.y1) * a,
                            this.z = this.z1 + (this.z2 - this.z1) * a,
                            this.onGround && e.playerStep(this, n.getDistance(this.oldX, this.oldZ, this.x, this.z)),
                            this.xDir = Math.lerpAngle(this.xDir2, this.xDir1, Math.min(1, a)),
                            this.yDir = Math.lerpAngle(this.yDir2, this.yDir1, Math.min(1, a))
                        }
                    }
                }
            }
            (n,this,a,s)).sid = r || a.generateSID(this.list),
            this.list.push(p)),
            h || (h = "Guest_" + p.sid),
            p.init(i, o, c, h, u),
            p.setClass(t, l),
            this.setTeam(p, t.mode),
            e && this.generateMeshes(p, u),
            this.swapWeapon(p, 0, !0),
            p
        }
        ,
        this.remove = function(e) {
            var n = this.indexBySid(e);
            if (n >= 0) {
                this.list[n].room;
                var r = this.list[n].id;
                if (this.list[n].objInstances && this.disposeMesh(this.list[n]),
                this.list.splice(n, 1),
                c) {
                    for (var i = this.list.length - 1; i >= 0; --i)
                        (n = this.list[i].sentTo.indexOf(r)) >= 0 && this.list[i].sentTo.splice(n, 1);
                    c.broadcast("game" + t.sid, "2", e),
                    this.syncLeaders()
                }
            }
        }
        ;
        var d = [0, 1, 2];
        this.getStepSound = function() {
            var t = a.randInt(0, d.length - 1)
              , e = d[t];
            return d.splice(t, 1),
            d.length <= 0 && d.push(0, 1, 2),
            e
        }
        ,
        this.playerStep = function(e, n) {
            if (n && (!e.isYou && e.crouchVal && (n *= 1.6),
            e.stepVal += n * s.stepMlt * e.stepDir,
            e.stepVal >= Math.PI / 2 && 1 == e.stepDir || e.stepVal <= -Math.PI / 2 && -1 == e.stepDir)) {
                if (i) {
                    var r = .65 * (e.crouchVal < 1 ? 1 : e.isYou ? .5 : 0)
                      , o = e.crouchVal < 1 ? 1 : .8
                      , c = e.stepSrc ? "_" + e.stepSrc : "";
                    e.isYou ? i.play("step_" + this.getStepSound() + c, r, !1, o) : r && t.playerSound("step_" + a.randInt(0, 2) + c, 0, r, e, o, 10)
                }
                e.stepDir *= -1
            }
        }
        ,
        this.resetStep = function(t) {
            if (i) {
                var e = t.stepSrc ? "_" + t.stepSrc : "";
                i.play("step_0" + e),
                t.isYou && (t.landVelocity += t.yVel)
            }
        }
        ,
        this.jump = function(e) {
            e.didJump = !0;
            var n = s.jumpVel * t.config.jumpMlt
              , r = s.jumpPush * t.config.jumpMlt;
            e.yVel += (n - n * (s.crouchJump * e.crouchVal)) * e.weapon.spdMlt * (e.aimVal ? 1 : s.aimJumpSlow);
            var o = a.getDistance(0, 0, e.xVel, e.zVel);
            e.xVel -= r * o * Math.sin(e.xDir),
            e.zVel -= r * o * Math.cos(e.xDir),
            i && !e.recon && i.play("jump_0", .1)
        }
        ,
        this.updateAim = function(t, n) {
            e.zoom(1 + (t.weapon.zoom - 1) * n)
        }
        ,
        this.toggleAim = function(t, n) {
            i && !t.recon && i.play("aim_" + n, .1),
            n || (e.zoom(1),
            aimRecticle.style.display = "none"),
            t.weapon.scope && (e.zoom(n ? t.weapon.zoom : 1),
            t.weaponMeshes[t.weaponIndex].visible = !n,
            aimRecticle.style.display = n ? "block" : "none")
        }
        ,
        this.reload = function(t) {
            !t.reloadTimer && t.ammos[t.weaponIndex] < t.weapon.ammo && (i && i.play("reload_1", .25),
            t.reloadTimer = t.weapon.reload)
        }
        ,
        this.endReload = function() {
            i && i.play("reload_2", .25)
        }
        ,
        this.updatePlayerAmmo = function(t) {
            t.isYou && (ammoVal.innerHTML = t.ammos[t.weaponIndex] + " <span id='ammoMax'> | " + t.weapon.ammo + "</span>",
            t.ammos[t.weaponIndex] <= 0 ? (reloadMsg.innerHTML = "[R] Reload",
            reloadMsg.style.display = "block") : reloadMsg.style.display = "none")
        }
        ;
        var f = [];
        this.shoot = function(e) {
            if (e.reloads[e.weaponIndex] = e.weapon.rate,
            e.ammos[e.weaponIndex]--,
            e.didShoot = !0,
            this.updatePlayerAmmo(e),
            t.playSound(e.weapon.sound, .85, e),
            e.recoilForce += e.weapon.recoil * (1 - .3 * e.crouchVal),
            e.isYou && (e.leanAnimX += a.randInt(0, 1) ? -e.weapon.recoilR : e.weapon.recoilR),
            e.isYou) {
                var n = e.weaponMeshes[e.weaponIndex];
                if (n.muzzle.visible = !0,
                o.setMaterial(n.muzzle, 2, 1, !0),
                n.muzzle.init(0, e.weapon.muzOffY || 0, -e.weapon.muzOff, 0, 0, 0, 3 * (e.weapon.muzMlt || 1), 50),
                !e.weapon.nCase) {
                    var r = e.weaponMeshes[e.weaponIndex].casing.getWorldPosition();
                    i.play("case_" + a.randInt(0, 1), .2),
                    0 == e.aimVal && e.weapon.scope || o.physObj(r.x, r.y, r.z, e.xDir - Math.PI / 2, Math.PI / 5 * a.randFloat(.8, 1.2), 25, e.weapon.caseInd || 1, e)
                }
            }
            for (var h = 0; h < (e.weapon.shots || 1); ++h) {
                var u = (e.spread + (e.weapon.innac || 0)) * s.spreadAdj
                  , p = e.xDir + a.randFloat(-u, u)
                  , d = e.yDir + e.recoilAnimY * s.recoilMlt * (cheatSettings.noRecoil ? 0 : 1) + a.randFloat(-u, u);
                f.length = 0;
                for (var m = 0, g = 1 / (e.weapon.range * Math.sin(p + Math.PI) * Math.cos(d)), v = 1 / (e.weapon.range * Math.cos(p + Math.PI) * Math.cos(d)), y = 1 / (e.weapon.range * Math.sin(d)), x = 0; x < t.map.manager.objects.length; ++x)
                    (l = t.map.manager.objects[x]).noShoot || (m = a.lineInRect(e.x, e.z, e.y + e.height - s.cameraHeight, g, v, y, l.x - l.width, l.z - l.length, l.y - l.height, l.x + l.width, l.z + l.length, l.y + l.height)) && m <= 1 && f.push({
                        obj: l,
                        dst: m
                    });
                if (c)
                    for (x = 0; x < this.list.length; ++x)
                        !this.list[x].active || e == this.list[x] || e.team && e.team == this.list[x].team || (l = this.fetchState(this.list[x], e.ping)) && (m = a.lineInRect(e.x, e.z, e.y + e.height - s.cameraHeight, g, v, y, l.x - this.list[x].scale - s.hitBoxPad, l.z - this.list[x].scale - s.hitBoxPad, l.y, l.x + this.list[x].scale + s.hitBoxPad, l.z + this.list[x].scale + s.hitBoxPad, l.y + this.list[x].height + s.hitBoxPad)) && m <= 1 && f.push({
                            player: !0,
                            obj: this.list[x],
                            dst: m
                        });
                var w = e.weapon.range;
                if (f.length) {
                    f.sort(a.orderByDst);
                    var b = e.weapon.dmg;
                    for (x = 0; x < f.length && (l = f[x],
                    w = e.weapon.range * l.dst,
                    c); ++x) {
                        var M = b - e.weapon.dmgDrop * l.dst
                          , _ = !1
                          , E = !1;
                        if (l.player) {
                            var S = e.y + e.height - s.cameraHeight + w * Math.sin(d);
                            _ = l.obj.y + l.obj.height - S < s.headScale,
                            E = l.obj.y + s.legHeight > S,
                            M *= _ && !e.weapon.noHeadShot ? 1.5 : 1,
                            M *= E ? .5 : 1
                        }
                        if (l.player || l.obj.dummy) {
                            if (this.changeHealth(l.obj, e, M)) {
                                var T = {
                                    dst: l.dst,
                                    headShot: _
                                };
                                this.kill(l.obj, e, T)
                            }
                            b -= void 0 != e.weapon.pierce ? e.weapon.dmg * s.materialDens.flesh * e.weapon.pierce : b
                        } else {
                            if (!s.materialDens[l.obj.src])
                                break;
                            b -= void 0 != e.weapon.pierce ? e.weapon.dmg * s.materialDens[l.obj.src] * e.weapon.pierce : b
                        }
                        if (b <= 0)
                            break
                    }
                }
                w -= .12;
                var A = e.x + w * Math.sin(p + Math.PI) * Math.cos(d)
                  , L = (S = e.y + e.height - s.cameraHeight + w * Math.sin(d),
                e.z + w * Math.cos(p + Math.PI) * Math.cos(d))
                  , R = 0
                  , P = 0;
                if (f.length && (S >= l.obj.y + l.obj.height ? P = Math.PI / 2 : S <= l.obj.y - l.obj.height ? P = -Math.PI / 2 : A <= l.obj.x - l.obj.width ? R = -Math.PI / 2 : A >= l.obj.x + l.obj.width ? R = Math.PI / 2 : L <= l.obj.z - l.obj.length && (R = Math.PI),
                c || o.effect(A, S, L, R, P, 0)),
                c && (!f.length || !l.player))
                    for (x = 0; x < this.list.length; ++x)
                        this.list[x].active && this.list[x] != e && (f.length ? c.send(this.list[x].id, "9", e.sid, Math.round(A), Math.round(S), Math.round(L), R.round(1), P.round(1)) : c.send(this.list[x].id, "9", e.sid, Math.round(A), Math.round(S), Math.round(L)));
                if (e.isYou && w >= s.tracerMinDst) {
                    var C = (r = e.weaponMeshes[e.weaponIndex].muzzle.getWorldPosition()).x
                      , I = r.y
                      , O = r.z;
                    a.getDistance3D(C, I, O, A, S, L),
                    R = a.getDirection(O, C, L, A),
                    P = a.getDirection(a.getDistance(C, O, A, L), S, 0, I),
                    o.physObj(C, I, O, R, P, Math.min(w, s.tracerMaxDst), 0)
                }
            }
        }
        ,
        this.spray = function(e) {
            if (t.now - e.lastSpray >= s.sprayTimer) {
                f.length = 0;
                for (var n = 0, r = 1 / (s.sprayRange * Math.sin(e.xDir + Math.PI) * Math.cos(e.yDir)), i = 1 / (s.sprayRange * Math.cos(e.xDir + Math.PI) * Math.cos(e.yDir)), o = 1 / (s.sprayRange * Math.sin(e.yDir)), h = 0; h < t.map.manager.objects.length; ++h)
                    (l = t.map.manager.objects[h]).noShoot || (n = a.lineInRect(e.x, e.z, e.y + e.height - s.cameraHeight, r, i, o, l.x - l.width, l.z - l.length, l.y - l.height, l.x + l.width, l.z + l.length, l.y + l.height)) && n <= 1 && f.push({
                        obj: l,
                        dst: n
                    });
                if (f.length && (f.sort(a.orderByDst),
                l = f[0].obj)) {
                    var u = s.sprayRange * f[0].dst - .1
                      , p = e.y + e.height - s.cameraHeight + u * Math.sin(e.yDir)
                      , d = e.x + u * Math.sin(e.xDir + Math.PI) * Math.cos(e.yDir)
                      , m = e.z + u * Math.cos(e.xDir + Math.PI) * Math.cos(e.yDir)
                      , g = 0
                      , v = 0;
                    p >= l.y + l.height ? v = -90 : p <= l.y - l.height ? v = 90 : d <= l.x - l.width ? g = -90 : d >= l.x + l.width ? g = 90 : m <= l.z - l.length && (g = 180);
                    var y = s.sprayScale / 2;
                    if (v) {
                        if (l.width < y || l.length < y)
                            return;
                        m - y < l.z - l.length ? m = l.z - l.length + y : m + y > l.z + l.length && (m = l.z + l.length - y),
                        d - y < l.x - l.width ? d = l.x - l.width + y : d + y > l.x + l.width && (d = l.x + l.width - y)
                    } else {
                        if (l.height < y)
                            return;
                        if (90 == g || -90 == g) {
                            if (l.length < y)
                                return;
                            m - y < l.z - l.length ? m = l.z - l.length + y : m + y > l.z + l.length && (m = l.z + l.length - y)
                        } else {
                            if (l.width < y)
                                return;
                            d - y < l.x - l.width ? d = l.x - l.width + y : d + y > l.x + l.width && (d = l.x + l.width - y)
                        }
                        p + y > l.y + l.height && (p = l.y + l.height - y)
                    }
                    e.lastSpray = t.now,
                    t.playSound("spray", .4, e, !0),
                    c.broadcast("game" + t.sid, "sp", e.sid, e.sprayIndex, d.round(2), p.round(2), m.round(2), g, v)
                }
            }
        }
        ;
        var m = [];
        this.syncLeaders = function() {
            u = this.list.slice().sort(a.orderByScore),
            m.length = 0;
            for (var e = 0; e < u.length; ++e)
                m.push(u[e].sid, u[e].name, u[e].team, u[e].score);
            c.broadcast("game" + t.sid, "7", m)
        }
        ,
        this.score = function(t, e) {
            t.score += e,
            e > t.highest && (t.highest = e),
            c.send(t.id, "5", e),
            this.syncLeaders()
        }
        ,
        this.tickPlayer = function(t, e) {
            t.playTime += e,
            t.hitTimer > 0 && (t.hitTimer -= e),
            t.ticker -= e,
            t.ticker <= 0 && (t.ticker = 500,
            t.hitTimer <= 0 && this.changeHealth(t, null, -s.regenVal))
        }
        ,
        this.changeHealth = function(e, n, r) {
            if (!(r < 0 && e.health == e.maxHealth || e.team && n && e.team == n.team && r > 0)) {
                if (n && c.send(n.id, "4", e.sid, Math.round(r)),
                e.dummy)
                    return !0;
                r > 0 && (e.hitTimer = s.regenDelay),
                e.health -= r,
                e.health = Math.max(Math.min(e.maxHealth, e.health), 0),
                n ? (c.send(e.id, "h", Math.ceil(e.health), null, Math.round(n.x), Math.round(n.z)),
                e.dmgReceived[n.id] ? (e.dmgReceived[n.id].val += r,
                e.dmgReceived[n.id].time = t.now) : e.dmgReceived[n.id] = {
                    time: t.now,
                    val: r
                }) : c.send(e.id, "h", Math.ceil(e.health));
                for (var i = 0; i < this.list.length; ++i)
                    this.list[i] != e && c.send(this.list[i].id, "h", Math.ceil(e.health), e.sid);
                return e.health <= 0
            }
        }
        ,
        this.swapWeapon = function(n, r, i, o) {
            if (!(n.ammos.length <= 1 && r)) {
                var a = n.weaponIndex;
                if (r && (n.reloadTimer = 0,
                n.weaponIndex += r,
                n.didShoot = !1,
                n.weaponIndex < 0 && (n.weaponIndex = n.ammos.length - 1),
                n.weaponIndex > n.ammos.length - 1 && (n.weaponIndex = 0)),
                void 0 != o && (n.weaponIndex = o),
                n.weapon = t.weapons[n.loadout[n.weaponIndex]],
                e && (a != n.weaponIndex || i) && (n.weaponMeshes[a] && (n.weaponMeshes[a].visible = !1),
                n.weaponMeshes[n.weaponIndex] && (n.weaponMeshes[n.weaponIndex].visible = !0)),
                void 0 == o && (!e || n.isYou) && (n.swapTime = n.weapon.swapTime,
                n.isYou && (a != n.weaponIndex || i))) {
                    for (var s = "", c = n.ammos.length - 1; c >= 0; --c)
                        s += "<div class='weaponItem'><img style='opacity:" + (c == n.weaponIndex ? 1 : .7) + "' class='weaponIcon' src='./textures/weapons/" + t.weapons[n.loadout[c]].icon + ".png' /></div>";
                    weaponDisplay.innerHTML = s,
                    this.updatePlayerAmmo(n)
                }
            }
        }
        ,
        this.kill = function(e, n, r) {
            var i;
            if (e.dummy || (e.active = !1,
            e.isYou && this.toggleAim(e, 0),
            e.objInstances && this.disposeMesh(e)),
            c && (e.deaths++,
            n && (e.dummy || n.kills++,
            n.streak++,
            t.now - n.lastKill >= s.feedTimer && (n.streak = 0),
            n.lastKill = t.now,
            (i = p.reward(this, n, e, r)) && c.send(n.id, "6", i, r.headShot ? 1 : 0, n.kills),
            this.score(n, p.getScore(i))),
            !e.dummy))
                for (var o = 0; o < this.list.length; ++o)
                    t.mode.teams && e.dmgReceived[this.list[o].id] && n != this.list[o] && e.dmgReceived[this.list[o].id].val >= s.assistMin && t.now - e.dmgReceived[this.list[o].id].time <= s.assistTime && (this.score(this.list[o], s.assistScore),
                    c.send(this.list[o].id, "10")),
                    this.list[o] == e ? c.send(e.id, "3", e.sid, n ? n.sid : 0, [n ? n.loadout[n.weaponIndex] : -1, i ? p.getScore(i) : 0]) : c.send(this.list[o].id, "3", e.sid, n ? n.sid : 0)
        }
        ,
        this.indexBySid = function(t) {
            for (var e = 0; e < this.list.length; ++e)
                if (this.list[e].sid == t)
                    return e;
            return -1
        }
        ,
        this.findBySid = function(t) {
            for (var e = 0; e < this.list.length; ++e)
                if (this.list[e].sid === t)
                    return this.list[e];
            return null
        }
    }
}
, function(t, e) {
    t.exports = [{
        name: "Dummy",
        opacity: 1
    }, {
        name: "Target",
        opacity: .7
    }, {
        name: "Vertix",
        opacity: .7
    }]
}
, function(t, e) {
    t.exports = [{
        name: "Triggerman",
        loadout: [2, 1],
        colors: [10975328, 4013373, 2302755, 2631720, 7098434, 12566463],
        health: 100,
        speed: 1.05
    }, {
        name: "Hunter",
        loadout: [0, 1],
        colors: [10975328, 8083261, 6506290, 2631720, 6506290, 6506290],
        health: 60,
        speed: 1
    }, {
        name: "Run N Gun",
        loadout: [3],
        colors: [10975328, 4088706, 3099491, 2631720, 6506290, 3099491],
        health: 80,
        speed: 1.1
    }, {
        name: "Spray N Pray",
        loadout: [4],
        colors: [10975328, 5793865, 4806204, 2631720, 2631720, 4806204],
        health: 150,
        speed: 1
    }, {
        name: "Vince",
        loadout: [5, 1],
        colors: [8412234, 5526119, 4144461, 2631720, 2631720, 4144461],
        health: 100,
        speed: 1
    }, {
        name: "Detective",
        loadout: [6],
        colors: [10975328, 7360054, 6308654, 2631720, 6506290, 6308654],
        health: 100,
        speed: 1
    }, {
        name: "Marksman",
        loadout: [7],
        colors: [10975328, 5793865, 4806204, 2631720, 2631720, 4806204],
        health: 100,
        speed: 1
    }]
}
, function(t, e) {
    t.exports = [{
        name: "Sniper Rifle",
        src: "weapon_1",
        icon: "icon_1",
        sound: "weapon_1",
        nAuto: !0,
        type: 0,
        scope: !0,
        swapTime: 400,
        aimSpeed: 120,
        spdMlt: .85,
        ammo: 3,
        reload: 1500,
        dmg: 100,
        pierce: .2,
        range: 1e3,
        dmgDrop: 0,
        scale: 1.3,
        leftHoldY: -.8,
        rightHoldY: -.8,
        leftHoldZ: 2.1,
        rightHoldZ: 0,
        xOff: .7,
        yOff: -.5,
        zOff: -2.4,
        xOrg: 0,
        yOrg: -.33,
        zOrg: -1.2,
        muzOff: 5.5,
        muzMlt: 1.4,
        rate: 900,
        spread: 260,
        zoom: 2.7,
        leanMlt: 1,
        recoil: .008,
        recoilR: .02,
        recover: .993,
        recoverY: .997,
        recoverF: .975,
        recoilY: 1.1,
        recoilZ: 3
    }, {
        name: "Pistol",
        src: "weapon_3",
        icon: "icon_3",
        sound: "weapon_3",
        transp: !0,
        nAuto: !0,
        kill: ["", 75],
        type: 1,
        swapTime: 200,
        aimSpeed: 120,
        spdMlt: 1.05,
        ammo: 10,
        reload: 700,
        dmg: 20,
        range: 500,
        dmgDrop: 10,
        scale: 1.22,
        leftHoldY: -.1,
        rightHoldY: .21,
        leftHoldZ: -.5,
        rightHoldZ: -.5,
        xOff: .7,
        yOff: -2,
        zOff: -4.5,
        xOrg: 0,
        yOrg: -1.09,
        zOrg: -4.25,
        caseZOff: .2,
        caseYOff: .85,
        muzOff: 1.5,
        muzOffY: .6,
        muzMlt: .95,
        rate: 150,
        spread: 90,
        zoom: 1.4,
        leanMlt: .3,
        recoil: .007,
        recoilR: .015,
        recover: .992,
        recoverF: .94,
        recoilY: 2.6,
        recoilZ: 6
    }, {
        name: "Assault Rifle",
        src: "weapon_2",
        icon: "icon_2",
        sound: "weapon_2",
        transp: !0,
        type: 0,
        swapTime: 300,
        aimSpeed: 140,
        spdMlt: 1,
        ammo: 30,
        reload: 1200,
        dmg: 22,
        pierce: 1,
        range: 700,
        dmgDrop: 10,
        scale: 1,
        leftHoldY: .07,
        rightHoldY: 0,
        rightHoldX: .2,
        leftHoldZ: 1,
        rightHoldZ: -.7,
        xOff: .95,
        yOff: -1.3,
        zOff: -3.5,
        xOrg: 0,
        yOrg: -.94,
        zOrg: -2.1,
        caseZOff: -1.5,
        caseYOff: .3,
        muzOff: 4.5,
        muzOffY: .5,
        rate: 110,
        spread: 120,
        minSpread: 5,
        zoom: 1.5,
        leanMlt: .3,
        recoil: .0032,
        recoilR: .014,
        recover: .99,
        recoverY: .998,
        recoverF: .975,
        recoilZ: 6.5
    }, {
        name: "Submachine Gun",
        src: "weapon_4",
        icon: "icon_4",
        sound: "weapon_4",
        transp: !0,
        type: 0,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 1.04,
        ammo: 24,
        reload: 1200,
        dmg: 18,
        pierce: 1,
        range: 500,
        dmgDrop: 12,
        scale: 1.6,
        leftHoldY: -.35,
        rightHoldY: -.45,
        leftHoldZ: 1.2,
        rightHoldZ: -.2,
        xOff: .95,
        yOff: -.95,
        zOff: -3,
        xOrg: 0,
        yOrg: -.62,
        zOrg: -2.2,
        caseYOff: -.15,
        caseZOff: -.4,
        muzOff: 2.4,
        muzOffY: .1,
        rate: 90,
        spread: 200,
        minSpread: 10,
        zoom: 1.4,
        recoil: .0035,
        recoilR: .01,
        recover: .99,
        recoverY: .995,
        recoverF: .975,
        recoilZ: 3
    }, {
        name: "Light Machine Gun",
        src: "weapon_7",
        icon: "icon_7",
        sound: "weapon_7",
        transp: !0,
        type: 0,
        swapTime: 800,
        aimSpeed: 200,
        spdMlt: .79,
        ammo: 100,
        reload: 2500,
        dmg: 22,
        pierce: 1,
        range: 700,
        dmgDrop: 10,
        scale: 1.9,
        leftHoldY: -.5,
        rightHoldY: -.55,
        rightHoldX: .1,
        leftHoldZ: 1.2,
        rightHoldZ: -.2,
        xOff: .95,
        yOff: -.95,
        zOff: -3,
        xOrg: 0,
        yOrg: -.3,
        zOrg: -2,
        caseInd: 2,
        caseZOff: -.2,
        caseYOff: -.25,
        muzOff: 3.9,
        rate: 120,
        spread: 300,
        minSpread: 15,
        zoom: 1.2,
        recoil: .0033,
        recoilR: .015,
        recover: .994,
        recoverY: .9975,
        recoverF: .975,
        recoilZ: 3.5
    }, {
        name: "Shotgun",
        src: "weapon_6",
        icon: "icon_6",
        sound: "weapon_6",
        nAuto: !0,
        nCase: !0,
        type: 0,
        swapTime: 300,
        aimSpeed: 180,
        spdMlt: 1,
        ammo: 2,
        shots: 5,
        reload: 900,
        dmg: 50,
        dmgDrop: 25,
        scale: 2,
        leftHoldY: -.4,
        rightHoldY: -.5,
        rightHoldX: 0,
        leftHoldZ: 2.2,
        rightHoldZ: .3,
        xOff: .95,
        yOff: -.95,
        zOff: -2,
        xOrg: 0,
        yOrg: -.4,
        zOrg: -1.5,
        muzOff: 5,
        muzMlt: 1.2,
        range: 240,
        rate: 400,
        innac: 110,
        spread: 120,
        minSpread: 20,
        zoom: 1.25,
        recoil: .013,
        recoilR: .015,
        recover: .994,
        recoverF: .975,
        recoilY: .8,
        recoilZ: 4
    }, {
        name: "Revolver",
        src: "weapon_5",
        icon: "icon_5",
        sound: "weapon_5",
        nAuto: !0,
        nCase: !0,
        transp: !0,
        kill: ["", 50],
        type: 1,
        swapTime: 200,
        aimSpeed: 120,
        spdMlt: 1.04,
        ammo: 6,
        reload: 900,
        dmg: 61,
        pierce: .85,
        dmgDrop: 10,
        scale: 1.7,
        leftHoldY: -.05,
        rightHoldY: .05,
        leftHoldZ: -.75,
        rightHoldZ: -.75,
        xOff: .7,
        yOff: -2.1,
        zOff: -4.1,
        xOrg: 0,
        yOrg: -1.26,
        zOrg: -4.25,
        muzOff: 2.3,
        muzOffY: .6,
        muzMlt: .95,
        range: 700,
        rate: 300,
        spread: 100,
        zoom: 1.4,
        recoil: .011,
        recoilR: .02,
        recover: .992,
        recoverF: .94,
        recoilY: 2.5,
        recoilZ: 6
    }, {
        name: "Semi Auto",
        src: "weapon_8",
        icon: "icon_8",
        sound: "weapon_8",
        nAuto: !0,
        type: 0,
        scope: !0,
        swapTime: 400,
        aimSpeed: 160,
        spdMlt: 1,
        ammo: 6,
        reload: 1300,
        dmg: 50,
        pierce: .2,
        range: 1e3,
        dmgDrop: 0,
        scale: 1.3,
        leftHoldY: -.8,
        rightHoldY: -.8,
        leftHoldZ: 2.1,
        rightHoldZ: 0,
        xOff: .7,
        yOff: -.6,
        zOff: -2.4,
        xOrg: 0,
        yOrg: -.33,
        zOrg: -1.2,
        muzOff: 5.5,
        muzOffY: -.2,
        muzMlt: 1.4,
        rate: 350,
        spread: 300,
        zoom: 2.2,
        leanMlt: 1,
        recoil: .01,
        recoilR: .02,
        recover: .993,
        recoverY: .996,
        recoverF: .975,
        recoilY: .5,
        recoilZ: 1
    }]
}
, function(t, e, n) {
    var r = n(11);
    t.exports.obj = function(t, e, i, o, a, s, c, h) {
        var l, u;
        this.index = t,
        this.connectedClients = 0,
        this.password = void 0,
        this.map = new r.manager(a,c,o,e),
        this.weapons = n(56),
        this.classes = n(55),
        this.sprays = n(54),
        this.players = new (n(53).manager)(this,a,s,c,o,e,h),
        this.endData = [],
        this.applyConfig = function(t) {
            t = t || {},
            this.config = {};
            for (var n = 0; n < e.serverConfig.length; ++n) {
                var r = e.serverConfig[n]
                  , i = t[r.varN];
                o.isNumber(i) || (i = r.def),
                this.config[r.varN] = o.limitMM(i, r.min, r.max)
            }
            if (this.config.maps = t.maps,
            !o.isArray(this.config.maps) || !this.config.maps.length || this.config.maps.length > this.map.maps.length)
                for (this.config.maps = [],
                n = 0; n < this.map.maps.length; n++)
                    this.config.maps.push(n);
            else
                for (n = 0; n < this.config.maps.length; n++)
                    if (!this.map.maps[this.config.maps[n]]) {
                        this.config.maps = [0];
                        break
                    }
        }
        ,
        this.applyConfig(),
        this.customMap = function(t, n) {
            if (t)
                try {
                    var r = JSON.parse(t);
                    if (this.customMapData = t,
                    !n) {
                        if (!o.isString(r.name))
                            return "Missing map name.";
                        if (!o.isArray(r.modes) || !r.modes.length || r.modes.length > this.map.modes.length)
                            return "Missing game modes.";
                        for (var i = 0; i < r.modes.length; ++i)
                            if (!this.map.modes[r.modes[i]])
                                return "Game mode error.";
                        if (!o.isArray(r.spawns) || !r.spawns.length)
                            return "Missing spawn points.";
                        if (r.spawns.length > e.spawnLimit)
                            return "Too many spawn points.";
                        for (i = 0; i < r.spawns.length; ++i) {
                            var a = r.spawns[i];
                            if (!o.isArray(a) || !a.length || a.length > 3)
                                return "Spawn point error.";
                            for (var s = 0; s < a.length; ++s)
                                if (!o.isNumber(a[s]))
                                    return "Spawn point error."
                        }
                        if (!o.isArray(r.objects) || !r.objects.length)
                            return "Missing objects.";
                        if (r.objects.length > e.objectLimit)
                            return "Map exceeds object limit.";
                        for (i = 0; i < r.objects.length; ++i) {
                            var c = r.objects[i];
                            if (!o.isArray(c.s) || 3 != c.s.length || !o.arrayInts(c.s))
                                return "Object scale error.";
                            if (!o.isArray(c.p) || 3 != c.p.length || !o.arrayInts(c.p))
                                return "Object position error.";
                            if (o.isArray(c.r)) {
                                if (3 != c.r.length || !o.arrayInts(c.r))
                                    return "Object rotation value error."
                            } else if (void 0 != c.r)
                                return "Object rotation error.";
                            if (void 0 != c.d && !o.isNumber(c.d))
                                return "Object direction error.";
                            c.col = !!c.col
                        }
                    }
                    for (s = 0; s < r.objects.length; ++s) {
                        if (r.objects[s].id = e.prefabIDS[r.objects[s].id || 0],
                        !r.objects[s].id)
                            return "Object ID error.";
                        if (r.objects[s].t = e.textureIDS[r.objects[s].t || 0],
                        !r.objects[s].t)
                            return "Object Texture error."
                    }
                    this.map.setMaps([r]),
                    this.config.maps = [0]
                } catch (t) {
                    return "Map error occured."
                }
        }
        ,
        this.playSound = function(t, e, n, r) {
            if (s)
                s.play(t, e);
            else
                for (var i = 0; i < this.players.list.length; ++i)
                    (l = this.players.list[i]).active && (n != l || r) && h.send(l.id, "s", t, n.sid)
        }
        ,
        this.playerSound = function(t, e, n, r, i) {
            (l = r || this.players.findBySid(e)) && s.play3D(t, l.x, l.y, l.z, n || 1, i)
        }
        ;
        var p = [];
        this.getSpawnPoint = function(t, n) {
            if (n)
                return this.map.spawns[0];
            p.length = 0;
            for (var r, i = 0; i < this.map.spawns.length; ++i) {
                this.map.spawns[i].dst = 0;
                for (var a = 0; a < this.players.list.length; ++a)
                    !(l = this.players.list[a]).active || t && l.team == t || this.canSee(l, this.map.spawns[i].x, this.map.spawns[i].y + e.playerHeight, this.map.spawns[i].z) || this.map.spawns[i].dst++
            }
            for (this.map.spawns.sort(o.orderByDst),
            r = this.map.spawns[0].dst,
            i = 0; i < this.map.spawns.length; ++i)
                if (this.map.spawns[i].dst == r) {
                    for (this.map.spawns[i].dst = 0,
                    a = 0; a < this.players.list.length; ++a)
                        !(l = this.players.list[a]).active || t && l.team == t || (this.map.spawns[i].dst += o.getDistance3D(this.map.spawns[i].x, this.map.spawns[i].y, this.map.spawns[i].z, l.x, l.y, l.z));
                    p.push(this.map.spawns[i])
                }
            return p.sort(o.orderByDst),
            p.reverse(),
            p[0]
        }
        ,
		this.getVars = function() {
            return {
                funcs: o,
                constants: e
            }
        }
        ,
        this.canSee = function(t, n, r, i) {
            for (var a = o.getDistance3D(t.x, t.y, t.z, n, r, i), s = o.getDirection(t.z, t.x, i, n), c = o.getDirection(o.getDistance(t.x, t.z, n, i), r, 0, t.y), h = 1 / (a * Math.sin(s - Math.PI) * Math.cos(c)), l = 1 / (a * Math.cos(s - Math.PI) * Math.cos(c)), u = 1 / (a * Math.sin(c)), p = 0; p < this.map.manager.objects.length; ++p) {
                var d = this.map.manager.objects[p];
                if (!d.noShoot) {
                    var f = o.lineInRect(t.x, t.z, t.y + t.height - e.cameraHeight, h, l, u, d.x - d.width, d.z - d.length, d.y - d.height, d.x + d.width, d.z + d.length, d.y + d.height);
                    if (f && f < 1)
                        return f
                }
            }
            return null
        }
        ,
        this.savePlayerData = function() {
            if (i)
                for (var t = 0; t < this.players.list.length; ++t)
                    if ((l = this.players.list[t]).account) {
                        l.account.kills += l.kills,
                        l.account.deaths += l.deaths,
                        l.account.games++,
                        l.account.timePlayed += l.playTime || 0,
                        l.account.score += l.score,
                        l.didWin && l.account.wins++;
                        var e = l.account.getData();
                        h.send(l.id, "ua", e),
                        i.call(2, e)
                    }
        }
        ,
        this.init = function(t, e, n) {
            this.players.clear(),
            this.gameTimer = 6e4 * this.config.gameTime,
            this.lastTimer = 0,
            this.mapIndex = void 0 != t ? t : this.config.maps[o.randInt(0, this.config.maps.length - 1)],
            this.modeIndex = void 0 != e ? e : this.map.getRandomMode(this.mapIndex),
            this.mode = r.modes[this.modeIndex],
            this.map.generate(this.mapIndex, this.mode, n),
            s && s.play("ambient_1", .12, !0)
        }
        ,
        this.endGame = function() {
            this.endTimer = e.endTimer,
            this.players.list.sort(o.orderByScore),
            this.endData.length = 0;
            for (var t = 0; t < this.players.list.length; ++t)
                for (var n = 0; n < e.endStats.length; ++n)
                    this.endData.push(this.players.list[t][e.endStats[n]]);
            if (this.mode.teams) {
                var r = 0
                  , i = 0;
                for (t = 0; t < this.players.list.length; ++t)
                    1 == (l = this.players.list[t]).team ? r += l.score : 2 == l.team && (i += l.score);
                this.winner = r >= i ? 1 : 2
            } else
                this.winner = this.players.list[0];
            for (t = 0; t < this.players.list.length; ++t)
                (l = this.players.list[t]).didWin = this.mode.teams ? l.team && l.team == this.winner : l == this.winner,
                h.send(l.id, "end", !1, l.didWin, this.endData);
            this.savePlayerData(),
            this.init()
        }
        ,
        this.forceNewGame = function() {
            this.gameTimer = 0,
            this.endGame(),
            h.broadcast("game" + this.sid, "init", this.mapIndex, this.modeIndex, this.config),
            this.endTimer = 0
        }
        ,
        this.update = function(t, e, n) {
            this.now = e,
            h && (this.endTimer > 0 ? (this.endTimer -= t,
            this.endTimer <= 0 ? (this.endTimer = 0,
            h.broadcast("game" + this.sid, "init", this.mapIndex, this.modeIndex, this.config)) : (u = o.getTime(this.endTimer)) != this.lastTimer && (this.lastTimer = u,
            h.broadcast("game" + this.sid, "t", u, 1))) : this.gameTimer > 0 && (this.gameTimer -= t,
            this.gameTimer <= 0 ? (this.gameTimer = 0,
            this.endGame()) : (u = o.getTime(this.gameTimer)) != this.lastTimer && (this.lastTimer = u,
            h.broadcast("game" + this.sid, "t", u)))),
            this.players.update(t * this.config.deltaMlt),
            c && c.update(t * this.config.deltaMlt, n),
            a && a.render(t * this.config.deltaMlt)
        }
    }
}
, function(t, e, n) {
    n(2),
    t.exports = function(t, e, n, r, i, o) {
        var a = this
          , s = t.renderer.domElement;
        if (this.hasPointerlock = "pointerLockElement"in document || "mozPointerLockElement"in document || "webkitPointerLockElement"in document,
        this.hasPointerlock) {
            s.requestPointerLock = s.requestPointerLock || s.mozRequestPointerLock || s.webkitRequestPointerLock;
            var c = function(t) {
                a.enabled = document.pointerLockElement === s || document.mozPointerLockElement === s || document.webkitPointerLockElement === s,
                o.connected && (a.enabled && enterGame(),
                n.toggleControlUI(a.enabled))
            };
            document.addEventListener("pointerlockchange", c, !1),
            document.addEventListener("mozpointerlockchange", c, !1),
            document.addEventListener("webkitpointerlockchange", c, !1)
        }
        this.isn = 0,
        this.tmpInputs = [],
        this.getISN = function() {
            return this.isn++
        }
        ,
        this.sensMlt = 1,
        this.locked = !1,
        this.enabled = !1,
        t.camera.rotation.set(0, 0, 0),
        this.pitchObject = new e.Object3D,
        this.pitchObject.add(t.camera),
        this.object = new e.Object3D,
        this.object.add(this.pitchObject);
        var h = Math.PI / 2;
		
        s.addEventListener("mousemove", function(e) {
            if (a.enabled) {
                e.preventDefault();
                var n = e.movementX || e.mozMovementX || e.webkitMovementX || 0
                  , r = e.movementY || e.mozMovementY || e.webkitMovementY || 0
                  , o = i.mouseSens * a.sensMlt * (a.target ? i.camChaseSen : 1) * (t.camera.fov / t.fov);
                a.object.rotation.y -= n * o,
                a.pitchObject.rotation.x -= r * o * (a.invertY ? -1 : 1),
                a.pitchObject.rotation.x = Math.max(-h, Math.min(h, a.pitchObject.rotation.x)),
                a.yDir = (a.pitchObject.rotation.x % Math.PI2).round(3),
                a.xDir = (a.object.rotation.y % Math.PI2).round(3)
            }
        }, !1),
        s.addEventListener("mousedown", function(t) {
            if (!a.locked)
                switch (a.enabled || a.toggle(!0),
                document.activeElement == chatInput && chatInput.blur(),
                t.which) {
                case 3:
                    a.mouseDownR = 1;
                    break;
                default:
                    a.mouseDownL = 1
                }
        }, !1),
        s.addEventListener("mouseup", function(t) {
            if (!a.locked)
                switch (t.which) {
                case 3:
                    a.mouseDownR = 0;
                    break;
                default:
                    a.mouseDownL = 0
                }
        }, !1);
        var l = function(t) {
            return t = window.event || t,
            a.skipScroll ? a.skipScroll = !1 : a.scrollDelta = -Math.max(-1, Math.min(1, t.wheelDelta || -t.detail)),
            !1
        };
        function u(t, e) {
            if (window.idleTimer = 0,
            a.keys) {
                if (e && a.keys[t] !== e && null != a.inputChanger)
                    a.moveKeys[a.inputChanger] ? a.moveKeys[a.inputChanger] = t : a[a.inputChanger] = t,
                    saveVal("cont_" + a.inputChanger, t),
                    a.inputChanger = null,
                    showWindow(7, !0);
                else if (!a.enabled)
                    return;
                a.keys[t] !== e && (a.keys[t] = e,
                t == a.voiceKey ? toggleRecord(e) : a.moveKeys.indexOf(t) >= 0 && a.updateMoveDir(),
                e && (t == a.swapKeyU ? a.scrollDelta = 1 : t == a.swapKeyD ? a.scrollDelta = -1 : window.pressButton(t)))
            }
        }
        s.addEventListener ? (s.addEventListener("mousewheel", l, !1),
        s.addEventListener("DOMMouseScroll", l, !1)) : myitem.attachEvent("onmousewheel", l),
        this.update = function(e) {
            if (this.target) {
                var n = r.getAngleDist(this.object.rotation.y, this.target.yD);
                this.object.rotation.y += n * e * i.camChaseTrn,
                n = r.getAngleDist(a.pitchObject.rotation.x, this.target.xD),
                this.pitchObject.rotation.x += n * e * i.camChaseTrn,
                n = r.getDistance3D(this.object.position.x, this.object.position.y, this.object.position.z, this.target.x, this.target.y, this.target.z) * e * i.camChaseSpd;
                var o = r.getDirection(this.object.position.z, this.object.position.x, this.target.z, this.target.x)
                  , s = r.getXDir(this.object.position.x, this.object.position.y, this.object.position.z, this.target.x, this.target.y, this.target.z);
                this.object.position.x -= n * Math.sin(o) * Math.cos(s),
                this.object.position.y += n * Math.sin(s),
                this.object.position.z -= n * Math.cos(o) * Math.cos(s),
                t.updateFrustum()
            }
        }
        ,
        this.camLookAt = function(t, e, n) {
            var o = r.getXDir(this.object.position.x, this.object.position.y, this.object.position.z, t, e, n)
              , a = r.getDirection(this.object.position.z, this.object.position.x, n, t);
            this.target = {
                xD: o,
                yD: a,
                x: t + i.camChaseDst * Math.sin(a) * Math.cos(o),
                y: e - i.camChaseDst * Math.sin(o),
                z: n + i.camChaseDst * Math.cos(a) * Math.cos(o)
            }
        }
        ,
        this.moveCam = function(e, n, r) {
            a.object.position.set(e, n, r),
            t.camera.updateProjectionMatrix(),
            t.updateFrustum()
        }
        ,
        this.rotateCam = function(e, n, r) {
            t.camera.rotation.y = e,
            t.camera.rotation.x = n,
            t.camera.rotation.z = r
        }
        ,
        this.jumpKey = parseInt(getSavedVal("cont_4") || 32),
        this.crouchKey = parseInt(getSavedVal("cont_5") || 16),
        this.swapKeyD = parseInt(getSavedVal("cont_6") || 81),
        this.swapKeyU = parseInt(getSavedVal("cont_7") || 69),
        this.reloadKey = parseInt(getSavedVal("cont_8") || 82),
        this.sprayKey = parseInt(getSavedVal("cont_9") || 70),
        this.aimKey = parseInt(getSavedVal("cont_10") || 67),
        this.chatKey = parseInt(getSavedVal("cont_11") || 13),
        this.voiceKey = parseInt(getSavedVal("cont_12") || 86),
        this.moveKeys = [parseInt(getSavedVal("cont_0") || 87), parseInt(getSavedVal("cont_1") || 83), parseInt(getSavedVal("cont_2") || 65), parseInt(getSavedVal("cont_3") || 68)],
        this.moveDirs = [[0, -1], [0, 1], [-1, 0], [1, 0]],
        this.updateMoveDir = function() {
            for (var t = 0, e = 0, n = 0; n < a.moveKeys.length; ++n)
                a.keys[a.moveKeys[n]] && (t += a.moveDirs[n][0],
                e += a.moveDirs[n][1]);
            this.moveDir = 0 == t && 0 == e ? null : Math.atan2(e, t)
        }
        ,
        window.addEventListener("keydown", function(t) {
            (t.which || t.keyCode) == a.chatKey ? window.pressButton(t.which || t.keyCode) : document.activeElement != chatInput && (a.enabled && t.preventDefault(),
            u(t.which || t.keyCode || 0, 1))
        }, !1),
        window.addEventListener("keyup", function(t) {
            a.enabled && t.preventDefault(),
            u(t.which || t.keyCode || 0, 0)
        }, !1),
        this.toggle = function(t) {
            this.locked || ("block" == windowHolder.style.display ? t && n.toggleWindow(!1) : (t ? s.requestPointerLock() : document.exitPointerLock(),
            this.enabled = t))
        }
        ,
        this.disable = function() {
            a.toggle(!1),
            a.locked = !0
        }
        ,
        this.reset = function() {
            this.mouseDownL = 0,
            this.mouseDownR = 0,
            this.keys = {},
            this.tmpInputs.length = 0,
            this.scrollDelta = 0,
            this.xDir = 0,
            this.yDir = 0,
            this.isn = 0,
            this.moveDir = null,
            this.skipScroll = !1,
            this.inputChanger = null,
            this.target = null,
            this.locked = !1,
            a.pitchObject.rotation.x = 0,
            a.object.rotation.y = 0,
            t.camera.rotation.set(0, 0, 0)
        }
    }
}
, function(t, e) {
    t.exports = function(t, e) {
        var n;
        this.divs = [],
        this.update = function(t) {
            for (var e = this.divs.length - 1; e >= 0; --e)
                if ((n = this.divs[e]).delay > 0)
                    n.delay -= t,
                    n.delay <= 0 && (n.style.display = "inline-block");
                else {
                    if (n.scale > n.minScale && (n.scale -= n.scaleSpeed * t,
                    n.scale <= n.minScale && (n.scale = n.minScale),
                    n.style.fontSize = n.scale + "px"),
                    n.scaleSpd && (n.startS += n.scaleSpd * t,
                    n.style.width = n.startS + "vh",
                    n.style.height = n.startS + "vh"),
                    n.life -= t,
                    n.life <= 0) {
                        n.style.display = "none";
                        var r = n.callback;
                        this.divs.splice(e, 1),
                        r && r()
                    }
                    n.fade && n.life <= n.fade && (n.style.opacity = n.life / n.fade)
                }
        }
        ,
        this.animateText = function(t, e, n, r, i, o, a, s) {
            this.divs.indexOf(t) < 0 && this.divs.push(t),
            t.delay = a,
            a || (t.style.display = "inline-block"),
            t.style.fontSize = n + "px",
            t.scale = n,
            t.minScale = r ? .4 * n : n,
            t.innerHTML = e,
            t.scaleSpeed = r,
            t.life = i,
            t.fade = o,
            t.style.opacity = 1,
            t.callback = s
        }
        ,
        this.animateDiv = function(t, e, n, r, i) {
            this.divs.indexOf(t) < 0 && this.divs.push(t),
            t.style.display = "block",
            t.life = e,
            t.maxLife = e,
            t.style.opacity = 1,
            t.fade = n,
            r && (t.style.width = r + "vh",
            t.style.height = r + "vh",
            t.startS = r,
            t.scaleSpd = i)
        }
        ,
        this.reset = function() {
            for (var t = 0; t < this.divs.length; ++t)
                this.divs[t].style.display = "none";
            this.divs.length = 0
        }
    }
}
, function(t, e) {
    var n = t.exports;
    n.active = !0,
    n.toggleMenu = function(t) {
        menuHolder.style.display = t ? "block" : "none",
        speakerDisplay.style.display = t ? "none" : "block",
        chatHolder.style.bottom = (t ? 20 : 88) + "px",
        voiceDisplay.style.bottom = (t ? 18 : 84) + "px",
        t && (endUI.style.display = "none",
        instructionHolder.style.display = "block"),
        n.active = !0
    }
    ,
    n.hideUI = function() {
        n.toggleMenu(!1),
        inGameUI.style.display = "none",
        instructionHolder.style.display = "none",
        chatHolder.style.bottom = "20px",
        voiceDisplay.style.bottom = "18px",
        speakerDisplay.style.right = "20px",
        n.active = !1
    }
    ,
    n.showEndScreen = function() {
        endTable.style.display = "none",
        endUI.style.display = "block",
        n.hideUI()
    }
    ,
    n.toggleWindow = function(t) {
        windowHolder.style.display = t ? "block" : "none",
        instructions.innerHTML = t ? "" : "CLICK TO PLAY"
    }
    ,
    n.showError = function(t) {
        n.toggleMenu(!0),
        instructions.innerHTML = t
    }
    ,
    n.toggleGameUI = function(t) {
        topRight.style.display = t ? "block" : "none",
        crosshair.style.display = t ? "block" : "none",
        reloadMsg.style.display = t ? "block" : "none",
        healthHolder.style.display = t ? "block" : "none",
        weaponDisplay.style.display = t ? "block" : "none",
        ammoDisplay.style.display = t ? "block" : "none",
        killCardHolder.style.display = t ? "none" : "block",
        speakerDisplay.style.right = (t ? 360 : 20) + "px",
        chatHolder.style.bottom = (t ? 88 : 20) + "px",
        voiceDisplay.style.bottom = (t ? 84 : 18) + "px"
    }
    ,
    n.toggleControlUI = function(t) {
        window.loading && (t = !1),
        inGameUI.style.display = t && n.active ? "block" : "none",
        instructionHolder.style.display = !t && n.active ? "block" : "none",
        aHolder.style.display = t ? "none" : "block",
        chatHolder.style.bottom = (t ? 88 : 20) + "px",
        voiceDisplay.style.bottom = (t ? 84 : 18) + "px",
        speakerDisplay.style.display = t && n.active ? "block" : "none",
        "block" != endUI.style.display && (menuHolder.style.display = t ? "none" : "block")
    }
    ;
    var r = 0
      , i = 0;
    n.updateCrosshair = function(t, e) {
        r == Math.round(t) && i == e.round(1) || (i = e.round(1),
        r = Math.round(t),
        crosshair.style.width = r + "px",
        crosshair.style.height = r + "px",
        crosshair.style.opacity = i)
    }
}
, function(t, e, n) {
    var r = n(2)
      , i = n(13)
      , o = [{
        mat: r.MeshBasicMaterial,
        spd: 1.7,
        scale: 1.4,
        length: 10,
        color: 16777179
    }, {
        spd: [.03, .04],
        grav: 4e-4,
        spn: [.03, .05],
        scale: .15,
        length: .5,
        color: 10124094
    }, {
        spd: [.03, .04],
        grav: 4e-4,
        spn: [.03, .05],
        scale: .11,
        length: .4,
        color: 12816686
    }];
    r.Sprite.prototype.init = function(t, e, n, r, i, o, a, s, c) {
        this.position.x = t,
        this.position.y = e,
        this.position.z = n,
        this.xVel = r,
        this.yVel = i,
        this.zVel = o,
        this.scale.x = this.scale.y = a,
        this.life = s,
        this.area = c
    }
    ,
    r.Sprite.prototype.update = function(t) {
        if (this.visible) {
            if (this.position.x += this.xVel * t,
            this.position.y += this.yVel * t,
            this.position.z += this.zVel * t,
            this.area) {
                var e = this.scale.x / 2;
                this.position.x - e >= this.area.x + this.area.w ? this.position.x = this.area.x - this.area.w - e : this.position.x + e <= this.area.x - this.area.w && (this.position.x = this.area.x + this.area.w + e),
                this.position.z - e >= this.area.z + this.area.l ? this.position.z = this.area.z - this.area.l - e : this.position.z + e <= this.area.z - this.area.l && (this.position.z = this.area.z + this.area.l + e),
                this.position.y - e >= this.area.y + this.area.h ? this.position.y = this.area.y - e : this.position.y + e <= this.area.y && (this.position.y = this.area.y + this.area.h + e)
            }
            this.life > 0 && (this.life -= t,
            this.life <= 0 && (this.visible = !1))
        }
    }
    ;
    var a = [Math.PI / 3, -Math.PI / 3]
      , s = [{
        hole: !0,
        count: 10,
        scale: [1, 4],
        speed: [0, .025],
        spread: [-.4, .4],
        life: [300, 500]
    }, {}, {
        count: 1,
        blending: 2,
        scale: [5, 7],
        speed: [0, 0],
        spread: [0, 0],
        life: [30, 35]
    }, {
        count: 1,
        blending: 2,
        scale: [2e3, 2e3],
        speed: [0, 0],
        spread: [0, 0]
    }];
    t.exports = function(t, e) {
        var n, c;
        this.particles = [],
        this.physObjs = [],
        this.areas = [],
        this.active = !0,
        this.area = function(t, e, n, r, o, a, s, c) {
            r /= 2,
            a /= 2,
            this.areas.push({
                f: c,
                x: t,
                y: e,
                z: n,
                w: r,
                h: o,
                l: a
            });
            for (var h = 0; h < s.count; ++h)
                this.add(s.src, t + i.randInt(-r, r), e + i.randInt(0, o), n + i.randInt(-a, a), s.spd * Math.sin(s.dir), s.grav ? i.randFloat(s.grav[0], s.grav[1]) : 0, s.spd * Math.cos(s.dir), i.randFloat(s.scl[0], s.scl[1]), 0, s.blending, this.areas[this.areas.length - 1])
        }
        ,
        this.effect = function(t, e, o, a, c, h) {
            if (this.active) {
                n = s[h];
                for (var l = 0; l < n.count; ++l) {
                    var u = i.randFloat(n.speed[0], n.speed[1])
                      , p = a + i.randFloat(n.spread[0], n.spread[1])
                      , d = c + i.randFloat(n.spread[0], n.spread[1]);
                    this.add(h, t, e, o, u * Math.sin(p) * Math.cos(d), u * Math.sin(d), u * Math.cos(p) * Math.cos(d), i.randFloat(n.scale[0], n.scale[1]), n.life ? i.randInt(n.life[0], n.life[1]) : 0, n.blending)
                }
                n.hole && this.add(1, t, e, o, 0, 0, 0, i.randFloat(.4, 1), 5e3, r.SubtractiveBlending)
            }
        }
        ,
        this.add = function(e, n, i, o, a, s, h, l, u, p, d) {
            c = null;
            for (var f = 0; f < this.particles.length; ++f)
                if (!this.particles[f].visible && !this.particles[f].static) {
                    c = this.particles[f];
                    break
                }
            c || (c = new r.Sprite,
            this.particles.push(c),
            t.scene.add(c)),
            this.setMaterial(c, e, p),
            c.visible = !0,
            c.init(n, i, o, a, s, h, l, u, d)
        }
        ,
        this.setMaterial = function(e, n, o, s) {
            e.material = t.getMat("particles/" + n, {
                mat: r.SpriteMaterial,
                depthWrite: !1,
                blending: o || r.NormalBlending,
                rotation: s ? a[i.randInt(0, 1)] : 0
            })
        }
        ,
        this.physObj = function(e, n, a, s, h, l, u, p) {
            c = null;
            for (var d = 0; d < this.physObjs.length; ++d)
                if (!this.physObjs[d].mesh.visible) {
                    c = this.physObjs[d];
                    break
                }
            c || (c = new function(t) {
                this.mesh = new r.Mesh(t.cubeGeo),
                this.init = function(e, n, o, a, s, c, h, l) {
                    this.dst = c,
                    this.spd = h.spd[1] ? i.randFloat(h.spd[0], h.spd[1]) : h.spd,
                    a -= Math.PI,
                    this.xS = this.spd * Math.sin(a) * Math.cos(s) + (l ? l.xVel : 0),
                    this.zS = this.spd * Math.cos(a) * Math.cos(s) + (l ? l.zVel : 0),
                    this.yS = this.spd * Math.sin(s) + (l ? l.yVel : 0),
                    this.grav = h.grav,
                    this.spin = h.spn ? h.spn[1] ? i.randFloat(h.spn[0], h.spn[1]) : h.spn : 0,
                    this.mesh.receiveShadow = h.mat != r.MeshBasicMaterial,
                    this.mesh.material = t.getMat("default", {
                        fog: h.mat != r.MeshBasicMaterial,
                        color: h.color,
                        emissive: h.emis,
                        mat: h.mat
                    }),
                    t.moveMesh(this.mesh, e, n, o),
                    this.mesh.lookAt(e + this.xS, n + this.yS, o + this.zS),
                    t.scaleMesh(this.mesh, h.scale, h.scale, h.length)
                }
                ,
                this.update = function(t) {
                    this.mesh.visible && (this.mesh.position.x += this.xS * t,
                    this.mesh.position.z += this.zS * t,
                    this.mesh.position.y += this.yS * t,
                    this.spin && (this.mesh.rotation.x += this.spin * t),
                    this.yS -= (this.grav || 0) * t,
                    this.dst -= this.spd * t,
                    this.dst <= 0 && (this.mesh.visible = !1))
                }
            }
            (t),
            this.physObjs.push(c),
            t.scene.add(c.mesh)),
            c.mesh.visible = !0,
            c.init(e, n, a, s, h, l, o[u], p)
        }
        ,
        this.update = function(t, e) {
            if (e && e.active)
                for (var n = 0; n < this.areas.length; ++n)
                    this.areas[n].f && (this.areas[n].x = e.x,
                    this.areas[n].y = e.y,
                    this.areas[n].z = e.z);
            for (n = 0; n < this.particles.length; ++n)
                this.particles[n].update(t);
            for (n = 0; n < this.physObjs.length; ++n)
                this.physObjs[n].update(t)
        }
        ,
        this.reset = function() {
            this.particles.length = 0,
            this.physObjs.length = 0,
            this.areas.length = 0
        }
    }
}
, function(t, e) {
    t.exports = function(t, e) {
        var n;
        this.sounds = [],
        this.listener = {},
        this.setVolume = function(t) {
            Howler.volume(t)
        }
        ,
        this.getSound = function(t, e) {
            var r = t + (e || "");
            (n = this.sounds[r]) || (n = new Howl({
                src: ".././sound/" + t + ".mp3"
            }),
            this.sounds[r] = n)
        }
        ,
        this.play = function(t, e, r, i) {
            if (this.getSound(t),
            !r || !n.isPlaying) {
                n.isPlaying = !0;
                var o = n.play();
                n.volume(e || 1, o),
                n.loop(r, o),
                n.rate(i || 1, o)
            }
        }
        ,
        this.play3D = function(t, r, i, o, a, s, c) {
            this.getSound(t, "3d");
            var h = n.play();
            a = (a || 1) * e.otherSoundMlt,
            n.volume(a, h),
            n.rate(s || 1, h),
            n.pos(r, i, o, h),
            n.pannerAttr({
                refDistance: c || 25,
                rolloffFactor: 1
            }, h)
        }
    }
}
, function(t, e) {
    function n(t) {
        return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t)
    }
    /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
    t.exports = function(t) {
        return null != t && (n(t) || function(t) {
            return "function" == typeof t.readFloatLE && "function" == typeof t.slice && n(t.slice(0, 0))
        }(t) || !!t._isBuffer)
    }
}
, function(t, e) {
    !function() {
        var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
          , n = {
            rotl: function(t, e) {
                return t << e | t >>> 32 - e
            },
            rotr: function(t, e) {
                return t << 32 - e | t >>> e
            },
            endian: function(t) {
                if (t.constructor == Number)
                    return 16711935 & n.rotl(t, 8) | 4278255360 & n.rotl(t, 24);
                for (var e = 0; e < t.length; e++)
                    t[e] = n.endian(t[e]);
                return t
            },
            randomBytes: function(t) {
                for (var e = []; t > 0; t--)
                    e.push(Math.floor(256 * Math.random()));
                return e
            },
            bytesToWords: function(t) {
                for (var e = [], n = 0, r = 0; n < t.length; n++,
                r += 8)
                    e[r >>> 5] |= t[n] << 24 - r % 32;
                return e
            },
            wordsToBytes: function(t) {
                for (var e = [], n = 0; n < 32 * t.length; n += 8)
                    e.push(t[n >>> 5] >>> 24 - n % 32 & 255);
                return e
            },
            bytesToHex: function(t) {
                for (var e = [], n = 0; n < t.length; n++)
                    e.push((t[n] >>> 4).toString(16)),
                    e.push((15 & t[n]).toString(16));
                return e.join("")
            },
            hexToBytes: function(t) {
                for (var e = [], n = 0; n < t.length; n += 2)
                    e.push(parseInt(t.substr(n, 2), 16));
                return e
            },
            bytesToBase64: function(t) {
                for (var n = [], r = 0; r < t.length; r += 3)
                    for (var i = t[r] << 16 | t[r + 1] << 8 | t[r + 2], o = 0; o < 4; o++)
                        8 * r + 6 * o <= 8 * t.length ? n.push(e.charAt(i >>> 6 * (3 - o) & 63)) : n.push("=");
                return n.join("")
            },
            base64ToBytes: function(t) {
                t = t.replace(/[^A-Z0-9+\/]/gi, "");
                for (var n = [], r = 0, i = 0; r < t.length; i = ++r % 4)
                    0 != i && n.push((e.indexOf(t.charAt(r - 1)) & Math.pow(2, -2 * i + 8) - 1) << 2 * i | e.indexOf(t.charAt(r)) >>> 6 - 2 * i);
                return n
            }
        };
        t.exports = n
    }()
}
, function(t, e, n) {
    !function() {
        var e = n(64)
          , r = n(46).utf8
          , i = n(63)
          , o = n(46).bin
          , a = function(t, n) {
            t.constructor == String ? t = n && "binary" === n.encoding ? o.stringToBytes(t) : r.stringToBytes(t) : i(t) ? t = Array.prototype.slice.call(t, 0) : Array.isArray(t) || (t = t.toString());
            for (var s = e.bytesToWords(t), c = 8 * t.length, h = 1732584193, l = -271733879, u = -1732584194, p = 271733878, d = 0; d < s.length; d++)
                s[d] = 16711935 & (s[d] << 8 | s[d] >>> 24) | 4278255360 & (s[d] << 24 | s[d] >>> 8);
            s[c >>> 5] |= 128 << c % 32,
            s[14 + (c + 64 >>> 9 << 4)] = c;
            var f = a._ff
              , m = a._gg
              , g = a._hh
              , v = a._ii;
            for (d = 0; d < s.length; d += 16) {
                var y = h
                  , x = l
                  , w = u
                  , b = p;
                l = v(l = v(l = v(l = v(l = g(l = g(l = g(l = g(l = m(l = m(l = m(l = m(l = f(l = f(l = f(l = f(l, u = f(u, p = f(p, h = f(h, l, u, p, s[d + 0], 7, -680876936), l, u, s[d + 1], 12, -389564586), h, l, s[d + 2], 17, 606105819), p, h, s[d + 3], 22, -1044525330), u = f(u, p = f(p, h = f(h, l, u, p, s[d + 4], 7, -176418897), l, u, s[d + 5], 12, 1200080426), h, l, s[d + 6], 17, -1473231341), p, h, s[d + 7], 22, -45705983), u = f(u, p = f(p, h = f(h, l, u, p, s[d + 8], 7, 1770035416), l, u, s[d + 9], 12, -1958414417), h, l, s[d + 10], 17, -42063), p, h, s[d + 11], 22, -1990404162), u = f(u, p = f(p, h = f(h, l, u, p, s[d + 12], 7, 1804603682), l, u, s[d + 13], 12, -40341101), h, l, s[d + 14], 17, -1502002290), p, h, s[d + 15], 22, 1236535329), u = m(u, p = m(p, h = m(h, l, u, p, s[d + 1], 5, -165796510), l, u, s[d + 6], 9, -1069501632), h, l, s[d + 11], 14, 643717713), p, h, s[d + 0], 20, -373897302), u = m(u, p = m(p, h = m(h, l, u, p, s[d + 5], 5, -701558691), l, u, s[d + 10], 9, 38016083), h, l, s[d + 15], 14, -660478335), p, h, s[d + 4], 20, -405537848), u = m(u, p = m(p, h = m(h, l, u, p, s[d + 9], 5, 568446438), l, u, s[d + 14], 9, -1019803690), h, l, s[d + 3], 14, -187363961), p, h, s[d + 8], 20, 1163531501), u = m(u, p = m(p, h = m(h, l, u, p, s[d + 13], 5, -1444681467), l, u, s[d + 2], 9, -51403784), h, l, s[d + 7], 14, 1735328473), p, h, s[d + 12], 20, -1926607734), u = g(u, p = g(p, h = g(h, l, u, p, s[d + 5], 4, -378558), l, u, s[d + 8], 11, -2022574463), h, l, s[d + 11], 16, 1839030562), p, h, s[d + 14], 23, -35309556), u = g(u, p = g(p, h = g(h, l, u, p, s[d + 1], 4, -1530992060), l, u, s[d + 4], 11, 1272893353), h, l, s[d + 7], 16, -155497632), p, h, s[d + 10], 23, -1094730640), u = g(u, p = g(p, h = g(h, l, u, p, s[d + 13], 4, 681279174), l, u, s[d + 0], 11, -358537222), h, l, s[d + 3], 16, -722521979), p, h, s[d + 6], 23, 76029189), u = g(u, p = g(p, h = g(h, l, u, p, s[d + 9], 4, -640364487), l, u, s[d + 12], 11, -421815835), h, l, s[d + 15], 16, 530742520), p, h, s[d + 2], 23, -995338651), u = v(u, p = v(p, h = v(h, l, u, p, s[d + 0], 6, -198630844), l, u, s[d + 7], 10, 1126891415), h, l, s[d + 14], 15, -1416354905), p, h, s[d + 5], 21, -57434055), u = v(u, p = v(p, h = v(h, l, u, p, s[d + 12], 6, 1700485571), l, u, s[d + 3], 10, -1894986606), h, l, s[d + 10], 15, -1051523), p, h, s[d + 1], 21, -2054922799), u = v(u, p = v(p, h = v(h, l, u, p, s[d + 8], 6, 1873313359), l, u, s[d + 15], 10, -30611744), h, l, s[d + 6], 15, -1560198380), p, h, s[d + 13], 21, 1309151649), u = v(u, p = v(p, h = v(h, l, u, p, s[d + 4], 6, -145523070), l, u, s[d + 11], 10, -1120210379), h, l, s[d + 2], 15, 718787259), p, h, s[d + 9], 21, -343485551),
                h = h + y >>> 0,
                l = l + x >>> 0,
                u = u + w >>> 0,
                p = p + b >>> 0
            }
            return e.endian([h, l, u, p])
        };
        a._ff = function(t, e, n, r, i, o, a) {
            var s = t + (e & n | ~e & r) + (i >>> 0) + a;
            return (s << o | s >>> 32 - o) + e
        }
        ,
        a._gg = function(t, e, n, r, i, o, a) {
            var s = t + (e & r | n & ~r) + (i >>> 0) + a;
            return (s << o | s >>> 32 - o) + e
        }
        ,
        a._hh = function(t, e, n, r, i, o, a) {
            var s = t + (e ^ n ^ r) + (i >>> 0) + a;
            return (s << o | s >>> 32 - o) + e
        }
        ,
        a._ii = function(t, e, n, r, i, o, a) {
            var s = t + (n ^ (e | ~r)) + (i >>> 0) + a;
            return (s << o | s >>> 32 - o) + e
        }
        ,
        a._blocksize = 16,
        a._digestsize = 16,
        t.exports = function(t, n) {
            if (void 0 === t || null === t)
                throw new Error("Illegal argument " + t);
            var r = e.wordsToBytes(a(t, n));
            return n && n.asBytes ? r : n && n.asString ? o.bytesToString(r) : e.bytesToHex(r)
        }
    }()
}
, function(t, e, n) {
    "use strict";
    var r = function(t) {
        switch (typeof t) {
        case "string":
            return t;
        case "boolean":
            return t ? "true" : "false";
        case "number":
            return isFinite(t) ? t : "";
        default:
            return ""
        }
    };
    t.exports = function(t, e, n, s) {
        return e = e || "&",
        n = n || "=",
        null === t && (t = void 0),
        "object" == typeof t ? o(a(t), function(a) {
            var s = encodeURIComponent(r(a)) + n;
            return i(t[a]) ? o(t[a], function(t) {
                return s + encodeURIComponent(r(t))
            }).join(e) : s + encodeURIComponent(r(t[a]))
        }).join(e) : s ? encodeURIComponent(r(s)) + n + encodeURIComponent(r(t)) : ""
    }
    ;
    var i = Array.isArray || function(t) {
        return "[object Array]" === Object.prototype.toString.call(t)
    }
    ;
    function o(t, e) {
        if (t.map)
            return t.map(e);
        for (var n = [], r = 0; r < t.length; r++)
            n.push(e(t[r], r));
        return n
    }
    var a = Object.keys || function(t) {
        var e = [];
        for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && e.push(n);
        return e
    }
}
, function(t, e, n) {
    "use strict";
    function r(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    t.exports = function(t, e, n, o) {
        e = e || "&",
        n = n || "=";
        var a = {};
        if ("string" != typeof t || 0 === t.length)
            return a;
        var s = /\+/g;
        t = t.split(e);
        var c = 1e3;
        o && "number" == typeof o.maxKeys && (c = o.maxKeys);
        var h = t.length;
        c > 0 && h > c && (h = c);
        for (var l = 0; l < h; ++l) {
            var u, p, d, f, m = t[l].replace(s, "%20"), g = m.indexOf(n);
            g >= 0 ? (u = m.substr(0, g),
            p = m.substr(g + 1)) : (u = m,
            p = ""),
            d = decodeURIComponent(u),
            f = decodeURIComponent(p),
            r(a, d) ? i(a[d]) ? a[d].push(f) : a[d] = [a[d], f] : a[d] = f
        }
        return a
    }
    ;
    var i = Array.isArray || function(t) {
        return "[object Array]" === Object.prototype.toString.call(t)
    }
}
, function(t, e, n) {
    "use strict";
    e.decode = e.parse = n(67),
    e.encode = e.stringify = n(66)
}
, function(t, e, n) {
    "use strict";
    t.exports = {
        isString: function(t) {
            return "string" == typeof t
        },
        isObject: function(t) {
            return "object" == typeof t && null !== t
        },
        isNull: function(t) {
            return null === t
        },
        isNullOrUndefined: function(t) {
            return null == t
        }
    }
}
, function(t, e) {
    t.exports = function(t) {
        return t.webpackPolyfill || (t.deprecate = function() {}
        ,
        t.paths = [],
        t.children || (t.children = []),
        Object.defineProperty(t, "loaded", {
            enumerable: !0,
            get: function() {
                return t.l
            }
        }),
        Object.defineProperty(t, "id", {
            enumerable: !0,
            get: function() {
                return t.i
            }
        }),
        t.webpackPolyfill = 1),
        t
    }
}
, function(t, e, n) {
    (function(t, r) {
        var i;
        /*! https://mths.be/punycode v1.3.2 by @mathias */
        !function(o) {
            "object" == typeof e && e && e.nodeType,
            "object" == typeof t && t && t.nodeType;
            var a = "object" == typeof r && r;
            a.global !== a && a.window !== a && a.self;
            var s, c = 2147483647, h = 36, l = 1, u = 26, p = 38, d = 700, f = 72, m = 128, g = "-", v = /^xn--/, y = /[^\x20-\x7E]/, x = /[\x2E\u3002\uFF0E\uFF61]/g, w = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, b = h - l, M = Math.floor, _ = String.fromCharCode;
            function E(t) {
                throw RangeError(w[t])
            }
            function S(t, e) {
                for (var n = t.length, r = []; n--; )
                    r[n] = e(t[n]);
                return r
            }
            function T(t, e) {
                var n = t.split("@")
                  , r = "";
                return n.length > 1 && (r = n[0] + "@",
                t = n[1]),
                r + S((t = t.replace(x, ".")).split("."), e).join(".")
            }
            function A(t) {
                for (var e, n, r = [], i = 0, o = t.length; i < o; )
                    (e = t.charCodeAt(i++)) >= 55296 && e <= 56319 && i < o ? 56320 == (64512 & (n = t.charCodeAt(i++))) ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e),
                    i--) : r.push(e);
                return r
            }
            function L(t) {
                return S(t, function(t) {
                    var e = "";
                    return t > 65535 && (e += _((t -= 65536) >>> 10 & 1023 | 55296),
                    t = 56320 | 1023 & t),
                    e + _(t)
                }).join("")
            }
            function R(t) {
                return t - 48 < 10 ? t - 22 : t - 65 < 26 ? t - 65 : t - 97 < 26 ? t - 97 : h
            }
            function P(t, e) {
                return t + 22 + 75 * (t < 26) - ((0 != e) << 5)
            }
            function C(t, e, n) {
                var r = 0;
                for (t = n ? M(t / d) : t >> 1,
                t += M(t / e); t > b * u >> 1; r += h)
                    t = M(t / b);
                return M(r + (b + 1) * t / (t + p))
            }
            function I(t) {
                var e, n, r, i, o, a, s, p, d, v, y = [], x = t.length, w = 0, b = m, _ = f;
                for ((n = t.lastIndexOf(g)) < 0 && (n = 0),
                r = 0; r < n; ++r)
                    t.charCodeAt(r) >= 128 && E("not-basic"),
                    y.push(t.charCodeAt(r));
                for (i = n > 0 ? n + 1 : 0; i < x; ) {
                    for (o = w,
                    a = 1,
                    s = h; i >= x && E("invalid-input"),
                    ((p = R(t.charCodeAt(i++))) >= h || p > M((c - w) / a)) && E("overflow"),
                    w += p * a,
                    !(p < (d = s <= _ ? l : s >= _ + u ? u : s - _)); s += h)
                        a > M(c / (v = h - d)) && E("overflow"),
                        a *= v;
                    _ = C(w - o, e = y.length + 1, 0 == o),
                    M(w / e) > c - b && E("overflow"),
                    b += M(w / e),
                    w %= e,
                    y.splice(w++, 0, b)
                }
                return L(y)
            }
            function O(t) {
                var e, n, r, i, o, a, s, p, d, v, y, x, w, b, S, T = [];
                for (x = (t = A(t)).length,
                e = m,
                n = 0,
                o = f,
                a = 0; a < x; ++a)
                    (y = t[a]) < 128 && T.push(_(y));
                for (r = i = T.length,
                i && T.push(g); r < x; ) {
                    for (s = c,
                    a = 0; a < x; ++a)
                        (y = t[a]) >= e && y < s && (s = y);
                    for (s - e > M((c - n) / (w = r + 1)) && E("overflow"),
                    n += (s - e) * w,
                    e = s,
                    a = 0; a < x; ++a)
                        if ((y = t[a]) < e && ++n > c && E("overflow"),
                        y == e) {
                            for (p = n,
                            d = h; !(p < (v = d <= o ? l : d >= o + u ? u : d - o)); d += h)
                                S = p - v,
                                b = h - v,
                                T.push(_(P(v + S % b, 0))),
                                p = M(S / b);
                            T.push(_(P(p, 0))),
                            o = C(n, w, r == i),
                            n = 0,
                            ++r
                        }
                    ++n,
                    ++e
                }
                return T.join("")
            }
            s = {
                version: "1.3.2",
                ucs2: {
                    decode: A,
                    encode: L
                },
                decode: I,
                encode: O,
                toASCII: function(t) {
                    return T(t, function(t) {
                        return y.test(t) ? "xn--" + O(t) : t
                    })
                },
                toUnicode: function(t) {
                    return T(t, function(t) {
                        return v.test(t) ? I(t.slice(4).toLowerCase()) : t
                    })
                }
            },
            void 0 === (i = function() {
                return s
            }
            .call(e, n, e, t)) || (t.exports = i)
        }()
    }
    ).call(this, n(70)(t), n(25))
}
, function(t, e, n) {
    "use strict";
    var r = n(71)
      , i = n(69);
    function o() {
        this.protocol = null,
        this.slashes = null,
        this.auth = null,
        this.host = null,
        this.port = null,
        this.hostname = null,
        this.hash = null,
        this.search = null,
        this.query = null,
        this.pathname = null,
        this.path = null,
        this.href = null
    }
    e.parse = x,
    e.resolve = function(t, e) {
        return x(t, !1, !0).resolve(e)
    }
    ,
    e.resolveObject = function(t, e) {
        return t ? x(t, !1, !0).resolveObject(e) : e
    }
    ,
    e.format = function(t) {
        return i.isString(t) && (t = x(t)),
        t instanceof o ? t.format() : o.prototype.format.call(t)
    }
    ,
    e.Url = o;
    var a = /^([a-z0-9.+-]+:)/i
      , s = /:[0-9]*$/
      , c = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/
      , h = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"])
      , l = ["'"].concat(h)
      , u = ["%", "/", "?", ";", "#"].concat(l)
      , p = ["/", "?", "#"]
      , d = /^[+a-z0-9A-Z_-]{0,63}$/
      , f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
      , m = {
        javascript: !0,
        "javascript:": !0
    }
      , g = {
        javascript: !0,
        "javascript:": !0
    }
      , v = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0
    }
      , y = n(68);
    function x(t, e, n) {
        if (t && i.isObject(t) && t instanceof o)
            return t;
        var r = new o;
        return r.parse(t, e, n),
        r
    }
    o.prototype.parse = function(t, e, n) {
        if (!i.isString(t))
            throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
        var o = t.indexOf("?")
          , s = -1 !== o && o < t.indexOf("#") ? "?" : "#"
          , h = t.split(s);
        h[0] = h[0].replace(/\\/g, "/");
        var x = t = h.join(s);
        if (x = x.trim(),
        !n && 1 === t.split("#").length) {
            var w = c.exec(x);
            if (w)
                return this.path = x,
                this.href = x,
                this.pathname = w[1],
                w[2] ? (this.search = w[2],
                this.query = e ? y.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "",
                this.query = {}),
                this
        }
        var b = a.exec(x);
        if (b) {
            var M = (b = b[0]).toLowerCase();
            this.protocol = M,
            x = x.substr(b.length)
        }
        if (n || b || x.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var _ = "//" === x.substr(0, 2);
            !_ || b && g[b] || (x = x.substr(2),
            this.slashes = !0)
        }
        if (!g[b] && (_ || b && !v[b])) {
            for (var E, S, T = -1, A = 0; A < p.length; A++)
                -1 !== (L = x.indexOf(p[A])) && (-1 === T || L < T) && (T = L);
            for (-1 !== (S = -1 === T ? x.lastIndexOf("@") : x.lastIndexOf("@", T)) && (E = x.slice(0, S),
            x = x.slice(S + 1),
            this.auth = decodeURIComponent(E)),
            T = -1,
            A = 0; A < u.length; A++) {
                var L;
                -1 !== (L = x.indexOf(u[A])) && (-1 === T || L < T) && (T = L)
            }
            -1 === T && (T = x.length),
            this.host = x.slice(0, T),
            x = x.slice(T),
            this.parseHost(),
            this.hostname = this.hostname || "";
            var R = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
            if (!R)
                for (var P = this.hostname.split(/\./), C = (A = 0,
                P.length); A < C; A++) {
                    var I = P[A];
                    if (I && !I.match(d)) {
                        for (var O = "", D = 0, U = I.length; D < U; D++)
                            I.charCodeAt(D) > 127 ? O += "x" : O += I[D];
                        if (!O.match(d)) {
                            var N = P.slice(0, A)
                              , B = P.slice(A + 1)
                              , z = I.match(f);
                            z && (N.push(z[1]),
                            B.unshift(z[2])),
                            B.length && (x = "/" + B.join(".") + x),
                            this.hostname = N.join(".");
                            break
                        }
                    }
                }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
            R || (this.hostname = r.toASCII(this.hostname));
            var F = this.port ? ":" + this.port : ""
              , k = this.hostname || "";
            this.host = k + F,
            this.href += this.host,
            R && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
            "/" !== x[0] && (x = "/" + x))
        }
        if (!m[M])
            for (A = 0,
            C = l.length; A < C; A++) {
                var H = l[A];
                if (-1 !== x.indexOf(H)) {
                    var G = encodeURIComponent(H);
                    G === H && (G = escape(H)),
                    x = x.split(H).join(G)
                }
            }
        var V = x.indexOf("#");
        -1 !== V && (this.hash = x.substr(V),
        x = x.slice(0, V));
        var j = x.indexOf("?");
        if (-1 !== j ? (this.search = x.substr(j),
        this.query = x.substr(j + 1),
        e && (this.query = y.parse(this.query)),
        x = x.slice(0, j)) : e && (this.search = "",
        this.query = {}),
        x && (this.pathname = x),
        v[M] && this.hostname && !this.pathname && (this.pathname = "/"),
        this.pathname || this.search) {
            F = this.pathname || "";
            var W = this.search || "";
            this.path = F + W
        }
        return this.href = this.format(),
        this
    }
    ,
    o.prototype.format = function() {
        var t = this.auth || "";
        t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"),
        t += "@");
        var e = this.protocol || ""
          , n = this.pathname || ""
          , r = this.hash || ""
          , o = !1
          , a = "";
        this.host ? o = t + this.host : this.hostname && (o = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"),
        this.port && (o += ":" + this.port)),
        this.query && i.isObject(this.query) && Object.keys(this.query).length && (a = y.stringify(this.query));
        var s = this.search || a && "?" + a || "";
        return e && ":" !== e.substr(-1) && (e += ":"),
        this.slashes || (!e || v[e]) && !1 !== o ? (o = "//" + (o || ""),
        n && "/" !== n.charAt(0) && (n = "/" + n)) : o || (o = ""),
        r && "#" !== r.charAt(0) && (r = "#" + r),
        s && "?" !== s.charAt(0) && (s = "?" + s),
        e + o + (n = n.replace(/[?#]/g, function(t) {
            return encodeURIComponent(t)
        })) + (s = s.replace("#", "%23")) + r
    }
    ,
    o.prototype.resolve = function(t) {
        return this.resolveObject(x(t, !1, !0)).format()
    }
    ,
    o.prototype.resolveObject = function(t) {
        if (i.isString(t)) {
            var e = new o;
            e.parse(t, !1, !0),
            t = e
        }
        for (var n = new o, r = Object.keys(this), a = 0; a < r.length; a++) {
            var s = r[a];
            n[s] = this[s]
        }
        if (n.hash = t.hash,
        "" === t.href)
            return n.href = n.format(),
            n;
        if (t.slashes && !t.protocol) {
            for (var c = Object.keys(t), h = 0; h < c.length; h++) {
                var l = c[h];
                "protocol" !== l && (n[l] = t[l])
            }
            return v[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = "/"),
            n.href = n.format(),
            n
        }
        if (t.protocol && t.protocol !== n.protocol) {
            if (!v[t.protocol]) {
                for (var u = Object.keys(t), p = 0; p < u.length; p++) {
                    var d = u[p];
                    n[d] = t[d]
                }
                return n.href = n.format(),
                n
            }
            if (n.protocol = t.protocol,
            t.host || g[t.protocol])
                n.pathname = t.pathname;
            else {
                for (var f = (t.pathname || "").split("/"); f.length && !(t.host = f.shift()); )
                    ;
                t.host || (t.host = ""),
                t.hostname || (t.hostname = ""),
                "" !== f[0] && f.unshift(""),
                f.length < 2 && f.unshift(""),
                n.pathname = f.join("/")
            }
            if (n.search = t.search,
            n.query = t.query,
            n.host = t.host || "",
            n.auth = t.auth,
            n.hostname = t.hostname || t.host,
            n.port = t.port,
            n.pathname || n.search) {
                var m = n.pathname || ""
                  , y = n.search || "";
                n.path = m + y
            }
            return n.slashes = n.slashes || t.slashes,
            n.href = n.format(),
            n
        }
        var x = n.pathname && "/" === n.pathname.charAt(0)
          , w = t.host || t.pathname && "/" === t.pathname.charAt(0)
          , b = w || x || n.host && t.pathname
          , M = b
          , _ = n.pathname && n.pathname.split("/") || []
          , E = (f = t.pathname && t.pathname.split("/") || [],
        n.protocol && !v[n.protocol]);
        if (E && (n.hostname = "",
        n.port = null,
        n.host && ("" === _[0] ? _[0] = n.host : _.unshift(n.host)),
        n.host = "",
        t.protocol && (t.hostname = null,
        t.port = null,
        t.host && ("" === f[0] ? f[0] = t.host : f.unshift(t.host)),
        t.host = null),
        b = b && ("" === f[0] || "" === _[0])),
        w)
            n.host = t.host || "" === t.host ? t.host : n.host,
            n.hostname = t.hostname || "" === t.hostname ? t.hostname : n.hostname,
            n.search = t.search,
            n.query = t.query,
            _ = f;
        else if (f.length)
            _ || (_ = []),
            _.pop(),
            _ = _.concat(f),
            n.search = t.search,
            n.query = t.query;
        else if (!i.isNullOrUndefined(t.search))
            return E && (n.hostname = n.host = _.shift(),
            (R = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = R.shift(),
            n.host = n.hostname = R.shift())),
            n.search = t.search,
            n.query = t.query,
            i.isNull(n.pathname) && i.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
            n.href = n.format(),
            n;
        if (!_.length)
            return n.pathname = null,
            n.search ? n.path = "/" + n.search : n.path = null,
            n.href = n.format(),
            n;
        for (var S = _.slice(-1)[0], T = (n.host || t.host || _.length > 1) && ("." === S || ".." === S) || "" === S, A = 0, L = _.length; L >= 0; L--)
            "." === (S = _[L]) ? _.splice(L, 1) : ".." === S ? (_.splice(L, 1),
            A++) : A && (_.splice(L, 1),
            A--);
        if (!b && !M)
            for (; A--; A)
                _.unshift("..");
        !b || "" === _[0] || _[0] && "/" === _[0].charAt(0) || _.unshift(""),
        T && "/" !== _.join("/").substr(-1) && _.push("");
        var R, P = "" === _[0] || _[0] && "/" === _[0].charAt(0);
        return E && (n.hostname = n.host = P ? "" : _.length ? _.shift() : "",
        (R = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) && (n.auth = R.shift(),
        n.host = n.hostname = R.shift())),
        (b = b || n.host && _.length) && !P && _.unshift(""),
        _.length ? n.pathname = _.join("/") : (n.pathname = null,
        n.path = null),
        i.isNull(n.pathname) && i.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
        n.auth = t.auth || n.auth,
        n.slashes = n.slashes || t.slashes,
        n.href = n.format(),
        n
    }
    ,
    o.prototype.parseHost = function() {
        var t = this.host
          , e = s.exec(t);
        e && (":" !== (e = e[0]) && (this.port = e.substr(1)),
        t = t.substr(0, t.length - e.length)),
        t && (this.hostname = t)
    }
}
, function(t, e, n) {
    var r = n(72)
      , i = n(65);
    function o(t, e, n, r, i) {
        "localhost" == location.hostname && (window.location.hostname = "127.0.0.1"),
        this.debugLog = !1,
        this.baseUrl = t,
        this.lobbySize = n,
        this.devPort = e,
        this.lobbySpread = r,
        this.rawIPs = !!i,
        this.server = void 0,
        this.gameIndex = void 0,
        this.callback = void 0,
        this.errorCallback = void 0,
        this.processServers(vultr.servers)
    }
    o.prototype.regionInfo = {
        0: {
            name: "Local",
            latitude: 0,
            longitude: 0
        },
        1: {
            name: "New Jersey",
            latitude: 40.1393329,
            longitude: -75.8521818
        },
        2: {
            name: "Chicago",
            latitude: 41.8339037,
            longitude: -87.872238
        },
        3: {
            name: "Dallas",
            latitude: 32.8208751,
            longitude: -96.8714229
        },
        4: {
            name: "Seattle",
            latitude: 47.6149942,
            longitude: -122.4759879
        },
        5: {
            name: "Los Angeles",
            latitude: 34.0207504,
            longitude: -118.691914
        },
        6: {
            name: "Atlanta",
            latitude: 33.7676334,
            longitude: -84.5610332
        },
        7: {
            name: "Amsterdam",
            latitude: 52.3745287,
            longitude: 4.7581878
        },
        8: {
            name: "London",
            latitude: 51.5283063,
            longitude: -.382486
        },
        9: {
            name: "Frankfurt",
            latitude: 50.1211273,
            longitude: 8.496137
        },
        12: {
            name: "Silicon Valley",
            latitude: 37.4024714,
            longitude: -122.3219752
        },
        19: {
            name: "Sydney",
            latitude: -33.8479715,
            longitude: 150.651084
        },
        24: {
            name: "Paris",
            latitude: 48.8588376,
            longitude: 2.2773454
        },
        25: {
            name: "Tokyo",
            latitude: 35.6732615,
            longitude: 139.569959
        },
        39: {
            name: "Miami",
            latitude: 25.7823071,
            longitude: -80.3012156
        },
        40: {
            name: "Singapore",
            latitude: 1.3147268,
            longitude: 103.7065876
        }
    },
    o.prototype.start = function(t, e) {
        this.callback = t,
        this.errorCallback = e;
        var n = this.parseServerQuery();
        n ? (this.log("Found server in query."),
        this.password = n[3],
        this.connect(n[0], n[1], n[2])) : (this.log("Pinging servers..."),
        this.pingServers())
    }
    ,
    o.prototype.parseServerQuery = function() {
        var t = r.parse(location.href, !0)
          , e = t.query.server;
        if ("string" == typeof e) {
            var n = e.split(":");
            if (3 == n.length)
                return [parseInt(n[0]), parseInt(n[1]), parseInt(n[2]), t.query.password];
            this.errorCallback("Invalid number of server parameters in " + e)
        }
    }
    ,
    o.prototype.findServer = function(t, e) {
        var n = this.servers[t];
        if (Array.isArray(n)) {
            for (var r = 0; r < n.length; r++) {
                var i = n[r];
                if (i.index == e)
                    return i
            }
            console.warn("Could not find server in region " + t + " with index " + e + ".")
        } else
            this.errorCallback("No server list for region " + t)
    }
    ,
    o.prototype.pingServers = function() {
        var t = this
          , e = [];
        for (var n in this.servers)
            if (this.servers.hasOwnProperty(n)) {
                var r = this.servers[n]
                  , i = r[Math.floor(Math.random() * r.length)];
                void 0 != i ? function(r, i) {
                    var o = new XMLHttpRequest;
                    o.onreadystatechange = function(r) {
                        var o = r.target;
                        if (4 == o.readyState)
                            if (200 == o.status) {
                                for (var a = 0; a < e.length; a++)
                                    e[a].abort();
                                t.log("Connecting to region", i.region);
                                var s = t.seekServer(i.region);
                                t.connect(s[0], s[1], s[2])
                            } else
                                console.warn("Error pinging " + i.ip + " in region " + n)
                    }
                    ;
                    var a = "//" + t.serverAddress(i.ip, !0) + ":" + t.serverPort(i) + "/ping";
                    o.open("GET", a, !0),
                    o.send(null),
                    t.log("Pinging", a),
                    e.push(o)
                }(0, i) : console.log("No target server for region " + n)
            }
    }
    ,
    o.prototype.seekServer = function(t, e) {
        void 0 == e && (e = "random");
        const n = ["random"];
        var r = this.lobbySize
          , i = this.lobbySpread
          , o = this.servers[t].flatMap(function(t) {
            var e = 0;
            return t.games.map(function(n) {
                var r = e++;
                return {
                    region: t.region,
                    index: t.index * t.games.length + r,
                    gameIndex: r,
                    gameCount: t.games.length,
                    playerCount: n.playerCount
                }
            })
        }).filter(function(t) {
            return "random" == e || n[t.index % n.length].key == e
        }).sort(function(t, e) {
            return e.playerCount - t.playerCount
        }).filter(function(t) {
            return t.playerCount < r
        });
        if (0 != o.length) {
            var a = Math.min(i, o.length)
              , s = Math.floor(Math.random() * a)
              , c = o[s = Math.min(s, o.length - 1)]
              , h = c.region
              , l = (s = Math.floor(c.index / c.gameCount),
            c.index % c.gameCount);
            return this.log("Found server."),
            [h, s, l]
        }
        this.errorCallback("No open servers.")
    }
    ,
    o.prototype.connect = function(t, e, n) {
        if (!this.connected) {
            var r = this.findServer(t, e);
            void 0 != r ? (this.log("Connecting to server", r, "with game index", n),
            r.games[n] && r.games[n].playerCount >= this.lobbySize ? this.errorCallback("Server is already full.") : (window.history.replaceState(document.title, document.title, this.generateHref(t, e, n, this.password)),
            this.server = r,
            this.gameIndex = n,
            this.callback(this.serverAddress(r.ip), this.serverPort(r), n))) : this.errorCallback("Failed to find server for region " + t + " and index " + e)
        }
    }
    ,
    o.prototype.switchServer = function(t, e, n, r) {
        this.switchingServers = !0,
        window.location.href = this.generateHref(t, e, n, r)
    }
    ,
    o.prototype.generateHref = function(t, e, n, r) {
        var i = "/?server=" + t + ":" + e + ":" + n;
        return r && (i += "&password=" + encodeURIComponent(r)),
        i
    }
    ,
    o.prototype.serverAddress = function(t, e) {
        return "127.0.0.1" == t || "7f000001" == t || "903d62ef5d1c2fecdcaeb5e7dd485eff" == t ? window.location.hostname : this.rawIPs ? e ? "ip_" + this.hashIP(t) + "." + this.baseUrl : t : "ip_" + t + "." + this.baseUrl
    }
    ,
    o.prototype.serverPort = function(t) {
        return 0 == t.region ? this.devPort : location.protocol.startsWith("https") ? 443 : 80
    }
    ,
    o.prototype.processServers = function(t) {
        for (var e = {}, n = 0; n < t.length; n++) {
            var r = t[n]
              , i = e[r.region];
            void 0 == i && (i = [],
            e[r.region] = i),
            i.push(r)
        }
        for (var o in e)
            e[o] = e[o].sort(function(t, e) {
                return t.index - e.index
            });
        this.servers = e
    }
    ,
    o.prototype.ipToHex = function(t) {
        return t.split(".").map(t=>("00" + parseInt(t).toString(16)).substr(-2)).join("").toLowerCase()
    }
    ,
    o.prototype.hashIP = function(t) {
        return i(this.ipToHex(t))
    }
    ,
    o.prototype.log = function() {
        return this.debugLog ? console.log.apply(void 0, arguments) : console.verbose ? console.verbose.apply(void 0, arguments) : void 0
    }
    ;
    var a = function(t, e) {
        return t.concat(e)
    };
    Array.prototype.flatMap = function(t) {
        return function(t, e) {
            return e.map(t).reduce(a, [])
        }(t, this)
    }
    ,
    t.exports = o
}
, function(t, e, n) {
    var r = n(1)
      , i = "undefined" != typeof Storage;
    window.saveVal = function(t, e) {
        i && localStorage.setItem(t, e)
    }
    ,
    window.getSavedVal = function(t) {
        return i ? localStorage.getItem(t) : null
    }
    ;
    var o, a = new (n(73))("krunker.io",3e3,r.maxPlayers,r.playerSpread,!1);
    function s(t, e) {
        if (hostGameMsg && (hostGameMsg.innerHTML = t),
        e) {
            var n = a.generateHref(a.server.region, a.server.index, e);
            window.history.replaceState({}, "Krunker", n)
        } else
            o = null
    }
    window.switchServer = function(t, e, n) {
        a.switchServer(t, e, n)
    }
    ,
    window.createPrivateRoom = function() {
        for (var t = [], e = 0; e < _.length; e++)
            document.getElementById("gameMap" + e).checked && t.push(e);
        if (0 != t.length || "" != customMapData.value) {
            "" == (o = customMapData.value) && (o = null);
            var n = {
                customMap: o,
                maps: t
            };
            for (e = 0; e < r.serverConfig.length; e++) {
                var i = document.getElementById("customS" + r.serverConfig[e].varN);
                n[r.serverConfig[e].varN] = i ? parseFloat(i.value) : 0
            }
            b.send("custom", n),
            hostGameMsg.innerHTML = "Please wait..."
        } else
            hostGameMsg.innerHTML = "<span class='error'>Select at least one map</span>"
    }
    ,
    Object.defineProperty(console, "_commandLineAPI", {
        get: function() {
            throw ""
        }
    });
    var c = n(2);
    c.OBJLoader = n(45)(c);
    var h, l, u, p, d, f, m = n(13), g = new (n(44))(c,m,r), v = new (n(62))(m,r), y = new (n(61))(g,r), x = n(60), w = new (n(59))(g,r), b = n(43), M = new (n(58))(g,c,x,m,r,b), _ = n(11).maps, E = (n(11).modes,
    n(57).obj), S = n(51);
    E = new E(0,r,null,m,g,v,y);
    var T, A, L, R, P = [], C = 0, I = 0, O = 0;
    window.idleTimer = 0,
    Math.PI2 = 2 * Math.PI,
    Math.lerpAngle = function(t, e, n) {
        Math.abs(e - t) > Math.PI && (t > e ? e += Math.PI2 : t += Math.PI2);
        var r = e + (t - e) * n;
        return r >= 0 && r <= Math.PI2 ? r : r % Math.PI2
    }
    ,
    console.warn = (t=>{}
    ),
    console.info = (t=>{}
    );
    var D, U, N = !1;
    function B() {
        window.innerWidth,
        D = window.innerHeight,
        U = D / 693,
        g.resize()
    }
    window.loading = !1,
    window.enterGame = function() {
        if (E.singlePlayer && !N) {
            ot("0:00");
            var t = E.getSpawnPoint(null, !0);
            dt([b.socketId, 1, t.x, t.y, t.z, "TEST", Q, null]),
            N = !0,
            yt([1, "TEST", 0, 0]),
            x.toggleMenu(!1)
        } else
            b.connected && !N && (N = !0,
            window.idleTimer = 0,
            x.toggleMenu(!1),
            instructions.innerHTML = "LOADING...",
            window.loading = !0,
            b.send("enter", [Q, lt]))
    }
    ,
    window.addEventListener("resize", B),
    B();
    const z = new FileReader;
    var F, k, H = !1, G = 0, V = {};
    function j() {
        N = !1,
        window.idleTimer = 0,
        x.toggleMenu(!0),
        M.toggle(!1)
    }
    window.voiceChat = function(t, e) {
        if (G)
            try {
                var n = new Howl({
                    src: [t]
                });
                n.on("load", function() {
                    n.duration() <= r.voiceChatMaxLength && (n.on("end", function() {
                        if (V[e]--,
                        V[e] <= 0) {
                            var t = document.getElementById("speaker" + e);
                            t && t.parentElement.removeChild(t),
                            delete V[e]
                        }
                    }),
                    V[e] || (V[e] = 0,
                    speakerDisplay.innerHTML += "<div id='speaker" + e + "' class='voiceSpeaker'>" + e + " <i class='material-icons' style='color:#fff;font-size:35px;vertical-align:middle'>volume_down</i></div>"),
                    V[e]++,
                    n.play())
                })
            } catch (t) {}
    }
    ,
    z.addEventListener("loadend", t=>{
        var e = z.result;
        b.send("vc", e)
    }
    ),
    window.toggleRecord = function(t) {
        h && l && (t && !H ? (voiceDisplay.style.opacity = .9,
        H = !0,
        navigator.mediaDevices.getUserMedia({
            audio: !0,
            video: !1
        }).then(t=>{
            (F = new MediaRecorder(t,{
                mimetype: "audio/ogg",
                bitsPerSecond: 6e3
            })).start();
            const e = [];
            F.addEventListener("dataavailable", t=>{
                e.push(t.data)
            }
            ),
            F.addEventListener("stop", ()=>{
                recTimer.style.display = "none",
                voiceDisplay.style.opacity = .3;
                var t = new Blob(e,{
                    type: "audio/ogg; codecs=opus"
                });
                z.readAsDataURL(t)
            }
            ),
            recTimer.style.display = "inline-block",
            recTimer.innerHTML = r.voiceChatMaxLength;
            var n = r.voiceChatMaxLength;
            k = setInterval(function() {
                n--,
                recTimer.innerHTML = n,
                n <= 0 && (H = !1,
                F.stop(),
                clearInterval(k))
            }, 1e3)
        }
        ).catch(function(t) {
            H = !1,
            k && clearInterval(k),
            voiceDisplay.style.opacity = .3
        })) : !t && H && F && (H = !1,
        F.stop(),
        clearInterval(k)))
    }
    ,
    window.updateSliderLabel = function(t, e) {
        var n = document.getElementById("customSet" + t);
        n && (n.innerHTML = e)
    }
    ,
    window.setSetting = function(t, e) {
        document.getElementById("slid" + t) && (document.getElementById("slid" + t).innerHTML = e),
        W[t].set(e),
        W[t].val = e,
        saveVal("setti_" + t, e)
    }
    ;
    for (var W = [{
        name: "<div style='width:100%'><a href='javascript:;' onclick='showWindow(7);' class='menuLink'>Change Controls</a></div>",
        html: function() {
            return ""
        }
    }, {
        name: "Resolution",
        val: .7,
        html: function() {
            return "<span class='sliderVal' id='slid1'>" + W[1].val + "</span><div class='slidecontainer'><input type='range' min='0.1' max='2' step='0.1' value='" + W[1].val + "' class='sliderM' oninput='setSetting(1, this.value)'></div>"
        },
        set: function(t) {
            g.setResMlt(t)
        }
    }, {
        name: "Sensitivity",
        val: 1,
        html: function() {
            return "<span class='sliderVal' id='slid2'>" + W[2].val + "</span><div class='slidecontainer'><input type='range' min='0.1' max='10' step='0.1' value='" + W[2].val + "' class='sliderM' oninput='setSetting(2, this.value)'></div>"
        },
        set: function(t) {
            M.sensMlt = t
        }
    }, {
        name: "Field of View",
        val: r.fov,
        html: function() {
            return "<span class='sliderVal' id='slid3'>" + W[3].val + "</span><div class='slidecontainer'><input type='range' min='60' max='100' step='5' value='" + W[3].val + "' class='sliderM' oninput='setSetting(3, this.value)'></div>"
        },
        set: function(t) {
            g.setFov(t)
        }
    }, {
        name: "Sound",
        val: 1,
        html: function() {
            return "<span class='sliderVal' id='slid4'>" + W[4].val + "</span><div class='slidecontainer'><input type='range' min='0' max='1' step='0.1' value='" + W[4].val + "' class='sliderM' oninput='setSetting(4, this.value)'></div>"
        },
        set: function(t) {
            v.setVolume(t)
        }
    }, {
        name: "Particles",
        val: !0,
        html: function() {
            return "<label class='switch'><input type='checkbox' onclick='setSetting(5, this.checked)' " + (W[5].val ? "checked" : "") + "><span class='slider'></span></label>"
        },
        set: function(t) {
            y.active = t
        }
    }, {
        name: "Invert Y-Axis",
        val: !1,
        html: function() {
            return "<label class='switch'><input type='checkbox' onclick='setSetting(6, this.checked)' " + (W[6].val ? "checked" : "") + "><span class='slider'></span></label>"
        },
        set: function(t) {
            M.invertY = t
        }
    }, {
        name: "Show Chat",
        val: !0,
        html: function() {
            return "<label class='switch'><input type='checkbox' onclick='setSetting(7, this.checked)' " + (W[7].val ? "checked" : "") + "><span class='slider'></span></label>"
        },
        set: function(t) {
            chatHolder.style.display = t ? "block" : "none"
        }
    }, {
        name: "Voice Volume",
        val: 1,
        html: function() {
            return "<span class='sliderVal' id='slid9'>" + W[8].val + "</span><div class='slidecontainer'><input type='range' min='0' max='1' step='0.1' value='" + W[8].val + "' class='sliderM' oninput='setSetting(8, this.value)'></div>"
        },
        set: function(t) {
            G = t
        }
    }, {
        name: "Crosshair Color",
        val: "#ffffff",
        html: function() {
            return "<input type='color' id='head' name='color' value='" + W[9].val + "' oninput='setSetting(9, this.value)' style='float:right;margin-top:5px'/>"
        },
        set: function(t) {
            crosshairT.style.backgroundColor = t,
            crosshairB.style.backgroundColor = t,
            crosshairLL.style.backgroundColor = t,
            crosshairRL.style.backgroundColor = t
        }
    }, {
        name: "Weapon Bobbing",
        val: 1,
        html: function() {
            return "<span class='sliderVal' id='slid10'>" + W[10].val + "</span><div class='slidecontainer'><input type='range' min='0' max='2' step='0.1' value='" + W[10].val + "' class='sliderM' oninput='setSetting(10, this.value)'></div>"
        },
        set: function(t) {
            g.weaponLean = t
        }
    }], Y = 0; Y < W.length; ++Y)
        if (W[Y].set) {
            var X = getSavedVal("setti_" + Y);
            W[Y].val = null !== X ? X : W[Y].val,
            "false" == W[Y].val && (W[Y].val = !1),
            W[Y].set(W[Y].val, !0)
        }
    function q(t) {
        l && l.setData(t),
        "block" == windowHolder.style.display && 5 == tt && showWindow(5, !0)
    }
    function Z(t) {
        try {
            accResp.innerHTML = t || "",
            accResp.style.display = t ? "block" : "none"
        } catch (t) {}
    }
    function J(t, e) {
        t >= 0 && Z("Please Wait..."),
        b.send("a", t, e)
    }
    function K(t, e, n, i, o) {
        t ? Z(t) : (l = new S(e,n,null,r),
        saveVal("krunker_username", n),
        q(i),
        o && saveVal("krunker_token", o))
    }
    window.changeCont = function(t) {
        showWindow(7, !0),
        t <= 3 ? M.inputChanger = t : 4 == t ? M.inputChanger = "jumpKey" : 5 == t ? M.inputChanger = "crouchKey" : 6 == t ? M.inputChanger = "swapKeyD" : 7 == t ? M.inputChanger = "swapKeyU" : 8 == t ? M.inputChanger = "reloadKey" : 9 == t ? M.inputChanger = "sprayKey" : 10 == t ? M.inputChanger = "aimKey" : 11 == t ? M.inputChanger = "chatKey" : 12 == t && (M.inputChanger = "voiceKey"),
        document.getElementById("cont" + t).innerHTML = "Press any Key"
    }
    ,
    window.registerAcc = function() {
        J(0, [accName.value, accPass.value])
    }
    ,
    window.loginAcc = function() {
        J(1, [accName.value, accPass.value, null])
    }
    ,
    window.logoutAcc = function() {
        J(-1),
        Z(),
        i && localStorage.removeItem("krunker_token"),
        l = null,
        q()
    }
    ;
    var Q = getSavedVal("classindex") || 0;
    window.selectClass = function(t) {
        saveVal("classindex", t),
        Q = t,
        showWindow(3)
    }
    ;
    var $ = [{
        header: "Game Settings",
        gen: function() {
            for (var t = "", e = 0; e < W.length; ++e)
                t += "<div class='settName'>" + W[e].name + " " + W[e].html() + "</div>";
            return t
        }
    }, {
        header: "Server Browser",
        lastLoadTime: 0,
        gen: function() {
            return Date.now() - this.lastLoadTime < 1e4 ? this.genList() : this.loadData()
        },
        loadData: function() {
            var t = new XMLHttpRequest
              , e = this;
            return t.onreadystatechange = function() {
                4 == this.readyState && (200 == this.status ? (window.vultr = JSON.parse(this.responseText),
                a.processServers(vultr.servers),
                e.lastLoadTime = Date.now(),
                window.showWindow(2, !0)) : console.error("Failed to load server data with status code:", this.status))
            }
            ,
            t.open("GET", "/serverData", !0),
            t.send(),
            "Loading..."
        },
        expandedRegion: -1,
        genList: function() {
            var t = this;
            window.setExpandedRegion = function(e) {
                t.expandedRegion = e,
                t.lastLoadTime = Date.now(),
                showWindow(2, !0)
            }
            ;
            var e = "<div style='font-size:20px'>";
            e += "<a class='menuLink' onclick='showWindow(8)'>Host Game</a><div style='height:10px'></div>";
            var n = 0
              , i = 0;
            for (var o in a.servers) {
                for (var s = a.servers[o], c = 0, h = 0; h < s.length; h++)
                    for (var l = 0; l < s[h].games.length; l++)
                        c += s[h].games[l].playerCount;
                n += c;
                var u = a.regionInfo[o].name
                  , p = u + " - " + c + " online"
                  , d = this.expandedRegion == i;
                if (e += "<div class='menuSelectorHeader' onclick='setExpandedRegion(" + (d ? -1 : i) + ")' style='cursor: pointer;'>" + (d ? "&#x25BC;" : "&#x25B6;") + " " + p + "</div>",
                d) {
                    e += "<div class='menuSelectorHolder'>";
                    for (var f = 0; f < s.length; f++)
                        for (var m = s[f], g = 0; g < m.games.length; g++) {
                            var v = m.games[g]
                              , y = m.index * r.gamesPerServer + g + 1
                              , x = a.server && a.server.region == m.region && a.server.index == m.index && a.gameIndex == g
                              , w = u + " " + y + " - " + v.playerCount + "/" + r.maxPlayers + " online";
                            e += "<div class='menuSelector" + (x ? " selectedMenuSelector" : "") + "' onclick='switchServer(" + o + "," + f + "," + g + ")'>" + w + "</div>"
                        }
                    e += "</div>"
                }
                e += "<br/>",
                i++
            }
            return (e += "<b>" + n + " total online</b>") + "</div>"
        }
    }, {
        header: "Change Loadout",
        gen: function() {
            var t = E.classes[Q];
            return "<div class='settName'>Class<span class='settText floatR' onclick='showWindow(6)'>" + t.name + "</span></div><div class='settName'>Primary<span class='settLabel'>" + E.weapons[t.loadout[0]].name + "</span></div><div class='settName'>Secondary<span class='settLabel'>" + (t.loadout[1] ? E.weapons[t.loadout[1]].name : "None") + "</span></div><div class='settName'>Spray<span onclick='showWindow(9)' class='settText floatR'>" + E.sprays[lt].name + "</span></div>"
        }
    }, {
        header: "Mod Manager",
        gen: function() {
            return "<div id='modLinks'><a href='./docs/mods.txt' class='menuLink'>Mod Guide</a> | <a href='' class='menuLink'>Find Mods</a></div><form id='modDropper'><input onchange='loadMod()' id='modInput'type='file'><p id='modLInfo'>drop mod file here or click</p></form>"
        }
    }, {
        header: "Account",
        gen: function() {
            return l ? "<div class='settName'>Name<span class='floatR'>" + l.name + "</span></div><div class='settName'>Level<span class='floatR'><img src='./img/levels/" + Math.max(Math.min(r.maxLevel, l.level.roundToNearest(3) - 2), 0) + ".png' class='rnkIcon'>" + l.level + "</span></div><div class='settName'>Score<span class='floatR'>" + l.score + "</span></div><div class='settName'>Kills<span class='floatR'>" + l.kills + "</span></div><div class='settName'>Deaths<span class='floatR'>" + l.deaths + "</span></div><div class='settName'>KDR<span class='floatR'>" + (l.kills / Math.max(l.deaths, 1)).toFixed(2) + "</span></div><div class='settName'>Games Played<span class='floatR'>" + l.games + "</span></div><div class='settName'>Games Won<span class='floatR'>" + l.wins + "</span></div><div class='settName'>W/L<span class='floatR'>" + (l.wins / Math.max(l.games - l.wins, 1)).toFixed(2) + "</span></div><div class='settName'>Time Played<span class='floatR'>" + m.getReadableTime(l.timePlayed) + "</span></div><div style='height:10px'></div><a class='menuLink' onclick='logoutAcc()'>Logout</a>" : "<input id='accName' type='text' placeholder='Username' class='accountInput' style='margin-top:0' value='" + (getSavedVal("krunker_username") || "") + "'></input><input id='accPass' type='password' placeholder='Password' class='accountInput'></input><div id='accResp' style='margin-top:15px;color:rgba(0,0,0,0.7);display:none'></div><div class='accountButton' onclick='registerAcc()'>Register</div><div class='accountButton' onclick='loginAcc()' style='margin-left: 20px'>Login</div>"
        }
    }, {
        header: "Select Class",
        gen: function() {
            for (var t = "", e = 0; e < E.classes.length; ++e)
                t += "<div class='selItem' style='margin-top:" + (e > 0 ? "10px" : "") + "'><div class='equipBtn' onclick='selectClass(" + e + ")'><i class='material-icons'>&#xE037</i></div><div class='itemIcon'><img class='itemIconImg' src='./textures/classes/icon_" + e + ".png'/></div><div class='itemInfo'><div class='itemName'>" + E.classes[e].name + "</div><div class='itemCat'>" + E.weapons[E.classes[e].loadout[0]].name + "</div></div></div>";
            return t
        }
    }, {
        header: "Change Controls",
        gen: function() {
            var t = "";
            return t += "<div class='settName'>Forward<span class='settText floatR' id='cont0' onclick='changeCont(0)'>" + m.getKeyName(M.moveKeys[0]) + "</span></div>",
            t += "<div class='settName'>Backward<span class='settText floatR' id='cont1' onclick='changeCont(1)'>" + m.getKeyName(M.moveKeys[1]) + "</span></div>",
            t += "<div class='settName'>Left<span class='settText floatR' id='cont2' onclick='changeCont(2)'>" + m.getKeyName(M.moveKeys[2]) + "</span></div>",
            t += "<div class='settName'>Right<span class='settText floatR' id='cont3' onclick='changeCont(3)'>" + m.getKeyName(M.moveKeys[3]) + "</span></div>",
            t += "<div class='settName'>Reload<span class='settText floatR' id='cont8' onclick='changeCont(8)'>" + m.getKeyName(M.reloadKey) + "</span></div>",
            t += "<div class='settName'>Aim<span class='settText floatR' id='cont10' onclick='changeCont(10)'>" + m.getKeyName(M.aimKey) + "</span></div>",
            t += "<div class='settName'>Spray<span class='settText floatR' id='cont9' onclick='changeCont(9)'>" + m.getKeyName(M.sprayKey) + "</span></div>",
            t += "<div class='settName'>Jump<span class='settText floatR' id='cont4' onclick='changeCont(4)'>" + m.getKeyName(M.jumpKey) + "</span></div>",
            t += "<div class='settName'>Crouch<span class='settText floatR' id='cont5' onclick='changeCont(5)'>" + m.getKeyName(M.crouchKey) + "</span></div>",
            t += "<div class='settName'>Next Weapon<span class='settText floatR' id='cont6' onclick='changeCont(6)'>" + m.getKeyName(M.swapKeyD) + "</span></div>",
            t += "<div class='settName'>Previous Weapon<span class='settText floatR' id='cont7' onclick='changeCont(7)'>" + m.getKeyName(M.swapKeyU) + "</span></div>",
            (t += "<div class='settName'>Chat<span class='settText floatR' id='cont11' onclick='changeCont(11)'>" + m.getKeyName(M.chatKey) + "</span></div>") + "<div class='settName'>Voice<span class='settText floatR' id='cont12' onclick='changeCont(12)'>" + m.getKeyName(M.voiceKey) + "</span></div>"
        }
    }, {
        header: "Host Custom Game",
        gen: function() {
            var t = "";
            t += "<div class='settName'>Select Maps</div>",
            t += "<div style='margin-top:5px'>";
            for (var e = 0; e < _.length; e++) {
                var n = _[e]
                  , i = "<label class='switch'><input id='gameMap" + e + "' type='checkbox' checked=''><span class='slider'></span></label>";
                t += "<div class='settNameSmall' style='margin:0'>" + m.capFirst(n.name) + i + "</div>"
            }
            for (t += "<div class='settNameSmall' style='margin:0;margin-top:10px'>Custom Map<input id='customMapData' type='text' class='formInput' placeholder='Paste map data' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false'></div><br/>",
            t += "</div>",
            t += "<div class='settName'>Settings</div>",
            e = 0; e < r.serverConfig.length; e++)
                t += "<div class='settNameSmall' style='margin-left:0'>" + (u = r.serverConfig[e]).name + "<span class='sliderVal' id='customSet" + e + "'>" + u.def + "</span><div class='slidecontainer'><input type='range' min='" + u.min + "' max='" + u.max + "' step='" + u.step + "' id='customS" + u.varN + "' value='" + u.def + "' oninput='updateSliderLabel(" + e + ",this.value)' class='sliderM'></div></div>";
            return t += "<div style='text-align:left;margin-top:30px'>",
            t += "<div style='color:#919191;margin-bottom:5px' id='hostGameMsg'></div>",
            (t += "<a class='menuLink' onclick='createPrivateRoom()'>Start Game</a><br/>") + "</div>"
        }
    }, {
        header: "Select Spray",
        gen: function() {
            for (var t = "", e = 0; e < E.sprays.length; ++e)
                t += "<div class='selItem' style='margin-top:" + (e > 0 ? "10px" : "") + "'><div class='equipBtn' onclick='selectSpray(" + e + ")'><i class='material-icons'>&#xE037</i></div><div class='itemIcon'><img class='itemIconImg' src='./textures/sprays/" + e + ".png'/></div><div class='itemInfo'><div class='itemName'>" + E.sprays[e].name + "</div><div class='itemCat'>Default Spray</div></div></div>";
            return t
        }
    }, {
        header: "Custom Maps",
        gen: function() {
            return "<a href='./editor.html' class='menuLink'>Map Editor</a><br/><div style='margin-top:30px'>Test Custom Map</div><input id='mapData' type='text' placeholder='Paste Map Data' class='mapInput' autocomplete='off' autocorrect='off' autocapitalize='off' spellcheck='false'/><div class='mapLoadButton' onclick='loadCustomMap()'>Load</div>"
        }
    }];
    for (Y = 0; Y < $.length; ++Y)
        $[Y].html = "";
    var tt = 0;
    window.showWindow = function(t, e) {
        window.idleTimer = 0,
        e || t && ("block" != windowHolder.style.display || t != tt) ? ($[t - 1].gen ? menuWindow.innerHTML = $[t - 1].gen() : menuWindow.innerHTML = $[t - 1].html,
        tt = t,
        windowHeader.innerHTML = $[t - 1].header,
        x.toggleWindow(!0)) : (x.toggleWindow(!1),
        M.inputChanger = null)
    }
    ,
    window.loadCustomMap = function() {
        It(null, !0),
        E.singlePlayer = !0;
        try {
            at(0, null, {
                maps: [0]
            }, mapData.value, !0)
        } catch (t) {}
    }
    ,
    zip.workerScriptsPath = "./libs/";
    var et = new FileReader;
    function nt(t) {
        this.imgAsDataURL = "",
        this.process = function(e) {
            if (this.imgAsDataURL = URL.createObjectURL(e),
            this.imgAsDataURL && t) {
                try {
                    var n = new Image;
                    n.onload = function() {
                        g.updateTexture(t.replace("textures/", "").replace(".png", ""), this)
                    }
                    ,
                    n.src = this.imgAsDataURL
                } catch (t) {}
                it.close()
            }
        }
    }
    function rt(t) {
        this.filename = t;
        var e = this;
        this.process = function(t) {
            var n = URL.createObjectURL(t);
            if (n) {
                try {
                    var r = e.filename.split("/")[1];
                    v.sounds[r] = new Howl({
                        src: [n],
                        format: "mp3"
                    }),
                    "ambient_1" == r && v.play("ambient_1", .12, !0)
                } catch (t) {}
                it.close()
            }
        }
    }
    et.onload = function(t) {
        !function(t) {
            try {
                var e = "";
                zip.createReader(new zip.Data64URIReader(t), function(t) {
                    t.getEntries(function(n) {
                        if (n.length) {
                            it.init(t, n.length);
                            for (var r = 0; r < n.length; r++) {
                                var i = n[r];
                                i.directory ? it.close() : "textures" == (e = i.filename.split("/")[0]) ? i.getData(new zip.BlobWriter("image/png"), new nt(i.filename).process, function(t, e) {}) : "sound" == e && i.getData(new zip.BlobWriter("audio/mp3"), new rt(i.filename.replace(".mp3", "")).process, function(t, e) {})
                            }
                        }
                    })
                }, function(t) {
                    modLInfo.innerHTML = "mod error!"
                })
            } catch (t) {
                modLInfo.innerHTML = "mod error!"
            }
        }(t.target.result)
    }
    ;
    var it = new function() {
        this.init = function(t, e) {
            this.numFiles = e,
            this.progress = 0,
            this.reader = t
        }
        ,
        this.close = function() {
            this.reader && (this.progress++,
            modLInfo.innerHTML = "extracting " + this.progress + "/" + this.numFiles,
            this.numFiles === this.progress && (spriteIndex = 0,
            modLInfo.innerHTML = "success!",
            this.reader.close(),
            this.reader = void 0))
        }
    }
    ;
    function ot(t, e) {
        O = e,
        pt(t),
        x.toggleMenu(!1),
        function() {
            bt.length = 0,
            At.length = 0,
            x.toggleGameUI(!0),
            w.reset(),
            M.reset(),
            E.players.forcePos(),
            P.length = 0,
            window.loading = !1,
            window.idleTimer = 0,
            instructions.innerHTML = "CLICK TO PLAY",
            f = null;
            for (var t = 0; t < playerInfos.children.length; t++)
                playerInfos.children[t].style.display = "none"
        }(),
        x.toggleControlUI(M.enabled)
    }
    function at(t, e, n, r, i) {
        r || o ? (E.customMap(r || o, !0),
        o = null) : E.map.setMaps(),
        E.applyConfig(n),
        E.init(t, e, i),
        R = null,
        M.reset();
        var a = E.map.maps[t];
        M.moveCam(a.camPos[0], a.camPos[1], a.camPos[2]),
        M.rotateCam(0, 0, 0),
        g.clearSprays(),
        g.scene.add(M.object),
        h = null,
        playerInfos.innerHTML = "",
        killsVal.innerHTML = 0,
        I = 0,
        j()
    }
    function st(t, e, n) {
        instructions.innerHTML = "CLICK TO PLAY",
        victoryText.innerHTML = e ? "VICTORY" : "DEFEAT",
        victorySub.src = "./img/" + (e ? "sub" : "defeat") + ".png",
        h && h.active ? (x.showEndScreen(),
        R = r.endAnim,
        setTimeout(function() {
            M.disable(),
            ct(n)
        }, r.endAnim)) : t && (M.disable(),
        x.showEndScreen(),
        ct(n))
    }
    function ct(t) {
        if (t && t.length) {
            endTable.style.display = "inline-block";
            for (var e = "<tr><th>Rank</th>", n = r.endStats.length, i = 1; i < n; ++i)
                e += "<th>" + m.capFirst(r.endStats[i]) + "</th>";
            e += "</tr>";
            var o = 1;
            for (i = 0; i < t.length; ) {
                if (u = E.players.findBySid(t[i])) {
                    e += "<tr style='" + (i + n >= t.length ? "border-bottom:none" : "") + "'><td style='color:#fff'>" + o + ".</td>";
                    for (var a = 1; a < n; ++a)
                        e += "<td " + (1 != a ? "" : "style='color:" + (h && h.sid == u.sid ? "#fff'" : h && h.team && h.team == u.team ? "rgba(255,255,255,0.6)'" : "#eb5656'")) + ">" + t[i + a] + "</td>"
                }
                e += "</tr>",
                o++,
                i += n
            }
            endTable.innerHTML = e
        }
    }
    function ht(t, e, n) {
        E.playerSound(t, e, n)
    }
    window.loadMod = function() {
        if (modInput.files && modInput.files[0]) {
            var t = modInput.files[0];
            "zip" == t.name.split(".").pop().toLowerCase() ? (modLInfo.innerHTML = "loading mod...",
            et.readAsDataURL(t)) : modLInfo.innerHTML = "invalid mod file!"
        }
    }
    ;
    var lt = getSavedVal("sprayindex") || 0;
    function ut(t, e, n, r, i, o, a) {
        g.addSpray(t, e, n, r, i, o, a, E.sprays[e].opacity)
    }
    function pt(t, e) {
        e ? endTimer.innerHTML = "Next Round in " + t : timerVal.innerHTML = t
    }
    function dt(t) {
        for (var e = 0; e < t.length; ) {
            var n = t[e] == b.socketId;
            if ((u = E.players.add(t[e], t[e + 1], t[e + 2], t[e + 3], t[e + 4], t[e + 5], t[e + 6], n)).health = null == t[e + 7] ? u.maxHealth : t[e + 7],
            u.team = t[e + 8],
            u.level = t[e + 9],
            n)
                h = u;
            else {
                playerInfos.innerHTML += "<div id='pInfo" + u.sid + "' class='playerInfo'>" + (u.level ? "<div class='playerRank' id='pInfoR" + u.sid + "'>" + u.level + "</div>" : "") + "<div class='pInfoH' id='pInfoH" + u.sid + "'>" + u.name + "<div></div><div class='playerHealth'><div class='healthBar" + (O && O == u.team ? "" : "E") + "' id='healthBarE" + u.sid + "'></div></div></div></div>";
                var r = document.getElementById("pInfoH" + u.sid);
                r && (r.style.textAlign = u.level ? "left" : "center")
            }
            Tt(u.health, u.sid, null, null),
            e += 10
        }
    }
    function ft(t) {
        if (b.send("p"),
        h) {
            h.x = t[1],
            h.y = t[2],
            h.z = t[3],
            h.xVel = t[4],
            h.yVel = t[5],
            h.zVel = t[6],
            h.onGround = t[7],
            h.didJump = t[8],
            h.onLadder = t[9],
            h.aimVal = t[10],
            h.crouchVal = t[11],
            E.players.swapWeapon(h, 0, !1, t[12]);
            for (var e = 0; e < M.tmpInputs.length; )
                M.tmpInputs[e][0] <= t[0] ? M.tmpInputs.splice(e, 1) : (h.processInput(M.tmpInputs[e], E, !0),
                e++)
        }
    }
    function mt(t) {
        E.players.hideAll();
        for (var e = 0; e < t.length; )
            (u = E.players.findBySid(t[e])) && u != h && (u.objInstances.visible = !0,
            u.forcePos ? (u.x = t[e + 1],
            u.y = t[e + 2],
            u.z = t[e + 3],
            u.xDir = t[e + 4],
            u.yDir = t[e + 5],
            u.interpolate = !1,
            u.forcePos = !1) : (u.dt = 0,
            u.x1 = u.x,
            u.x2 = t[e + 1],
            u.y1 = u.y,
            u.y2 = t[e + 2],
            u.z1 = u.z,
            u.z2 = t[e + 3],
            u.xDir1 = u.xDir,
            u.xDir2 = t[e + 4],
            u.yDir1 = u.yDir,
            u.yDir2 = t[e + 5],
            u.interpolate = !0),
            u.onGround = t[e + 6],
            u.crouchVal = t[e + 7],
            E.players.swapWeapon(u, 0, !1, t[e + 8])),
            e += 9
    }
    function gt(t) {
        E.players.remove(t)
    }
    function vt(t, e, n) {
        if (u = E.players.findBySid(t),
        p = E.players.findBySid(e),
        u) {
            if (E.players.kill(u),
            u.isYou) {
                var i = "";
                p && (M.camLookAt(p.x, p.y + p.height - r.cameraHeight, p.z),
                p.interpolate = !1,
                p.inView = !0,
                i = "<img id='kCProfile' src='./textures/classes/icon_" + p.classIndex + ".png' />",
                i += "<div id='kCName'>" + (p ? p.name : "You") + "</div>",
                i += "<br/><div id='kCInfo'>[" + E.weapons[n[0]].name + "] <span id='kCInfoS'>+" + n[1] + "</span></div>"),
                killCard.innerHTML = i,
                x.toggleGameUI(!1),
                setTimeout(function() {
                    j()
                }, r.deathDelay)
            }
            var o = u == h ? "<span style='color:#fff'>You</span>" : "<span style='color:" + (O && O == u.team ? "#9eeb56" : "#eb5656") + "'>" + u.name + "</span>"
              , a = p == h ? "<span style='color:#fff'>You</span>" : p ? "<span style='color:" + (O && O == p.team ? "#9eeb56" : "#eb5656") + "'>" + p.name + "</span>" : "";
            Rt(null, p ? a + " killed " + o : o + " committed suicide", !0)
        }
    }
    function yt(t) {
        if (h) {
            for (var e = "", n = 1, r = 0; r < t.length; r += 4)
                e += "<div class='leaderItem'>",
                e += "<div class='leaderCounter'>" + n + ".</div>",
                e += "<div class='leaderName" + (t[r] == h.sid ? "M" : O && O == t[r + 2] ? "F" : "") + "'>" + t[r + 1] + "</div>",
                e += "<div class='leaderScore'>" + m.formatNum(t[r + 3]) + "</div>",
                e += "</div>",
                n++;
            leaderContainer.innerHTML = e
        }
    }
    function xt(t, e, n, i, o, a) {
        if (h && h.active) {
            if (u = E.players.findBySid(t)) {
                var s = u.y + u.height - r.cameraHeight - u.crouchVal * r.crouchDst
                  , c = m.getDistance3D(u.x, s, u.z, e, n, i)
                  , l = m.getDirection(u.z, u.x, i, e)
                  , p = m.getDirection(m.getDistance(u.x, u.z, e, i), n, 0, s);
                y.physObj(u.x, s, u.z, l, p, c, 0)
            }
            void 0 != o && y.effect(e, n, i, o, a, 0)
        }
    }
    function wt(t) {
        I += t,
        w.animateText(scoreText, "+" + I, 100, .38, 1100, 100, 0, function() {
            I = 0
        }),
        h.score += t
    }
    window.selectSpray = function(t) {
        saveVal("sprayindex", t),
        lt = t,
        showWindow(3)
    }
    ;
    var bt = [];
    function Mt(t, e, n) {
        Et(t),
        e && v.play("headshot"),
        killsVal.innerHTML = n
    }
    function _t() {
        Et(["Assist", r.assistScore])
    }
    function Et(t) {
        if (t) {
            for (var e = 0 == bt.length, n = 0; n < t.length; ++n)
                "" == t[n] ? n++ : bt.push(t[n]);
            e && function t(e) {
                bt.length > 0 && w.animateText(chalName, "<span class='cTxt'>" + bt[0] + "</span><div id='chalScore'>+" + bt[1] + "</div>", 130, .4, r.medalAnim, 100, e, function() {
                    bt.splice(0, 2),
                    t(0)
                })
            }(r.medalDelay)
        }
    }
    var St = 0;
    function Tt(t, e, n, i) {
        if (h && (u = void 0 == e || null == e ? h : E.players.findBySid(e))) {
            u.health = t;
            var o = t / u.maxHealth * 100;
            u == h ? (healthValue.innerHTML = t + " <span id='maxHP'>|" + u.maxHealth + "</span>",
            healthBarH.style.width = o + "%",
            healthBarH.style.backgroundColor = o <= 35 ? "#eb5656" : "#9eeb56",
            bloodDisplay.style.display = o <= 90 ? "block" : "none",
            bloodDisplay.style.opacity = 1 - o / 90,
            t < St && (void 0 != n && null != n && function(t, e) {
                for (var n = null, i = 0; i < At.length; ++i)
                    if (!At[i].life) {
                        n = At[i];
                        break
                    }
                n || (n = {},
                At.push(n)),
                n.life = r.hitLife,
                n.x = t,
                n.z = e
            }(n, i),
            v.play("impact_0", .8)),
            St = t) : document.getElementById("healthBarE" + e).style.width = o + "%"
        }
    }
    var At = [];
    function Lt(t, e) {
        v.play("hit_0", 3),
        w.animateDiv(hitmarker, 400, 100, 14)
    }
    function Rt(t, e, n) {
        for (chatList.innerHTML += n ? "<div class='chatItem'><span class='chatMsg'>" + e + "</span></div><br/>" : "<div class='chatItem'>" + (t || "unknown") + ": <span class='chatMsg'>" + e + "</span></div><br/>"; chatList.scrollHeight >= 250; )
            chatList.removeChild(chatList.childNodes[0])
    }
    window.pressButton = function(t) {
        t == M.chatKey && (document.activeElement != chatInput ? chatInput.focus() : ("" != chatInput.value && (b.send("c", chatInput.value),
        chatInput.value = ""),
        chatInput.blur())),
        h && h.active && t == M.sprayKey && b.send("s")
    }
    ;
    var Pt = void 0;
    function Ct(t) {
        Pt = t,
        showWindow(0),
        M.disable(),
        x.hideUI(),
        instructionHolder.style.display = "block",
        instructions.innerHTML = "<span style='color: rgba(255, 255, 255, 0.6)'>" + t + "</span><br/><span style='color: rgba(255, 255, 255, 0.6)'>Try seeking a new server by clicking <a href='//krunker.io'>here</a>.</span>",
        instructionHolder.style.pointerEvents = "all"
    }
    function It(t, e) {
        b.socket.onclose = function() {}
        ,
        b.socket.close(),
        e || (showWindow(0),
        M.disable(),
        x.hideUI(),
        instructionHolder.style.display = "block",
        instructions.innerText = t || "DISCONNECTED")
    }
    a.start(function(t, e, n) {
        var r = "//" + t + ":8008/?gameIndex=" + n;
        b.connect(r, function(t) {
            if (t) {
                if (void 0 != Pt)
                    return;
                It()
            } else
                j(),
                function() {
                    var t = getSavedVal("krunker_token")
                      , e = getSavedVal("krunker_username");
                    t && e && J(1, [e, null, t])
                }()
        }, {
            init: at,
            start: ot,
            cust: s,
            end: st,
            error: Ct,
            dc: It,
            t: pt,
            0: dt,
            1: mt,
            8: ft,
            2: gt,
            3: vt,
            4: Lt,
            5: wt,
            6: Mt,
            7: yt,
            9: xt,
            10: _t,
            h: Tt,
            s: ht,
            sp: ut,
            ch: Rt,
            vc: voiceChat,
            a: K,
            ua: q
        })
    }, function(t) {
        Ct(t)
    }),
    window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(t) {
        window.setTimeout(t, 1e3 / 60)
    }
    ,
    setInterval(function() {
        !E.singlePlayer && h && h.active && (b.send("0", P),
        P.length = 0)
    }, r.clientSendRate),
    setInterval(function() {
        if (!E.singlePlayer && h && h.active)
            for (var t = 0; t < E.players.list.length; ++t)
                (u = E.players.list[t]).active && u.objInstances && u != h && (u.inView = !0,
                O && O == u.team || null == E.canSee(h, u.x, u.y, u.z) || (u.inView = !1))
    }, r.nameVisRate),
    L = Date.now(),
    function t() {
        T = Date.now(),
        A = T - L,
        A = Math.min(A, r.dltMx),
        L = T,
        R > 0 && (R -= A) <= 0 && (R = 0),
        null != R && (A *= R / r.endAnim),
        h || (C += 1e-4 * A,
        C %= 2 * Math.PI,
        M.rotateCam(C, 0, 0)),
        M.update(A * E.config.deltaMlt),
        h && h.active && (M.skipScroll = !1,
		h["recoilAnimY"] = h.recoilAnimYOld ? h.recoilAnimYOld : h["recoilAnimY"],
        d = [M.getISN(), A * E.config.deltaMlt, M.xDir, M.yDir, r.movDirs.indexOf(M.moveDir), M.mouseDownL, M.mouseDownR || M.keys[M.aimKey] ? 1 : 0, M.keys[M.jumpKey] ? 1 : 0, M.keys[M.crouchKey] ? 1 : 0, M.keys[M.reloadKey] ? 1 : 0, M.scrollDelta],
        M.scrollDelta && (M.skipScroll = !0),
        M.scrollDelta = 0,
        M.tmpInputs.push(d),
        h.processInput(d, E),
        M.moveCam(h.x, h.y + h.height - r.cameraHeight, h.z),
		
		(function() {
            let camera = M;
            let localPlayer = h;
            let {funcs, constants} = E.getVars();
            let inputs = d;
            let game = E;
            let team = O;
            function init() {
                camera.camAimAt = function(x, y, z, dx, dy, dz) {
                    if (!x)
                        this.aimTarget = null;
                    else {
                        var a = funcs["getXDir"](this["object"].position.x, this["object"].position.y, this["object"]["position"].z, x, y, z)
                          , h = funcs["getDirection"](this["object"].position.z, this["object"].position.x, z, x);
                        this.aimTarget = {
                            xD: a,
                            yD: h
                        }
                    }
                }
                ;
                camera.updateOld = camera.update;
                camera.update = function() {
                    if (!this["target"] && this["aimTarget"]) {
                        if (cheatSettings.aimbot) {
                            this["object"].rotation.y = this["aimTarget"].yD;
                            this["pitchObject"].rotation.x = this["aimTarget"].xD
                        }
                        var c = Math.PI / 2;
                        this["pitchObject"].rotation.x = Math.max(-c, Math.min(c, this["pitchObject"].rotation.x));
                        this.yDir = (this["pitchObject"].rotation.x % Math.PI2).round(3);
                        this.xDir = (this["object"].rotation.y % Math.PI2)["round"](3)
                    }
                    let ret = this.updateOld.apply(this, arguments);
                    return ret
                }
                ;
                camera.resetOld = camera.reset;
                camera.reset = function() {
                    this.aimTarget = null;
                    let ret = this.resetOld.apply(this, arguments);
                    return ret
                }
            }
            if (!cheatSettings.aimInitialized) {
                init();
                cheatSettings.aimInitialized = true;
            }
            let closest;
            let closestDist = Infinity;
            if (localPlayer && localPlayer.active)
                for (let x = 0, r; x < game.players.list.length; ++x)
                    if ((r = game.players.list[x])["active"] && r.objInstances && r != localPlayer && (!team || team != r.team))
                        if (game.canSee(localPlayer, r.x, r.y, r.z) === null) {
                            var t = funcs.getDistance3D(localPlayer.x, localPlayer.y, localPlayer.z, r.x, r.y, r.z);
                            if (!closest || t < closestDist) {
                                closestDist = t;
                                closest = r
                            }
                        }
						
            if (closest) { //&& (camera.mouseDownR || camera.keys[camera.aimKey])) {
                camera.camAimAt(closest.x, 
					closest.y + constants.playerHeight - constants.headScale / 2 - constants.crouchDst * closest.crouchVal, 
					closest.z, 
					closest.x2 - closest.x1 - localPlayer.xVel, closest.y2 - closest.y1 - localPlayer.yVel, closest.z2 - closest.z1 - localPlayer.zVel);
					
				if (cheatSettings.autoShoot) {
					if(camera.mouseDownR != 1) {
						camera.mouseDownR = 1;
					}else{
						camera.mouseDownL = camera.mouseDownL == 1 ? 0 : 1;
					}
				}
			} else {
                camera.camAimAt(null);
				
				if (cheatSettings.autoShoot) {
					camera.mouseDownL = 0;
					if(camera.mouseDownR != 0) {
						camera.mouseDownR = 0;
					}
				}
			}
			
            if (cheatSettings.noRecoil) {
                inputs[3] = ((camera.pitchObject.rotation.x - localPlayer["recoilAnimY"] * constants["recoilMlt"]) % Math.PI2).round(3);
                localPlayer.recoilAnimYOld = localPlayer["recoilAnimY"];
                localPlayer["recoilAnimY"] = 0;
            } else {
                localPlayer.recoilAnimYOld = 0;
            }
            if (cheatSettings.infiniteAmmo) {
                localPlayer.ammos[localPlayer.weaponIndex] = Infinity;
            } else if (localPlayer.ammos[localPlayer.weaponIndex] === Infinity) {
                localPlayer.ammos[localPlayer.weaponIndex] = localPlayer.weapon.ammo;
            }
        }
        )(),
        M.rotateCam(0, h.recoilAnimY * r.recoilMlt, 0),
        x.updateCrosshair(Math.max(.05 * window.innerHeight, h.spread * U), h.aimVal * (h.weapon.melee || h.reloadTimer > 0 ? 0 : 1)),
        E.singlePlayer || function(t) {
            for (var e = P.length ? 1 : 0; e < t.length; )
                if (2 == e && f && f[2] == t[2] && f[3] == t[3])
                    P.push("x"),
                    e += 2;
                else {
                    if (5 == e && f && f[5] == t[5] && f[6] == t[6] && f[7] == t[7] && f[8] == t[8] && f[9] == t[9] && f[10] == t[10]) {
                        P.push("x");
                        break
                    }
                    P.push(t[e]),
                    e++
                }
            f = t
        }(d),
        Howler.pos(h.x, h.y + h.height - r.cameraHeight, h.z),
        Howler.orientation(Math.sin(M.xDir + Math.PI), M.yDir, Math.cos(M.xDir + Math.PI)),
        E.singlePlayer && h.y <= r.deathY && vt(h.sid)),
        E.update(A, T, h),
        function(t) {
            var e = "";
            if (h && h.active)
                for (var n = 0; n < At.length; ++n)
                    At[n].life && (At[n].life -= t,
                    At[n].life <= 0 && (At[n].life = 0),
                    e += "<div class='hitInd' style='transform: translate(0, -50%) rotate(" + (M.xDir + m.getDirection(At[n].x, At[n].z, h.x, h.z)) + "rad);opacity:" + At[n].life / r.hitLife + "'></div>");
            hitHolder.innerHTML = e
        }(A),
        w.update(A),
        "block" == menuHolder.style.display && r.isProd && (window.idleTimer += A,
        window.idleTimer >= r.kickTimer && It("Kicked for inactivity")),
        requestAnimFrame(t)
    }()
}
]);
